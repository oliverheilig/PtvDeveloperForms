
//----------------------
// <auto-generated>
//     Generated REST API Client Code Generator v1.8.10.0 on 16.11.2023 20:22:44
//     Using the tool OpenAPI Generator v7.1.0
// </auto-generated>
//----------------------


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using OpenAPIDateConverter = RoutingClient.Client.OpenAPIDateConverter;
using Polly;
using RestSharp;
using RestSharp.Serializers;
using RestSharpMethod = RestSharp.Method;
using RoutingClient.Client;
using RoutingClient.Model;
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;

using System.Net.Security;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreas</returns>
        ReachableAreas CalculateReachableAreas(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreas</returns>
        ApiResponse<ReachableAreas> CalculateReachableAreasWithHttpInfo(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable areas specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteReachableAreas(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable areas specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteReachableAreasWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasResponse</returns>
        ReachableAreasResponse GetReachableAreas(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasResponse</returns>
        ApiResponse<ReachableAreasResponse> GetReachableAreasWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasId</returns>
        ReachableAreasId StartAndCreateReachableAreas(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasId</returns>
        ApiResponse<ReachableAreasId> StartAndCreateReachableAreasWithHttpInfo(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0);
        #endregion Synchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreas</returns>
        System.Threading.Tasks.Task<ReachableAreas> CalculateReachableAreasAsync(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreas)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreas>> CalculateReachableAreasWithHttpInfoAsync(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable areas specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteReachableAreasAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable areas specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteReachableAreasWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasResponse</returns>
        System.Threading.Tasks.Task<ReachableAreasResponse> GetReachableAreasAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable areas calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreasResponse>> GetReachableAreasWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasId</returns>
        System.Threading.Tasks.Task<ReachableAreasId> StartAndCreateReachableAreasAsync(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasId)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableAreasId>> StartAndCreateReachableAreasWithHttpInfoAsync(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableAreasApi : IReachableAreasApiSync, IReachableAreasApiAsync
    {
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ReachableAreasApi : IReachableAreasApi
    {
        private RoutingClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableAreasApi() : this((string)null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableAreasApi(string basePath)
        {
            this.Configuration = RoutingClient.Client.Configuration.MergeConfigurations(
                RoutingClient.Client.GlobalConfiguration.Instance,
                new RoutingClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ReachableAreasApi(RoutingClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Configuration = RoutingClient.Client.Configuration.MergeConfigurations(
                RoutingClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ReachableAreasApi(RoutingClient.Client.ISynchronousClient client, RoutingClient.Client.IAsynchronousClient asyncClient, RoutingClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public RoutingClient.Client.IAsynchronousClient AsynchronousClient { get; set; }
        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public RoutingClient.Client.ISynchronousClient Client { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public RoutingClient.Client.IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public RoutingClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }
        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreas</returns>
        public ReachableAreas CalculateReachableAreas(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<ReachableAreas> localVarResponse = CalculateReachableAreasWithHttpInfo(waypoint, horizons, profile, horizonType, options);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreas</returns>
        public RoutingClient.Client.ApiResponse<ReachableAreas> CalculateReachableAreasWithHttpInfo(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0)
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->CalculateReachableAreas");
            }
            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->CalculateReachableAreas");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Operation = "ReachableAreasApi.CalculateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableAreas>("/reachable-areas", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreas</returns>
        public async System.Threading.Tasks.Task<ReachableAreas> CalculateReachableAreasAsync(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<ReachableAreas> localVarResponse = await CalculateReachableAreasWithHttpInfoAsync(waypoint, horizons, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates the areas which can be reached from a waypoint, within given horizons (limited to 25 km or 20 minutes). Use the asynchronous POST and GET requests for larger horizons or calculation of areas from a route.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information.</param>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreas)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<ReachableAreas>> CalculateReachableAreasWithHttpInfoAsync(string waypoint, List<int> horizons, string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'waypoint' is set
            if (waypoint == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'waypoint' when calling ReachableAreasApi->CalculateReachableAreas");
            }
            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->CalculateReachableAreas");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Operation = "ReachableAreasApi.CalculateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableAreas>("/reachable-areas", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Deletes calculated reachable areas specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteReachableAreas(Guid id, int operationIndex = 0)
        {
            DeleteReachableAreasWithHttpInfo(id);
        }
        /// <summary>
        ///  Deletes calculated reachable areas specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public RoutingClient.Client.ApiResponse<Object> DeleteReachableAreasWithHttpInfo(Guid id, int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableAreasApi.DeleteReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Deletes calculated reachable areas specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteReachableAreasAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteReachableAreasWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        ///  Deletes calculated reachable areas specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<Object>> DeleteReachableAreasWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableAreasApi.DeleteReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasResponse</returns>
        public ReachableAreasResponse GetReachableAreas(Guid id, int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<ReachableAreasResponse> localVarResponse = GetReachableAreasWithHttpInfo(id);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasResponse</returns>
        public RoutingClient.Client.ApiResponse<ReachableAreasResponse> GetReachableAreasWithHttpInfo(Guid id, int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableAreasApi.GetReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableAreasResponse>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasResponse</returns>
        public async System.Threading.Tasks.Task<ReachableAreasResponse> GetReachableAreasAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<ReachableAreasResponse> localVarResponse = await GetReachableAreasWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Gets the results of a reachable areas calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable areas.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasResponse)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<ReachableAreasResponse>> GetReachableAreasWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableAreasApi.GetReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableAreasResponse>("/reachable-areas/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableAreasId</returns>
        public ReachableAreasId StartAndCreateReachableAreas(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<ReachableAreasId> localVarResponse = StartAndCreateReachableAreasWithHttpInfo(horizons, waypoint, routeId, profile, horizonType, options);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableAreasId</returns>
        public RoutingClient.Client.ApiResponse<ReachableAreasId> StartAndCreateReachableAreasWithHttpInfo(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0)
        {
            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Operation = "ReachableAreasApi.StartAndCreateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Post<ReachableAreasId>("/reachable-areas", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableAreasId</returns>
        public async System.Threading.Tasks.Task<ReachableAreasId> StartAndCreateReachableAreasAsync(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<ReachableAreasId> localVarResponse = await StartAndCreateReachableAreasWithHttpInfoAsync(horizons, waypoint, routeId, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Starts and creates the areas which can be reached from a waypoint or from a route, within given horizons. This type of request is recommended when the &#x60;horizons&#x60; parameter is more than 20 minutes or 25 km.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizons">The distances [m] or travel times [s] of the horizons, depending on the **horizonType**. Limited to 5 horizons (or 3 with a **routeId**).</param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableAreasId)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<ReachableAreasId>> StartAndCreateReachableAreasWithHttpInfoAsync(List<int> horizons, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'horizons' is set
            if (horizons == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'horizons' when calling ReachableAreasApi->StartAndCreateReachableAreas");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "horizons", horizons));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Operation = "ReachableAreasApi.StartAndCreateReachableAreas";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReachableAreasId>("/reachable-areas", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableAreas", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableLocationsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteReachableLocations(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsResponse</returns>
        ReachableLocationsResponse GetReachableLocations(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsResponse</returns>
        ApiResponse<ReachableLocationsResponse> GetReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsId</returns>
        ReachableLocationsId StartAndCreateReachableLocations(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsId</returns>
        ApiResponse<ReachableLocationsId> StartAndCreateReachableLocationsWithHttpInfo(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0);
        #endregion Synchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableLocationsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes calculated reachable locations specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsResponse</returns>
        System.Threading.Tasks.Task<ReachableLocationsResponse> GetReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets the results of a reachable locations calculation specified by its ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableLocationsResponse>> GetReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsId</returns>
        System.Threading.Tasks.Task<ReachableLocationsId> StartAndCreateReachableLocationsAsync(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsId)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReachableLocationsId>> StartAndCreateReachableLocationsWithHttpInfoAsync(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IReachableLocationsApi : IReachableLocationsApiSync, IReachableLocationsApiAsync
    {
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ReachableLocationsApi : IReachableLocationsApi
    {
        private RoutingClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableLocationsApi() : this((string)null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ReachableLocationsApi(string basePath)
        {
            this.Configuration = RoutingClient.Client.Configuration.MergeConfigurations(
                RoutingClient.Client.GlobalConfiguration.Instance,
                new RoutingClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ReachableLocationsApi(RoutingClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Configuration = RoutingClient.Client.Configuration.MergeConfigurations(
                RoutingClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ReachableLocationsApi(RoutingClient.Client.ISynchronousClient client, RoutingClient.Client.IAsynchronousClient asyncClient, RoutingClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public RoutingClient.Client.IAsynchronousClient AsynchronousClient { get; set; }
        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public RoutingClient.Client.ISynchronousClient Client { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public RoutingClient.Client.IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public RoutingClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }
        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteReachableLocations(Guid id, int operationIndex = 0)
        {
            DeleteReachableLocationsWithHttpInfo(id);
        }
        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public RoutingClient.Client.ApiResponse<Object> DeleteReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableLocationsApi.DeleteReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteReachableLocationsWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        ///  Deletes calculated reachable locations specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<Object>> DeleteReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableLocationsApi.DeleteReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsResponse</returns>
        public ReachableLocationsResponse GetReachableLocations(Guid id, int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<ReachableLocationsResponse> localVarResponse = GetReachableLocationsWithHttpInfo(id);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsResponse</returns>
        public RoutingClient.Client.ApiResponse<ReachableLocationsResponse> GetReachableLocationsWithHttpInfo(Guid id, int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableLocationsApi.GetReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<ReachableLocationsResponse>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsResponse</returns>
        public async System.Threading.Tasks.Task<ReachableLocationsResponse> GetReachableLocationsAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<ReachableLocationsResponse> localVarResponse = await GetReachableLocationsWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Gets the results of a reachable locations calculation specified by its ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the calculated reachable locations.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsResponse)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<ReachableLocationsResponse>> GetReachableLocationsWithHttpInfoAsync(Guid id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("id", RoutingClient.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Operation = "ReachableLocationsApi.GetReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ReachableLocationsResponse>("/reachable-locations/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ReachableLocationsId</returns>
        public ReachableLocationsId StartAndCreateReachableLocations(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<ReachableLocationsId> localVarResponse = StartAndCreateReachableLocationsWithHttpInfo(horizon, locations, waypoint, routeId, profile, horizonType, options);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ReachableLocationsId</returns>
        public RoutingClient.Client.ApiResponse<ReachableLocationsId> StartAndCreateReachableLocationsWithHttpInfo(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0)
        {
            // verify the required parameter 'locations' is set
            if (locations == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'locations' when calling ReachableLocationsApi->StartAndCreateReachableLocations");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
                "application/json"
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizon", horizon));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Data = locations;
            localVarRequestOptions.Operation = "ReachableLocationsApi.StartAndCreateReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Post<ReachableLocationsId>("/reachable-locations", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReachableLocationsId</returns>
        public async System.Threading.Tasks.Task<ReachableLocationsId> StartAndCreateReachableLocationsAsync(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<ReachableLocationsId> localVarResponse = await StartAndCreateReachableLocationsWithHttpInfoAsync(horizon, locations, waypoint, routeId, profile, horizonType, options, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Starts the calculation of the sets of reachable and unreachable locations from the given ones and creates them as the result.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="horizon">The distance [m] or travel time [s] of the horizons, depending of the &#x60;horizonType&#x60; (limited to 100 km or 1 hours).</param>
        /// <param name="locations"></param>
        /// <param name="waypoint">The start or destination waypoint. The format of the waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road. By default the air-line connection between given and matched coordinates is not included in the distance or duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:   * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the distance or duration.   We will refer to this type of waypoint as an _off-road waypoint_.   * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.   the air-line connection between the waypoint coordinates and the matched coordinates   is included in the distance or duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,   e.g. garage exit at a different road.  See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="horizonType"> (optional)</param>
        /// <param name="options">Routing-relevant options like driving direction or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReachableLocationsId)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<ReachableLocationsId>> StartAndCreateReachableLocationsWithHttpInfoAsync(int horizon, Locations locations, string waypoint = default(string), Guid? routeId = default(Guid?), string profile = default(string), HorizonType horizonType = default(HorizonType), ReachableOptions options = default(ReachableOptions), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'locations' is set
            if (locations == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'locations' when calling ReachableLocationsApi->StartAndCreateReachableLocations");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
                "application/json"
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (waypoint != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint", waypoint));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizon", horizon));
            if (horizonType != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "horizonType", horizonType));
            }
            if (options != null)
            {
                if (options.DrivingDirection != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[drivingDirection]", options.DrivingDirection));
                }
                if (options.ReferenceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[referenceTime]", options.ReferenceTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
            }
            localVarRequestOptions.Data = locations;
            localVarRequestOptions.Operation = "ReachableLocationsApi.StartAndCreateReachableLocations";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<ReachableLocationsId>("/reachable-locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("StartAndCreateReachableLocations", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse CalculateRoute(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> CalculateRouteWithHttpInfo(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse CalculateRoutePost(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> CalculateRoutePostWithHttpInfo(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EtaResponse</returns>
        EtaResponse GetEstimatedTimeOfArrival(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EtaResponse</returns>
        ApiResponse<EtaResponse> GetEstimatedTimeOfArrivalWithHttpInfo(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a route for a previously calculated or alternative route ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        RouteResponse GetRouteByRouteId(Guid routeId, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a route for a previously calculated or alternative route ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        ApiResponse<RouteResponse> GetRouteByRouteIdWithHttpInfo(Guid routeId, int operationIndex = 0);
        #endregion Synchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> CalculateRouteAsync(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> CalculateRouteWithHttpInfoAsync(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> CalculateRoutePostAsync(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> CalculateRoutePostWithHttpInfoAsync(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EtaResponse</returns>
        System.Threading.Tasks.Task<EtaResponse> GetEstimatedTimeOfArrivalAsync(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EtaResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EtaResponse>> GetEstimatedTimeOfArrivalWithHttpInfoAsync(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a route for a previously calculated or alternative route ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        System.Threading.Tasks.Task<RouteResponse> GetRouteByRouteIdAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a route for a previously calculated or alternative route ID.
        /// </remarks>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RouteResponse>> GetRouteByRouteIdWithHttpInfoAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRoutingApi : IRoutingApiSync, IRoutingApiAsync
    {
    }
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class RoutingApi : IRoutingApi
    {
        private RoutingClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;
        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RoutingApi() : this((string)null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RoutingApi(string basePath)
        {
            this.Configuration = RoutingClient.Client.Configuration.MergeConfigurations(
                RoutingClient.Client.GlobalConfiguration.Instance,
                new RoutingClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public RoutingApi(RoutingClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Configuration = RoutingClient.Client.Configuration.MergeConfigurations(
                RoutingClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new RoutingClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoutingApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public RoutingApi(RoutingClient.Client.ISynchronousClient client, RoutingClient.Client.IAsynchronousClient asyncClient, RoutingClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");
            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = RoutingClient.Client.Configuration.DefaultExceptionFactory;
        }
        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public RoutingClient.Client.IAsynchronousClient AsynchronousClient { get; set; }
        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public RoutingClient.Client.ISynchronousClient Client { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public RoutingClient.Client.IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public RoutingClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse CalculateRoute(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<RouteResponse> localVarResponse = CalculateRouteWithHttpInfo(waypoints, routeId, profile, vehicle, options, monetaryCostOptions, results);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public RoutingClient.Client.ApiResponse<RouteResponse> CalculateRouteWithHttpInfo(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (waypoints != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("multi", "waypoints", waypoints));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            localVarRequestOptions.Operation = "RoutingApi.CalculateRoute";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<RouteResponse>("/routes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoute", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> CalculateRouteAsync(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<RouteResponse> localVarResponse = await CalculateRouteWithHttpInfoAsync(waypoints, routeId, profile, vehicle, options, monetaryCostOptions, results, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.   The format of each waypoint is &#x60;&lt;lat&gt;,&lt;lon&gt;[;&lt;attribute&gt;;&lt;attribute&gt;;...]&#x60; representing a point with the latitude value in degrees from south to north and the longitude value in degrees (WGS84/EPSG:4326) from west to east. This point will be matched to the nearest possible road.   By default the air-line connection between given and matched coordinates is not included in the route polyline, distance and duration. We will refer to this type of waypoint as an _on-road waypoint_.  The behaviour of a waypoint can be changed by appending the following attributes:    * &#x60;includeLastMeters&#x60; to include the air-line connection between given and matched coordinates in the route polyline, distance and duration.  We will refer to this type of waypoint as an _off-road waypoint_.  * &#x60;roadAccess&#x3D;&lt;lat&gt;,&lt;lon&gt;&#x60;, to use these coordinates for matching to the nearest road. Implies **includeLastMeters**, i.e.  the air-line connection between the waypoint coordinates and the matched coordinates  is included in the route polyline, distance and duration. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away,  e.g. garage exit at a different road.  * &#x60;matchSideOfStreet&#x60;, specifies that this waypoint will be reached at the side of street on which it is located.  This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.  * &#x60;radius&#x3D;&lt;distance&gt;&#x60;, influences the route course, so that the route passes an area defined by the given radius [m] (integer value).  This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.  &#x60;radius&#x60; must be &gt; 0 and is not compatible with any other attribute on the same waypoint except for &#x60;name&#x60;.  We will refer to this type of waypoint as a _route-manipulation waypoint_.  * &#x60;name&#x3D;&lt;name of waypoint&gt;&#x60;, is an identifier to reference this waypoint in the response.  * In order to influence the route course so that the route uses a specific ferry or railway connection between two locations the waypoint is formatted as follows:  &#x60;combinedTransport&#x3D;&lt;lat&gt;,&lt;lon&gt;,&lt;lat&gt;,&lt;lon&gt;&#x60;. Both locations will be matched to the nearest ports looking for a direct connection.  If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned.  If more than one connection is found, the best one will be used,  and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_.  This waypoint will not appear as a waypoint event in the response and may not be used as start or destination.  We will refer to this type of waypoint as a _combined-transport waypoint_.   See [here](./concepts/waypoints) for more information. (optional)</param>
        /// <param name="routeId">Instead of the waypoint mentioned above, a **routeId** from a previously calculated route or a matched track can be entered. More information and applying restrictions can be found [here](./concepts/waypoints). (optional)</param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<RouteResponse>> CalculateRouteWithHttpInfoAsync(List<string> waypoints = default(List<string>), Guid? routeId = default(Guid?), string profile = default(string), Vehicle vehicle = default(Vehicle), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (waypoints != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("multi", "waypoints", waypoints));
            }
            if (routeId != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "routeId", routeId));
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            localVarRequestOptions.Operation = "RoutingApi.CalculateRoute";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RouteResponse>("/routes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoute", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse CalculateRoutePost(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<RouteResponse> localVarResponse = CalculateRoutePostWithHttpInfo(routeRequest, profile, vehicle, driver, options, monetaryCostOptions, results);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public RoutingClient.Client.ApiResponse<RouteResponse> CalculateRoutePostWithHttpInfo(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0)
        {
            // verify the required parameter 'routeRequest' is set
            if (routeRequest == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'routeRequest' when calling RoutingApi->CalculateRoutePost");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
                "application/json"
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (driver != null)
            {
                if (driver.WorkingHoursPreset != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "driver[workingHoursPreset]", driver.WorkingHoursPreset));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            localVarRequestOptions.Data = routeRequest;
            localVarRequestOptions.Operation = "RoutingApi.CalculateRoutePost";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Post<RouteResponse>("/routes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoutePost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> CalculateRoutePostAsync(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<RouteResponse> localVarResponse = await CalculateRoutePostWithHttpInfoAsync(routeRequest, profile, vehicle, driver, options, monetaryCostOptions, results, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates a route by specifying a list of waypoints taking into account opening intervals and working hours.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeRequest"></param>
        /// <param name="profile">A profile defines a vehicle by a set of attributes, matching typical transport situations. It must be the name of one of the [predefined profiles](../data-api/concepts/profiles) such as _EUR_TRAILER_TRUCK_.  If this parameter is not specified and the first waypoint or the routeId is located in the Americas, _USA_8_SEMITRAILER_5AXLE_ is used as the default instead of _EUR_TRAILER_TRUCK_.  If the first waypoint or the routeId is located in the Americas but a non-American profile is specified or vice-versa, a warning is returned (routing only). Always use a profile which matches the region of the waypoints to obtain best results.  If the attributes of the profile do not fit to your vehicle, the values can be changed by the corresponding attributes in the **vehicle** parameter (routing only). (optional, default to &quot;EUR_TRAILER_TRUCK&quot;)</param>
        /// <param name="vehicle">Physical and legal properties of the vehicle such as its dimensions to override the values of the selected **profile**.  These parameters will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. Unsupported parameters such as **electricityType** for combustion vehicles should not be specified in the request.  Use array notation like &#x60;vehicle[emissionStandard]&#x3D;EURO_5&#x60; to set vehicle attributes. (optional)</param>
        /// <param name="driver">Options regarding the driver&#39;s working hours. (optional)</param>
        /// <param name="options">Routing-relevant options like date of travel or the use of additional data. Use array notation like &#x60;options[trafficMode]&#x3D;AVERAGE&#x60; to set options. (optional)</param>
        /// <param name="monetaryCostOptions">Relevant options to report the monetary costs of a route when _MONETARY_COSTS_ are requested in the **results**. Used for monetary cost routing when **options[routingMode]&#x3D;MONETARY** is set. The costs have to be specified in the currency that is set in **options[currency]**. (optional)</param>
        /// <param name="results">Comma-separated list that defines which results will be returned. _TOLL_COSTS_, _TOLL_SECTIONS_, _TOLL_SYSTEMS_ and _TOLL_EVENTS_ will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_. For electric vehicles and non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_ all emission values will be 0.  * &#x60;ROUTE_ID&#x60;     Response includes the route ID for recalculation.  * &#x60;LEGS&#x60;     Response includes information about the route **legs** defined as the parts of the route between two consecutive waypoints.  * &#x60;LEGS_POLYLINE&#x60;     Response includes the **polyline** of each of the **legs** in the format specified by **options[polylineFormat]**. _LEGS_ will automatically be included.  * &#x60;TOLL_COSTS&#x60;     Response includes the toll **costs** of the route.  * &#x60;TOLL_SECTIONS&#x60;     Response includes the list of toll **sections** defined by the toll operators.  * &#x60;TOLL_SYSTEMS&#x60;     Response includes the list of toll **systems** defined by the toll operators.  * &#x60;TOLL_EVENTS&#x60;     Response includes **events** when a toll road is entered, exited or a toll booth is passed.  * &#x60;POLYLINE&#x60;     Response includes the complete **polyline** of the entire route in the format specified by **options[polylineFormat]**.  * &#x60;MANEUVER_EVENTS&#x60;     Response includes **events** for a **maneuver** when the driver has to take an action, e.g. turn left or right.  * &#x60;BORDER_EVENTS&#x60;     Response includes **events** when a **border** of a country or subdivision is crossed by the route.  * &#x60;VIOLATION_EVENTS&#x60;     Response includes **events** when the route contains a **violation**, e.g. entering or exiting an area where passing with the current vehicle is prohibited.  * &#x60;VIOLATION_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each route violation. _VIOLATION_EVENTS_ will automatically be included.  * &#x60;WAYPOINT_EVENTS&#x60;     Response includes **events** when a **waypoint** is reached by the route.  * &#x60;UTC_OFFSET_CHANGE_EVENTS&#x60;     Response includes **events** when the offset to UTC changes (**utcOffsetChange**).  * &#x60;COMBINED_TRANSPORT_EVENTS&#x60;     Response includes **events** when a combined transport is entered or exited.  * &#x60;TRAFFIC_EVENTS&#x60;     Response includes **events** when a traffic incident such as a traffic jam is reached by the route.  * &#x60;TRAFFIC_EVENTS_POLYLINE&#x60;     The response contains the **polyline** of each traffic events. _TRAFFIC_EVENTS_ will automatically be included.  * &#x60;SCHEDULE_EVENTS&#x60;     Response includes **events** when the driver has to take a break or a rest, perform service or wait for a waypoint to open (**schedule**), POST only.  * &#x60;EMISSIONS_EN16258_2012&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ and _DIESEL_, an arbitrary **bioFuelRatio** is supported.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     It is mutually exclusive with **EMISSIONS_EN16258_2012_HBEFA**.  * &#x60;EMISSIONS_EN16258_2012_HBEFA&#x60;     Response includes information on **emissions** (**EN16258_2012**) calculated according to EN 16258 from 2012 (a.k.a. CEN) based on the total fuel consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** will be ignored.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).     Supported vehicles are the same as those of _EMISSIONS_EN16258_2012_.     It is mutually exclusive with **EMISSIONS_EN16258_2012**.  * &#x60;EMISSIONS_ISO14083_2022&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023** for more information.  * &#x60;EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION&#x60;     Draft version of ISO 14083:2023. See **EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION** for more information.  * &#x60;EMISSIONS_ISO14083_2023&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) based on the total fuel and electricity consumption for this route.     Only supported for [European and American profiles](../data-api/concepts/profiles). Emissions are calculated using the respective factors.     All fuel and electricity types are supported, for _GASOLINE_ and _DIESEL_ an arbitrary **bioFuelRatio** is supported.     For **engineType** _HYBRID_ or **engineType** _COMBUSTION_ with **fuelType** _CNG_GASOLINE_ or _LPG_GASOLINE_, an arbitrary **hybridRatio** is supported.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION&#x60;     Response includes information on **emissions** (**ISO14083_2023**) calculated according to ISO 14083:2023 (a.k.a. ISO) for based on the default fuel and electricity consumption for this route     which is automatically calculated through HBEFA 4.2. The **averageFuelConsumption** and **averageElectricityConsumption** will be ignored.     Only supported for [European profiles](../data-api/concepts/profiles). Emissions are calculated using the European factors.     Supported vehicles are the same as those of _EMISSIONS_ISO14083_2023_.     It is mutually exclusive with all other ISO14083 calculations.  * &#x60;EMISSIONS_FRENCH_CO2E_DECREE_2017_639&#x60;     Response includes information on **emissions** (**French_CO2e_Decree_2017_639**) calculated according to the French CO2E decree from 2017 based on the total fuel consumption for this route.     Only vehicles with **engineType** _COMBUSTION_ and **fuelType** _GASOLINE_, _DIESEL_, _COMPRESSED_NATURAL_GAS_ or _LIQUEFIED_PETROLEUM_GAS_ are supported.     For _GASOLINE_ a **bioFuelRatio** of _0_, _10_ and _85_ is supported, for _DIESEL_ _0_ and _30_.     This is a European emission standard which should only be used with [European profiles](../data-api/concepts/profiles).  * &#x60;ALTERNATIVE_ROUTES&#x60;     Response includes up to three alternatives in addition to the optimal route. Only supported when exactly two on-road or off-road waypoints are specified. Please note that the additional calculations will degrade the performance.       Cannot be used with **options[routingMode]&#x3D;MONETARY**.  * &#x60;SCHEDULE_REPORT&#x60;     Response includes the **scheduleReport** which provides an overview of the times of the schedule of this route including break and rest times, POST only.  * &#x60;GUIDED_NAVIGATION&#x60;     Response includes the guided navigation information for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator).       See [here](./concepts/guided-navigation) for more information.  * &#x60;MONETARY_COSTS&#x60;     Response includes a report with monetary costs for the route. See [here](./concepts/monetary-costs) for more information. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<RouteResponse>> CalculateRoutePostWithHttpInfoAsync(RouteRequest routeRequest, string profile = default(string), Vehicle vehicle = default(Vehicle), Driver driver = default(Driver), Options options = default(Options), MonetaryCostOptions monetaryCostOptions = default(MonetaryCostOptions), List<Results> results = default(List<Results>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'routeRequest' is set
            if (routeRequest == null)
            {
                throw new RoutingClient.Client.ApiException(400, "Missing required parameter 'routeRequest' when calling RoutingApi->CalculateRoutePost");
            }
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
                "application/json"
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            if (profile != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "profile", profile));
            }
            if (vehicle != null)
            {
                if (vehicle.EngineType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[engineType]", vehicle.EngineType));
                }
                if (vehicle.FuelType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[fuelType]", vehicle.FuelType));
                }
                if (vehicle.ElectricityType != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[electricityType]", vehicle.ElectricityType));
                }
                if (vehicle.AverageFuelConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageFuelConsumption]", vehicle.AverageFuelConsumption));
                }
                if (vehicle.AverageElectricityConsumption != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[averageElectricityConsumption]", vehicle.AverageElectricityConsumption));
                }
                if (vehicle.BioFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[bioFuelRatio]", vehicle.BioFuelRatio));
                }
                if (vehicle.HybridRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hybridRatio]", vehicle.HybridRatio));
                }
                if (vehicle.DualFuelRatio != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[dualFuelRatio]", vehicle.DualFuelRatio));
                }
                if (vehicle.CylinderCapacity != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[cylinderCapacity]", vehicle.CylinderCapacity));
                }
                if (vehicle.EmissionStandard != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emissionStandard]", vehicle.EmissionStandard));
                }
                if (vehicle.Co2EmissionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[co2EmissionClass]", vehicle.Co2EmissionClass));
                }
                if (vehicle.LowEmissionZoneTypes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[lowEmissionZoneTypes]", vehicle.LowEmissionZoneTypes));
                }
                if (vehicle.ParticleReductionClass != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[particleReductionClass]", vehicle.ParticleReductionClass));
                }
                if (vehicle.EmptyWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[emptyWeight]", vehicle.EmptyWeight));
                }
                if (vehicle.LoadWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[loadWeight]", vehicle.LoadWeight));
                }
                if (vehicle.TotalPermittedWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[totalPermittedWeight]", vehicle.TotalPermittedWeight));
                }
                if (vehicle.AxleWeight != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[axleWeight]", vehicle.AxleWeight));
                }
                if (vehicle.NumberOfAxles != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfAxles]", vehicle.NumberOfAxles));
                }
                if (vehicle.NumberOfTires != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[numberOfTires]", vehicle.NumberOfTires));
                }
                if (vehicle.Height != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[height]", vehicle.Height));
                }
                if (vehicle.HeightAboveFrontAxle != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[heightAboveFrontAxle]", vehicle.HeightAboveFrontAxle));
                }
                if (vehicle.Length != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[length]", vehicle.Length));
                }
                if (vehicle.Width != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[width]", vehicle.Width));
                }
                if (vehicle.HazardousMaterials != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[hazardousMaterials]", vehicle.HazardousMaterials));
                }
                if (vehicle.TunnelRestrictionCode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[tunnelRestrictionCode]", vehicle.TunnelRestrictionCode));
                }
                if (vehicle.TruckRoutes != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[truckRoutes]", vehicle.TruckRoutes));
                }
                if (vehicle.Commercial != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[commercial]", vehicle.Commercial));
                }
                if (vehicle.EtcSubscriptions != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "vehicle[etcSubscriptions]", vehicle.EtcSubscriptions));
                }
            }
            if (driver != null)
            {
                if (driver.WorkingHoursPreset != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "driver[workingHoursPreset]", driver.WorkingHoursPreset));
                }
            }
            if (options != null)
            {
                if (options.StartTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[startTime]", options.StartTime));
                }
                if (options.ArrivalTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[arrivalTime]", options.ArrivalTime));
                }
                if (options.TrafficMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[trafficMode]", options.TrafficMode));
                }
                if (options.Language != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[language]", options.Language));
                }
                if (options.PolylineFormat != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[polylineFormat]", options.PolylineFormat));
                }
                if (options.AllowedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[allowedCountries]", options.AllowedCountries));
                }
                if (options.ProhibitedCountries != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[prohibitedCountries]", options.ProhibitedCountries));
                }
                if (options.Currency != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[currency]", options.Currency));
                }
                if (options.PreferTurnsOnPassengerSide != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[preferTurnsOnPassengerSide]", options.PreferTurnsOnPassengerSide));
                }
                if (options.Avoid != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[avoid]", options.Avoid));
                }
                if (options.BlockIntersectingRoads != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[blockIntersectingRoads]", options.BlockIntersectingRoads));
                }
                if (options.CustomRoadAttributeScenarios != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[customRoadAttributeScenarios]", options.CustomRoadAttributeScenarios));
                }
                if (options.RoutingMode != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "options[routingMode]", options.RoutingMode));
                }
            }
            if (monetaryCostOptions != null)
            {
                if (monetaryCostOptions.CostPerKilometer != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKilometer]", monetaryCostOptions.CostPerKilometer));
                }
                if (monetaryCostOptions.WorkingCostPerHour != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[workingCostPerHour]", monetaryCostOptions.WorkingCostPerHour));
                }
                if (monetaryCostOptions.CostPerKwh != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerKwh]", monetaryCostOptions.CostPerKwh));
                }
                if (monetaryCostOptions.CostPerFuelUnit != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "monetaryCostOptions[costPerFuelUnit]", monetaryCostOptions.CostPerFuelUnit));
                }
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            localVarRequestOptions.Data = routeRequest;
            localVarRequestOptions.Operation = "RoutingApi.CalculateRoutePost";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<RouteResponse>("/routes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CalculateRoutePost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>EtaResponse</returns>
        public EtaResponse GetEstimatedTimeOfArrival(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<EtaResponse> localVarResponse = GetEstimatedTimeOfArrivalWithHttpInfo(routeId, waypoint, position, workLogbook);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of EtaResponse</returns>
        public RoutingClient.Client.ApiResponse<EtaResponse> GetEstimatedTimeOfArrivalWithHttpInfo(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("routeId", RoutingClient.Client.ClientUtils.ParameterToString(routeId)); // path parameter
            if (waypoint != null)
            {
                if (waypoint.Name != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint[name]", waypoint.Name));
                }
                if (waypoint.PerformedServiceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint[performedServiceTime]", waypoint.PerformedServiceTime));
                }
            }
            if (position != null)
            {
                if (position.Latitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[latitude]", position.Latitude));
                }
                if (position.Longitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[longitude]", position.Longitude));
                }
                if (position.NextWaypointName != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[nextWaypointName]", position.NextWaypointName));
                }
                if (position.Heading != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[heading]", position.Heading));
                }
                if (position.HeadingTolerance != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[headingTolerance]", position.HeadingTolerance));
                }
            }
            if (workLogbook != null)
            {
                if (workLogbook.LastTimeTheDriverWorked != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[lastTimeTheDriverWorked]", workLogbook.LastTimeTheDriverWorked));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastBreak]", workLogbook.AccumulatedDrivingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedWorkingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedWorkingTimeSinceLastBreak]", workLogbook.AccumulatedWorkingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastDailyRest]", workLogbook.AccumulatedDrivingTimeSinceLastDailyRest));
                }
                if (workLogbook.AccumulatedTravelTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedTravelTimeSinceLastDailyRest]", workLogbook.AccumulatedTravelTimeSinceLastDailyRest));
                }
            }
            localVarRequestOptions.Operation = "RoutingApi.GetEstimatedTimeOfArrival";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<EtaResponse>("/eta/{routeId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEstimatedTimeOfArrival", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EtaResponse</returns>
        public async System.Threading.Tasks.Task<EtaResponse> GetEstimatedTimeOfArrivalAsync(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<EtaResponse> localVarResponse = await GetEstimatedTimeOfArrivalWithHttpInfoAsync(routeId, waypoint, position, workLogbook, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Calculates the estimated time of arrival (ETA) based on a previously calculated route and the current position of the vehicle.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route id returned from a previous route calculation.   Make sure to assign unique names to all off-road and on-road waypoints in the request to obtain the route id. Otherwise, the route id cannot be used for ETA calculation because the waypoints cannot be identified. Furthermore, the route id must not contain route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints. </param>
        /// <param name="waypoint"> (optional)</param>
        /// <param name="position"> (optional)</param>
        /// <param name="workLogbook"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EtaResponse)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<EtaResponse>> GetEstimatedTimeOfArrivalWithHttpInfoAsync(Guid routeId, PositionAtWaypoint waypoint = default(PositionAtWaypoint), PositionOnRoute position = default(PositionOnRoute), WorkLogbook workLogbook = default(WorkLogbook), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("routeId", RoutingClient.Client.ClientUtils.ParameterToString(routeId)); // path parameter
            if (waypoint != null)
            {
                if (waypoint.Name != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint[name]", waypoint.Name));
                }
                if (waypoint.PerformedServiceTime != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "waypoint[performedServiceTime]", waypoint.PerformedServiceTime));
                }
            }
            if (position != null)
            {
                if (position.Latitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[latitude]", position.Latitude));
                }
                if (position.Longitude != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[longitude]", position.Longitude));
                }
                if (position.NextWaypointName != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[nextWaypointName]", position.NextWaypointName));
                }
                if (position.Heading != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[heading]", position.Heading));
                }
                if (position.HeadingTolerance != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "position[headingTolerance]", position.HeadingTolerance));
                }
            }
            if (workLogbook != null)
            {
                if (workLogbook.LastTimeTheDriverWorked != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[lastTimeTheDriverWorked]", workLogbook.LastTimeTheDriverWorked));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastBreak]", workLogbook.AccumulatedDrivingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedWorkingTimeSinceLastBreak != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedWorkingTimeSinceLastBreak]", workLogbook.AccumulatedWorkingTimeSinceLastBreak));
                }
                if (workLogbook.AccumulatedDrivingTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedDrivingTimeSinceLastDailyRest]", workLogbook.AccumulatedDrivingTimeSinceLastDailyRest));
                }
                if (workLogbook.AccumulatedTravelTimeSinceLastDailyRest != null)
                {
                    localVarRequestOptions.QueryParameters.Add(RoutingClient.Client.ClientUtils.ParameterToMultiMap("", "workLogbook[accumulatedTravelTimeSinceLastDailyRest]", workLogbook.AccumulatedTravelTimeSinceLastDailyRest));
                }
            }
            localVarRequestOptions.Operation = "RoutingApi.GetEstimatedTimeOfArrival";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EtaResponse>("/eta/{routeId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEstimatedTimeOfArrival", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Returns a route for a previously calculated or alternative route ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RouteResponse</returns>
        public RouteResponse GetRouteByRouteId(Guid routeId, int operationIndex = 0)
        {
            RoutingClient.Client.ApiResponse<RouteResponse> localVarResponse = GetRouteByRouteIdWithHttpInfo(routeId);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Returns a route for a previously calculated or alternative route ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RouteResponse</returns>
        public RoutingClient.Client.ApiResponse<RouteResponse> GetRouteByRouteIdWithHttpInfo(Guid routeId, int operationIndex = 0)
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("routeId", RoutingClient.Client.ClientUtils.ParameterToString(routeId)); // path parameter
            localVarRequestOptions.Operation = "RoutingApi.GetRouteByRouteId";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = this.Client.Get<RouteResponse>("/routes/{routeId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRouteByRouteId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
        /// <summary>
        ///  Returns a route for a previously calculated or alternative route ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RouteResponse</returns>
        public async System.Threading.Tasks.Task<RouteResponse> GetRouteByRouteIdAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.ApiResponse<RouteResponse> localVarResponse = await GetRouteByRouteIdWithHttpInfoAsync(routeId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }
        /// <summary>
        ///  Returns a route for a previously calculated or alternative route ID.
        /// </summary>
        /// <exception cref="RoutingClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="routeId">The route ID returned from a previous route calculation or alternative route.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RouteResponse)</returns>
        public async System.Threading.Tasks.Task<RoutingClient.Client.ApiResponse<RouteResponse>> GetRouteByRouteIdWithHttpInfoAsync(Guid routeId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            RoutingClient.Client.RequestOptions localVarRequestOptions = new RoutingClient.Client.RequestOptions();
            string[] _contentTypes = new string[] {
            };
            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };
            var localVarContentType = RoutingClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }
            var localVarAccept = RoutingClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }
            localVarRequestOptions.PathParameters.Add("routeId", RoutingClient.Client.ClientUtils.ParameterToString(routeId)); // path parameter
            localVarRequestOptions.Operation = "RoutingApi.GetRouteByRouteId";
            localVarRequestOptions.OperationIndex = operationIndex;
            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }
            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RouteResponse>("/routes/{routeId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRouteByRouteId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Allows RestSharp to Serialize/Deserialize JSON using our custom logic, but only when ContentType is JSON.
    /// </summary>
    internal class CustomJsonCodec : IRestSerializer, ISerializer, IDeserializer
    {
        private readonly IReadableConfiguration _configuration;
        private readonly JsonSerializerSettings _serializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        public CustomJsonCodec(IReadableConfiguration configuration)
        {
            _configuration = configuration;
        }
        public CustomJsonCodec(JsonSerializerSettings serializerSettings, IReadableConfiguration configuration)
        {
            _serializerSettings = serializerSettings;
            _configuration = configuration;
        }
        /// <summary>
        /// Serialize the object into a JSON string.
        /// </summary>
        /// <param name="obj">Object to be serialized.</param>
        /// <returns>A JSON string.</returns>
        public string Serialize(object obj)
        {
            if (obj != null && obj is RoutingClient.Model.AbstractOpenAPISchema)
            {
                // the object to be serialized is an oneOf/anyOf schema
                return ((RoutingClient.Model.AbstractOpenAPISchema)obj).ToJson();
            }
            else
            {
                return JsonConvert.SerializeObject(obj, _serializerSettings);
            }
        }
        public string Serialize(Parameter bodyParameter) => Serialize(bodyParameter.Value);
        public T Deserialize<T>(RestResponse response)
        {
            var result = (T)Deserialize(response, typeof(T));
            return result;
        }
        /// <summary>
        /// Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="response">The HTTP response.</param>
        /// <param name="type">Object type.</param>
        /// <returns>Object representation of the JSON string.</returns>
        internal object Deserialize(RestResponse response, Type type)
        {
            if (type == typeof(byte[])) // return byte array
            {
                return response.RawBytes;
            }
            // TODO: ? if (type.IsAssignableFrom(typeof(Stream)))
            if (type == typeof(Stream))
            {
                var bytes = response.RawBytes;
                if (response.Headers != null)
                {
                    var filePath = string.IsNullOrEmpty(_configuration.TempFolderPath)
                        ? Path.GetTempPath()
                        : _configuration.TempFolderPath;
                    var regex = new Regex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$");
                    foreach (var header in response.Headers)
                    {
                        var match = regex.Match(header.ToString());
                        if (match.Success)
                        {
                            string fileName = filePath + ClientUtils.SanitizeFilename(match.Groups[1].Value.Replace("\"", "").Replace("'", ""));
                            File.WriteAllBytes(fileName, bytes);
                            return new FileStream(fileName, FileMode.Open);
                        }
                    }
                }
                var stream = new MemoryStream(bytes);
                return stream;
            }
            if (type.Name.StartsWith("System.Nullable`1[[System.DateTime")) // return a datetime object
            {
                return DateTime.Parse(response.Content, null, System.Globalization.DateTimeStyles.RoundtripKind);
            }
            if (type == typeof(string) || type.Name.StartsWith("System.Nullable")) // return primitive type
            {
                return Convert.ChangeType(response.Content, type);
            }
            // at this point, it must be a model (json)
            try
            {
                return JsonConvert.DeserializeObject(response.Content, type, _serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }
        public ISerializer Serializer => this;
        public IDeserializer Deserializer => this;
        public string[] AcceptedContentTypes => RestSharp.ContentType.JsonAccept;
        public SupportsContentType SupportsContentType => contentType =>
            contentType.Value.EndsWith("json", StringComparison.InvariantCultureIgnoreCase) ||
            contentType.Value.EndsWith("javascript", StringComparison.InvariantCultureIgnoreCase);
        public ContentType ContentType { get; set; } = RestSharp.ContentType.Json;
        public DataFormat DataFormat => DataFormat.Json;
    }
    /// <summary>
    /// Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
    /// encapsulating general REST accessor use cases.
    /// </summary>
    public partial class ApiClient : ISynchronousClient, IAsynchronousClient
    {
        private readonly string _baseUrl;
        /// <summary>
        /// Specifies the settings on a <see cref="JsonSerializer" /> object.
        /// These settings can be adjusted to accommodate custom serialization rules.
        /// </summary>
        public JsonSerializerSettings SerializerSettings { get; set; } = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        /// <summary>
        /// Allows for extending request processing for <see cref="ApiClient"/> generated code.
        /// </summary>
        /// <param name="request">The RestSharp request object</param>
        partial void InterceptRequest(RestRequest request);
        /// <summary>
        /// Allows for extending response processing for <see cref="ApiClient"/> generated code.
        /// </summary>
        /// <param name="request">The RestSharp request object</param>
        /// <param name="response">The RestSharp response object</param>
        partial void InterceptResponse(RestRequest request, RestResponse response);
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" />, defaulting to the global configurations' base url.
        /// </summary>
        public ApiClient()
        {
            _baseUrl = RoutingClient.Client.GlobalConfiguration.Instance.BasePath;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" />
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        public ApiClient(string basePath)
        {
            if (string.IsNullOrEmpty(basePath))
                throw new ArgumentException("basePath cannot be empty");
            _baseUrl = basePath;
        }
        /// <summary>
        /// Constructs the RestSharp version of an http method
        /// </summary>
        /// <param name="method">Swagger Client Custom HttpMethod</param>
        /// <returns>RestSharp's HttpMethod instance.</returns>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        private RestSharpMethod Method(HttpMethod method)
        {
            RestSharpMethod other;
            switch (method)
            {
                case HttpMethod.Get:
                    other = RestSharpMethod.Get;
                    break;
                case HttpMethod.Post:
                    other = RestSharpMethod.Post;
                    break;
                case HttpMethod.Put:
                    other = RestSharpMethod.Put;
                    break;
                case HttpMethod.Delete:
                    other = RestSharpMethod.Delete;
                    break;
                case HttpMethod.Head:
                    other = RestSharpMethod.Head;
                    break;
                case HttpMethod.Options:
                    other = RestSharpMethod.Options;
                    break;
                case HttpMethod.Patch:
                    other = RestSharpMethod.Patch;
                    break;
                default:
                    throw new ArgumentOutOfRangeException("method", method, null);
            }
            return other;
        }
        /// <summary>
        /// Provides all logic for constructing a new RestSharp <see cref="RestRequest"/>.
        /// At this point, all information for querying the service is known. Here, it is simply
        /// mapped into the RestSharp request.
        /// </summary>
        /// <param name="method">The http verb.</param>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>[private] A new RestRequest instance.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        private RestRequest NewRequest(
            HttpMethod method,
            string path,
            RequestOptions options,
            IReadableConfiguration configuration)
        {
            if (path == null) throw new ArgumentNullException("path");
            if (options == null) throw new ArgumentNullException("options");
            if (configuration == null) throw new ArgumentNullException("configuration");
            RestRequest request = new RestRequest(path, Method(method));
            if (options.PathParameters != null)
            {
                foreach (var pathParam in options.PathParameters)
                {
                    request.AddParameter(pathParam.Key, pathParam.Value, ParameterType.UrlSegment);
                }
            }
            if (options.QueryParameters != null)
            {
                foreach (var queryParam in options.QueryParameters)
                {
                    foreach (var value in queryParam.Value)
                    {
                        request.AddQueryParameter(queryParam.Key, value);
                    }
                }
            }
            if (configuration.DefaultHeaders != null)
            {
                foreach (var headerParam in configuration.DefaultHeaders)
                {
                    request.AddHeader(headerParam.Key, headerParam.Value);
                }
            }
            if (options.HeaderParameters != null)
            {
                foreach (var headerParam in options.HeaderParameters)
                {
                    foreach (var value in headerParam.Value)
                    {
                        request.AddHeader(headerParam.Key, value);
                    }
                }
            }
            if (options.FormParameters != null)
            {
                foreach (var formParam in options.FormParameters)
                {
                    request.AddParameter(formParam.Key, formParam.Value);
                }
            }
            if (options.Data != null)
            {
                if (options.Data is Stream stream)
                {
                    var contentType = "application/octet-stream";
                    if (options.HeaderParameters != null)
                    {
                        var contentTypes = options.HeaderParameters["Content-Type"];
                        contentType = contentTypes[0];
                    }
                    var bytes = ClientUtils.ReadAsBytes(stream);
                    request.AddParameter(contentType, bytes, ParameterType.RequestBody);
                }
                else
                {
                    if (options.HeaderParameters != null)
                    {
                        var contentTypes = options.HeaderParameters["Content-Type"];
                        if (contentTypes == null || contentTypes.Any(header => header.Contains("application/json")))
                        {
                            request.RequestFormat = DataFormat.Json;
                        }
                        else
                        {
                            // TODO: Generated client user should add additional handlers. RestSharp only supports XML and JSON, with XML as default.
                        }
                    }
                    else
                    {
                        // Here, we'll assume JSON APIs are more common. XML can be forced by adding produces/consumes to openapi spec explicitly.
                        request.RequestFormat = DataFormat.Json;
                    }
                    request.AddJsonBody(options.Data);
                }
            }
            if (options.FileParameters != null)
            {
                foreach (var fileParam in options.FileParameters)
                {
                    foreach (var file in fileParam.Value)
                    {
                        var bytes = ClientUtils.ReadAsBytes(file);
                        var fileStream = file as FileStream;
                        if (fileStream != null)
                            request.AddFile(fileParam.Key, bytes, System.IO.Path.GetFileName(fileStream.Name));
                        else
                            request.AddFile(fileParam.Key, bytes, "no_file_name_provided");
                    }
                }
            }
            return request;
        }
        private ApiResponse<T> ToApiResponse<T>(RestResponse<T> response)
        {
            T result = response.Data;
            string rawContent = response.Content;
            var transformed = new ApiResponse<T>(response.StatusCode, new Multimap<string, string>(), result, rawContent)
            {
                ErrorText = response.ErrorMessage,
                Cookies = new List<Cookie>()
            };
            if (response.Headers != null)
            {
                foreach (var responseHeader in response.Headers)
                {
                    transformed.Headers.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
                }
            }
            if (response.ContentHeaders != null)
            {
                foreach (var responseHeader in response.ContentHeaders)
                {
                    transformed.Headers.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
                }
            }
            if (response.Cookies != null)
            {
                foreach (var responseCookies in response.Cookies.Cast<Cookie>())
                {
                    transformed.Cookies.Add(
                        new Cookie(
                            responseCookies.Name,
                            responseCookies.Value,
                            responseCookies.Path,
                            responseCookies.Domain)
                        );
                }
            }
            return transformed;
        }
        private ApiResponse<T> Exec<T>(RestRequest request, RequestOptions options, IReadableConfiguration configuration)
        {
            var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;
            var cookies = new CookieContainer();
            if (options.Cookies != null && options.Cookies.Count > 0)
            {
                foreach (var cookie in options.Cookies)
                {
                    cookies.Add(new Cookie(cookie.Name, cookie.Value));
                }
            }
            var clientOptions = new RestClientOptions(baseUrl)
            {
                ClientCertificates = configuration.ClientCertificates,
                CookieContainer = cookies,
                MaxTimeout = configuration.Timeout,
                Proxy = configuration.Proxy,
                UserAgent = configuration.UserAgent,
                UseDefaultCredentials = configuration.UseDefaultCredentials,
                RemoteCertificateValidationCallback = configuration.RemoteCertificateValidationCallback
            };
            using (RestClient client = new RestClient(clientOptions,
                configureSerialization: serializerConfig => serializerConfig.UseSerializer(() => new CustomJsonCodec(SerializerSettings, configuration))))
            {
                InterceptRequest(request);
                RestResponse<T> response;
                if (RetryConfiguration.RetryPolicy != null)
                {
                    var policy = RetryConfiguration.RetryPolicy;
                    var policyResult = policy.ExecuteAndCapture(() => client.Execute(request));
                    response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>(request)
                    {
                        ErrorException = policyResult.FinalException
                    };
                }
                else
                {
                    response = client.Execute<T>(request);
                }
                // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
                if (typeof(RoutingClient.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
                {
                    try
                    {
                        response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
                    }
                    catch (Exception ex)
                    {
                        throw ex.InnerException != null ? ex.InnerException : ex;
                    }
                }
                else if (typeof(T).Name == "Stream") // for binary response
                {
                    response.Data = (T)(object)new MemoryStream(response.RawBytes);
                }
                else if (typeof(T).Name == "Byte[]") // for byte response
                {
                    response.Data = (T)(object)response.RawBytes;
                }
                else if (typeof(T).Name == "String") // for string response
                {
                    response.Data = (T)(object)response.Content;
                }
                InterceptResponse(request, response);
                var result = ToApiResponse(response);
                if (response.ErrorMessage != null)
                {
                    result.ErrorText = response.ErrorMessage;
                }
                if (response.Cookies != null && response.Cookies.Count > 0)
                {
                    if (result.Cookies == null) result.Cookies = new List<Cookie>();
                    foreach (var restResponseCookie in response.Cookies.Cast<Cookie>())
                    {
                        var cookie = new Cookie(
                            restResponseCookie.Name,
                            restResponseCookie.Value,
                            restResponseCookie.Path,
                            restResponseCookie.Domain
                        )
                        {
                            Comment = restResponseCookie.Comment,
                            CommentUri = restResponseCookie.CommentUri,
                            Discard = restResponseCookie.Discard,
                            Expired = restResponseCookie.Expired,
                            Expires = restResponseCookie.Expires,
                            HttpOnly = restResponseCookie.HttpOnly,
                            Port = restResponseCookie.Port,
                            Secure = restResponseCookie.Secure,
                            Version = restResponseCookie.Version
                        };
                        result.Cookies.Add(cookie);
                    }
                }
                return result;
            }
        }
        private async Task<ApiResponse<T>> ExecAsync<T>(RestRequest request, RequestOptions options, IReadableConfiguration configuration, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;
            var clientOptions = new RestClientOptions(baseUrl)
            {
                ClientCertificates = configuration.ClientCertificates,
                MaxTimeout = configuration.Timeout,
                Proxy = configuration.Proxy,
                UserAgent = configuration.UserAgent,
                UseDefaultCredentials = configuration.UseDefaultCredentials,
                RemoteCertificateValidationCallback = configuration.RemoteCertificateValidationCallback
            };
            using (RestClient client = new RestClient(clientOptions,
                configureSerialization: serializerConfig => serializerConfig.UseSerializer(() => new CustomJsonCodec(SerializerSettings, configuration))))
            {
                InterceptRequest(request);
                RestResponse<T> response;
                if (RetryConfiguration.AsyncRetryPolicy != null)
                {
                    var policy = RetryConfiguration.AsyncRetryPolicy;
                    var policyResult = await policy.ExecuteAndCaptureAsync((ct) => client.ExecuteAsync(request, ct), cancellationToken).ConfigureAwait(false);
                    response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>(request)
                    {
                        ErrorException = policyResult.FinalException
                    };
                }
                else
                {
                    response = await client.ExecuteAsync<T>(request, cancellationToken).ConfigureAwait(false);
                }
                // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
                if (typeof(RoutingClient.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
                {
                    response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
                }
                else if (typeof(T).Name == "Stream") // for binary response
                {
                    response.Data = (T)(object)new MemoryStream(response.RawBytes);
                }
                else if (typeof(T).Name == "Byte[]") // for byte response
                {
                    response.Data = (T)(object)response.RawBytes;
                }
                InterceptResponse(request, response);
                var result = ToApiResponse(response);
                if (response.ErrorMessage != null)
                {
                    result.ErrorText = response.ErrorMessage;
                }
                if (response.Cookies != null && response.Cookies.Count > 0)
                {
                    if (result.Cookies == null) result.Cookies = new List<Cookie>();
                    foreach (var restResponseCookie in response.Cookies.Cast<Cookie>())
                    {
                        var cookie = new Cookie(
                            restResponseCookie.Name,
                            restResponseCookie.Value,
                            restResponseCookie.Path,
                            restResponseCookie.Domain
                        )
                        {
                            Comment = restResponseCookie.Comment,
                            CommentUri = restResponseCookie.CommentUri,
                            Discard = restResponseCookie.Discard,
                            Expired = restResponseCookie.Expired,
                            Expires = restResponseCookie.Expires,
                            HttpOnly = restResponseCookie.HttpOnly,
                            Port = restResponseCookie.Port,
                            Secure = restResponseCookie.Secure,
                            Version = restResponseCookie.Version
                        };
                        result.Cookies.Add(cookie);
                    }
                }
                return result;
            }
        }
        #region IAsynchronousClient
        /// <summary>
        /// Make a HTTP GET request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP POST request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP PUT request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP DELETE request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP HEAD request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP OPTION request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, config), options, config, cancellationToken);
        }
        /// <summary>
        /// Make a HTTP PATCH request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config, cancellationToken);
        }
        #endregion IAsynchronousClient
        #region ISynchronousClient
        /// <summary>
        /// Make a HTTP GET request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Get, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP POST request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Post, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP PUT request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Put, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP DELETE request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP HEAD request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Head, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP OPTION request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Options, path, options, config), options, config);
        }
        /// <summary>
        /// Make a HTTP PATCH request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config);
        }
        #endregion ISynchronousClient
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// API Exception
    /// </summary>
    public class ApiException : Exception
    {
        /// <summary>
        /// Gets or sets the error code (HTTP status code)
        /// </summary>
        /// <value>The error code (HTTP status code).</value>
        public int ErrorCode { get; set; }
        /// <summary>
        /// Gets or sets the error content (body json object)
        /// </summary>
        /// <value>The error content (Http response body).</value>
        public object ErrorContent { get; private set; }
        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        public Multimap<string, string> Headers { get; private set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiException"/> class.
        /// </summary>
        public ApiException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiException"/> class.
        /// </summary>
        /// <param name="errorCode">HTTP status code.</param>
        /// <param name="message">Error message.</param>
        public ApiException(int errorCode, string message) : base(message)
        {
            this.ErrorCode = errorCode;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiException"/> class.
        /// </summary>
        /// <param name="errorCode">HTTP status code.</param>
        /// <param name="message">Error message.</param>
        /// <param name="errorContent">Error content.</param>
        /// <param name="headers">HTTP Headers.</param>
        public ApiException(int errorCode, string message, object errorContent = null, Multimap<string, string> headers = null) : base(message)
        {
            this.ErrorCode = errorCode;
            this.ErrorContent = errorContent;
            this.Headers = headers;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Provides a non-generic contract for the ApiResponse wrapper.
    /// </summary>
    public interface IApiResponse
    {
        /// <summary>
        /// The data type of <see cref="Content"/>
        /// </summary>
        Type ResponseType { get; }
        /// <summary>
        /// The content of this response
        /// </summary>
        Object Content { get; }
        /// <summary>
        /// Gets or sets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        HttpStatusCode StatusCode { get; }
        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        Multimap<string, string> Headers { get; }
        /// <summary>
        /// Gets or sets any error text defined by the calling client.
        /// </summary>
        string ErrorText { get; set; }
        /// <summary>
        /// Gets or sets any cookies passed along on the response.
        /// </summary>
        List<Cookie> Cookies { get; set; }
        /// <summary>
        /// The raw content of this response
        /// </summary>
        string RawContent { get; }
    }
    /// <summary>
    /// API Response
    /// </summary>
    public class ApiResponse<T> : IApiResponse
    {
        #region Properties
        /// <summary>
        /// Gets or sets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        public HttpStatusCode StatusCode { get; }
        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        public Multimap<string, string> Headers { get; }
        /// <summary>
        /// Gets or sets the data (parsed HTTP body)
        /// </summary>
        /// <value>The data.</value>
        public T Data { get; }
        /// <summary>
        /// Gets or sets any error text defined by the calling client.
        /// </summary>
        public string ErrorText { get; set; }
        /// <summary>
        /// Gets or sets any cookies passed along on the response.
        /// </summary>
        public List<Cookie> Cookies { get; set; }
        /// <summary>
        /// The content of this response
        /// </summary>
        public Type ResponseType
        {
            get { return typeof(T); }
        }
        /// <summary>
        /// The data type of <see cref="Content"/>
        /// </summary>
        public object Content
        {
            get { return Data; }
        }
        /// <summary>
        /// The raw content
        /// </summary>
        public string RawContent { get; }
        #endregion Properties
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="headers">HTTP headers.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        /// <param name="rawContent">Raw content.</param>
        public ApiResponse(HttpStatusCode statusCode, Multimap<string, string> headers, T data, string rawContent)
        {
            StatusCode = statusCode;
            Headers = headers;
            Data = data;
            RawContent = rawContent;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="headers">HTTP headers.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        public ApiResponse(HttpStatusCode statusCode, Multimap<string, string> headers, T data) : this(statusCode, headers, data, null)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        /// <param name="rawContent">Raw content.</param>
        public ApiResponse(HttpStatusCode statusCode, T data, string rawContent) : this(statusCode, null, data, rawContent)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        public ApiResponse(HttpStatusCode statusCode, T data) : this(statusCode, data, null)
        {
        }
        #endregion Constructors
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Utility functions providing some benefit to API client consumers.
    /// </summary>
    public static class ClientUtils
    {
        /// <summary>
        /// Sanitize filename by removing the path
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <returns>Filename</returns>
        public static string SanitizeFilename(string filename)
        {
            Match match = Regex.Match(filename, @".*[/\\](.*)$");
            return match.Success ? match.Groups[1].Value : filename;
        }
        /// <summary>
        /// Convert params to key/value pairs.
        /// Use collectionFormat to properly format lists and collections.
        /// </summary>
        /// <param name="collectionFormat">The swagger-supported collection format, one of: csv, tsv, ssv, pipes, multi</param>
        /// <param name="name">Key name.</param>
        /// <param name="value">Value object.</param>
        /// <returns>A multimap of keys with 1..n associated values.</returns>
        public static Multimap<string, string> ParameterToMultiMap(string collectionFormat, string name, object value)
        {
            var parameters = new Multimap<string, string>();
            if (value is ICollection collection && collectionFormat == "multi")
            {
                foreach (var item in collection)
                {
                    parameters.Add(name, ParameterToString(item));
                }
            }
            else if (value is IDictionary dictionary)
            {
                if(collectionFormat == "deepObject") {
                    foreach (DictionaryEntry entry in dictionary)
                    {
                        parameters.Add(name + "[" + entry.Key + "]", ParameterToString(entry.Value));
                    }
                }
                else {
                    foreach (DictionaryEntry entry in dictionary)
                    {
                        parameters.Add(entry.Key.ToString(), ParameterToString(entry.Value));
                    }
                }
            }
            else
            {
                parameters.Add(name, ParameterToString(value));
            }
            return parameters;
        }
        /// <summary>
        /// If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with Configuration.DateTime.
        /// If parameter is a list, join the list with ",".
        /// Otherwise just return the string.
        /// </summary>
        /// <param name="obj">The parameter (header, path, query, form).</param>
        /// <param name="configuration">An optional configuration instance, providing formatting options used in processing.</param>
        /// <returns>Formatted string.</returns>
        public static string ParameterToString(object obj, IReadableConfiguration configuration = null)
        {
            if (obj is DateTime dateTime)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return dateTime.ToString((configuration ?? GlobalConfiguration.Instance).DateTimeFormat);
            if (obj is DateTimeOffset dateTimeOffset)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return dateTimeOffset.ToString((configuration ?? GlobalConfiguration.Instance).DateTimeFormat);
            if (obj is bool boolean)
                return boolean ? "true" : "false";
            if (obj is ICollection collection) {
                List<string> entries = new List<string>();
                foreach (var entry in collection)
                    entries.Add(ParameterToString(entry, configuration));
                return string.Join(",", entries);
            }
            if (obj is Enum && HasEnumMemberAttrValue(obj))
                return GetEnumMemberAttrValue(obj);
            return Convert.ToString(obj, CultureInfo.InvariantCulture);
        }
        /// <summary>
        /// Serializes the given object when not null. Otherwise return null.
        /// </summary>
        /// <param name="obj">The object to serialize.</param>
        /// <returns>Serialized string.</returns>
        public static string Serialize(object obj)
        {
            return obj != null ? Newtonsoft.Json.JsonConvert.SerializeObject(obj) : null;
        }
        /// <summary>
        /// Encode string in base64 format.
        /// </summary>
        /// <param name="text">string to be encoded.</param>
        /// <returns>Encoded string.</returns>
        public static string Base64Encode(string text)
        {
            return Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(text));
        }
        /// <summary>
        /// Convert stream to byte array
        /// </summary>
        /// <param name="inputStream">Input stream to be converted</param>
        /// <returns>Byte array</returns>
        public static byte[] ReadAsBytes(Stream inputStream)
        {
            using (var ms = new MemoryStream())
            {
                inputStream.CopyTo(ms);
                return ms.ToArray();
            }
        }
        /// <summary>
        /// Select the Content-Type header's value from the given content-type array:
        /// if JSON type exists in the given array, use it;
        /// otherwise use the first one defined in 'consumes'
        /// </summary>
        /// <param name="contentTypes">The Content-Type array to select from.</param>
        /// <returns>The Content-Type header to use.</returns>
        public static string SelectHeaderContentType(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
                return null;
            foreach (var contentType in contentTypes)
            {
                if (IsJsonMime(contentType))
                    return contentType;
            }
            return contentTypes[0]; // use the first content type specified in 'consumes'
        }
        /// <summary>
        /// Select the Accept header's value from the given accepts array:
        /// if JSON exists in the given array, use it;
        /// otherwise use all of them (joining into a string)
        /// </summary>
        /// <param name="accepts">The accepts array to select from.</param>
        /// <returns>The Accept header to use.</returns>
        public static string SelectHeaderAccept(string[] accepts)
        {
            if (accepts.Length == 0)
                return null;
            if (accepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
                return "application/json";
            return string.Join(",", accepts);
        }
        /// <summary>
        /// Provides a case-insensitive check that a provided content type is a known JSON-like content type.
        /// </summary>
        public static readonly Regex JsonRegex = new Regex("(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$");
        /// <summary>
        /// Check if the given MIME is a JSON MIME.
        /// JSON MIME examples:
        ///    application/json
        ///    application/json; charset=UTF8
        ///    APPLICATION/JSON
        ///    application/vnd.company+json
        /// </summary>
        /// <param name="mime">MIME</param>
        /// <returns>Returns True if MIME type is json.</returns>
        public static bool IsJsonMime(string mime)
        {
            if (string.IsNullOrWhiteSpace(mime)) return false;
            return JsonRegex.IsMatch(mime) || mime.Equals("application/json-patch+json");
        }
        /// <summary>
        /// Is the Enum decorated with EnumMember Attribute
        /// </summary>
        /// <param name="enumVal"></param>
        /// <returns>true if found</returns>
        private static bool HasEnumMemberAttrValue(object enumVal)
        {
            if (enumVal == null)
                throw new ArgumentNullException(nameof(enumVal));
            var enumType = enumVal.GetType();
            var memInfo = enumType.GetMember(enumVal.ToString() ?? throw new InvalidOperationException());
            var attr = memInfo.FirstOrDefault()?.GetCustomAttributes(false).OfType<EnumMemberAttribute>().FirstOrDefault();
            if (attr != null) return true;
                return false;
        }
        /// <summary>
        /// Get the EnumMember value
        /// </summary>
        /// <param name="enumVal"></param>
        /// <returns>EnumMember value as string otherwise null</returns>
        private static string GetEnumMemberAttrValue(object enumVal)
        {
            if (enumVal == null)
                throw new ArgumentNullException(nameof(enumVal));
            var enumType = enumVal.GetType();
            var memInfo = enumType.GetMember(enumVal.ToString() ?? throw new InvalidOperationException());
            var attr = memInfo.FirstOrDefault()?.GetCustomAttributes(false).OfType<EnumMemberAttribute>().FirstOrDefault();
            if (attr != null)
            {
                return attr.Value;
            }
            return null;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Represents a set of configuration settings
    /// </summary>
    public class Configuration : IReadableConfiguration
    {
        #region Constants
        /// <summary>
        /// Version of the package.
        /// </summary>
        /// <value>Version of the package.</value>
        public const string Version = "1.0.0";
        /// <summary>
        /// Identifier for ISO 8601 DateTime Format
        /// </summary>
        /// <remarks>See https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8 for more information.</remarks>
        // ReSharper disable once InconsistentNaming
        public const string ISO8601_DATETIME_FORMAT = "o";
        #endregion Constants
        #region Static Members
        /// <summary>
        /// Default creation of exceptions for a given method name and response object
        /// </summary>
        public static readonly ExceptionFactory DefaultExceptionFactory = (methodName, response) =>
        {
            var status = (int)response.StatusCode;
            if (status >= 400)
            {
                return new ApiException(status,
                    string.Format("Error calling {0}: {1}", methodName, response.RawContent),
                    response.RawContent, response.Headers);
            }
            if (status == 0)
            {
                return new ApiException(status,
                    string.Format("Error calling {0}: {1}", methodName, response.ErrorText), response.ErrorText);
            }
            return null;
        };
        #endregion Static Members
        #region Private Members
        /// <summary>
        /// Defines the base path of the target API server.
        /// Example: http://localhost:3000/v1/
        /// </summary>
        private string _basePath;
        private bool _useDefaultCredentials = false;
        /// <summary>
        /// Gets or sets the API key based on the authentication name.
        /// This is the key and value comprising the "secret" for accessing an API.
        /// </summary>
        /// <value>The API key.</value>
        private IDictionary<string, string> _apiKey;
        /// <summary>
        /// Gets or sets the prefix (e.g. Token) of the API key based on the authentication name.
        /// </summary>
        /// <value>The prefix of the API key.</value>
        private IDictionary<string, string> _apiKeyPrefix;
        private string _dateTimeFormat = ISO8601_DATETIME_FORMAT;
        private string _tempFolderPath = Path.GetTempPath();
        /// <summary>
        /// Gets or sets the servers defined in the OpenAPI spec.
        /// </summary>
        /// <value>The servers</value>
        private IList<IReadOnlyDictionary<string, object>> _servers;
        /// <summary>
        /// Gets or sets the operation servers defined in the OpenAPI spec.
        /// </summary>
        /// <value>The operation servers</value>
        private IReadOnlyDictionary<string, List<IReadOnlyDictionary<string, object>>> _operationServers;
        #endregion Private Members
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="Configuration" /> class
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("ReSharper", "VirtualMemberCallInConstructor")]
        public Configuration()
        {
            Proxy = null;
            UserAgent = WebUtility.UrlEncode("OpenAPI-Generator/1.0.0/csharp");
            BasePath = "https://api.myptv.com/routing/v1";
            DefaultHeaders = new ConcurrentDictionary<string, string>();
            ApiKey = new ConcurrentDictionary<string, string>();
            ApiKeyPrefix = new ConcurrentDictionary<string, string>();
            Servers = new List<IReadOnlyDictionary<string, object>>()
            {
                {
                    new Dictionary<string, object> {
                        {"url", "https://api.myptv.com/routing/v1"},
                        {"description", "No description provided"},
                    }
                }
            };
            OperationServers = new Dictionary<string, List<IReadOnlyDictionary<string, object>>>()
            {
            };
            // Setting Timeout has side effects (forces ApiClient creation).
            Timeout = 100000;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="Configuration" /> class
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("ReSharper", "VirtualMemberCallInConstructor")]
        public Configuration(
            IDictionary<string, string> defaultHeaders,
            IDictionary<string, string> apiKey,
            IDictionary<string, string> apiKeyPrefix,
            string basePath = "https://api.myptv.com/routing/v1") : this()
        {
            if (string.IsNullOrWhiteSpace(basePath))
                throw new ArgumentException("The provided basePath is invalid.", "basePath");
            if (defaultHeaders == null)
                throw new ArgumentNullException("defaultHeaders");
            if (apiKey == null)
                throw new ArgumentNullException("apiKey");
            if (apiKeyPrefix == null)
                throw new ArgumentNullException("apiKeyPrefix");
            BasePath = basePath;
            foreach (var keyValuePair in defaultHeaders)
            {
                DefaultHeaders.Add(keyValuePair);
            }
            foreach (var keyValuePair in apiKey)
            {
                ApiKey.Add(keyValuePair);
            }
            foreach (var keyValuePair in apiKeyPrefix)
            {
                ApiKeyPrefix.Add(keyValuePair);
            }
        }
        #endregion Constructors
        #region Properties
        /// <summary>
        /// Gets or sets the base path for API access.
        /// </summary>
        public virtual string BasePath 
        {
            get { return _basePath; }
            set { _basePath = value; }
        }
        /// <summary>
        /// Determine whether or not the "default credentials" (e.g. the user account under which the current process is running) will be sent along to the server. The default is false.
        /// </summary>
        public virtual bool UseDefaultCredentials
        {
            get { return _useDefaultCredentials; }
            set { _useDefaultCredentials = value; }
        }
        /// <summary>
        /// Gets or sets the default header.
        /// </summary>
        [Obsolete("Use DefaultHeaders instead.")]
        public virtual IDictionary<string, string> DefaultHeader
        {
            get
            {
                return DefaultHeaders;
            }
            set
            {
                DefaultHeaders = value;
            }
        }
        /// <summary>
        /// Gets or sets the default headers.
        /// </summary>
        public virtual IDictionary<string, string> DefaultHeaders { get; set; }
        /// <summary>
        /// Gets or sets the HTTP timeout (milliseconds) of ApiClient. Default to 100000 milliseconds.
        /// </summary>
        public virtual int Timeout { get; set; }
        /// <summary>
        /// Gets or sets the proxy
        /// </summary>
        /// <value>Proxy.</value>
        public virtual WebProxy Proxy { get; set; }
        /// <summary>
        /// Gets or sets the HTTP user agent.
        /// </summary>
        /// <value>Http user agent.</value>
        public virtual string UserAgent { get; set; }
        /// <summary>
        /// Gets or sets the username (HTTP basic authentication).
        /// </summary>
        /// <value>The username.</value>
        public virtual string Username { get; set; }
        /// <summary>
        /// Gets or sets the password (HTTP basic authentication).
        /// </summary>
        /// <value>The password.</value>
        public virtual string Password { get; set; }
        /// <summary>
        /// Gets the API key with prefix.
        /// </summary>
        /// <param name="apiKeyIdentifier">API key identifier (authentication scheme).</param>
        /// <returns>API key with prefix.</returns>
        public string GetApiKeyWithPrefix(string apiKeyIdentifier)
        {
            string apiKeyValue;
            ApiKey.TryGetValue(apiKeyIdentifier, out apiKeyValue);
            string apiKeyPrefix;
            if (ApiKeyPrefix.TryGetValue(apiKeyIdentifier, out apiKeyPrefix))
            {
                return apiKeyPrefix + " " + apiKeyValue;
            }
            return apiKeyValue;
        }
        /// <summary>
        /// Gets or sets certificate collection to be sent with requests.
        /// </summary>
        /// <value>X509 Certificate collection.</value>
        public X509CertificateCollection ClientCertificates { get; set; }
        /// <summary>
        /// Gets or sets the access token for OAuth2 authentication.
        ///
        /// This helper property simplifies code generation.
        /// </summary>
        /// <value>The access token.</value>
        public virtual string AccessToken { get; set; }
        /// <summary>
        /// Gets or sets the temporary folder path to store the files downloaded from the server.
        /// </summary>
        /// <value>Folder path.</value>
        public virtual string TempFolderPath
        {
            get { return _tempFolderPath; }
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    _tempFolderPath = Path.GetTempPath();
                    return;
                }
                // create the directory if it does not exist
                if (!Directory.Exists(value))
                {
                    Directory.CreateDirectory(value);
                }
                // check if the path contains directory separator at the end
                if (value[value.Length - 1] == Path.DirectorySeparatorChar)
                {
                    _tempFolderPath = value;
                }
                else
                {
                    _tempFolderPath = value + Path.DirectorySeparatorChar;
                }
            }
        }
        /// <summary>
        /// Gets or sets the date time format used when serializing in the ApiClient
        /// By default, it's set to ISO 8601 - "o", for others see:
        /// https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx
        /// and https://msdn.microsoft.com/en-us/library/8kb3ddd4(v=vs.110).aspx
        /// No validation is done to ensure that the string you're providing is valid
        /// </summary>
        /// <value>The DateTimeFormat string</value>
        public virtual string DateTimeFormat
        {
            get { return _dateTimeFormat; }
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    // Never allow a blank or null string, go back to the default
                    _dateTimeFormat = ISO8601_DATETIME_FORMAT;
                    return;
                }
                // Caution, no validation when you choose date time format other than ISO 8601
                // Take a look at the above links
                _dateTimeFormat = value;
            }
        }
        /// <summary>
        /// Gets or sets the prefix (e.g. Token) of the API key based on the authentication name.
        ///
        /// Whatever you set here will be prepended to the value defined in AddApiKey.
        ///
        /// An example invocation here might be:
        /// <example>
        /// ApiKeyPrefix["Authorization"] = "Bearer";
        /// </example>
        ///  where ApiKey["Authorization"] would then be used to set the value of your bearer token.
        ///
        /// <remarks>
        /// OAuth2 workflows should set tokens via AccessToken.
        /// </remarks>
        /// </summary>
        /// <value>The prefix of the API key.</value>
        public virtual IDictionary<string, string> ApiKeyPrefix
        {
            get { return _apiKeyPrefix; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("ApiKeyPrefix collection may not be null.");
                }
                _apiKeyPrefix = value;
            }
        }
        /// <summary>
        /// Gets or sets the API key based on the authentication name.
        /// </summary>
        /// <value>The API key.</value>
        public virtual IDictionary<string, string> ApiKey
        {
            get { return _apiKey; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("ApiKey collection may not be null.");
                }
                _apiKey = value;
            }
        }
        /// <summary>
        /// Gets or sets the servers.
        /// </summary>
        /// <value>The servers.</value>
        public virtual IList<IReadOnlyDictionary<string, object>> Servers
        {
            get { return _servers; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("Servers may not be null.");
                }
                _servers = value;
            }
        }
        /// <summary>
        /// Gets or sets the operation servers.
        /// </summary>
        /// <value>The operation servers.</value>
        public virtual IReadOnlyDictionary<string, List<IReadOnlyDictionary<string, object>>> OperationServers
        {
            get { return _operationServers; }
            set
            {
                if (value == null)
                {
                    throw new InvalidOperationException("Operation servers may not be null.");
                }
                _operationServers = value;
            }
        }
        /// <summary>
        /// Returns URL based on server settings without providing values
        /// for the variables
        /// </summary>
        /// <param name="index">Array index of the server settings.</param>
        /// <return>The server URL.</return>
        public string GetServerUrl(int index)
        {
            return GetServerUrl(Servers, index, null);
        }
        /// <summary>
        /// Returns URL based on server settings.
        /// </summary>
        /// <param name="index">Array index of the server settings.</param>
        /// <param name="inputVariables">Dictionary of the variables and the corresponding values.</param>
        /// <return>The server URL.</return>
        public string GetServerUrl(int index, Dictionary<string, string> inputVariables)
        {
            return GetServerUrl(Servers, index, inputVariables);
        }
        /// <summary>
        /// Returns URL based on operation server settings.
        /// </summary>
        /// <param name="operation">Operation associated with the request path.</param>
        /// <param name="index">Array index of the server settings.</param>
        /// <return>The operation server URL.</return>
        public string GetOperationServerUrl(string operation, int index)
        {
            return GetOperationServerUrl(operation, index, null);
        }
        /// <summary>
        /// Returns URL based on operation server settings.
        /// </summary>
        /// <param name="operation">Operation associated with the request path.</param>
        /// <param name="index">Array index of the server settings.</param>
        /// <param name="inputVariables">Dictionary of the variables and the corresponding values.</param>
        /// <return>The operation server URL.</return>
        public string GetOperationServerUrl(string operation, int index, Dictionary<string, string> inputVariables)
        {
            if (operation != null && OperationServers.TryGetValue(operation, out var operationServer))
            {
                return GetServerUrl(operationServer, index, inputVariables);
            }
            return null;
        }
        /// <summary>
        /// Returns URL based on server settings.
        /// </summary>
        /// <param name="servers">Dictionary of server settings.</param>
        /// <param name="index">Array index of the server settings.</param>
        /// <param name="inputVariables">Dictionary of the variables and the corresponding values.</param>
        /// <return>The server URL.</return>
        private string GetServerUrl(IList<IReadOnlyDictionary<string, object>> servers, int index, Dictionary<string, string> inputVariables)
        {
            if (index < 0 || index >= servers.Count)
            {
                throw new InvalidOperationException($"Invalid index {index} when selecting the server. Must be less than {servers.Count}.");
            }
            if (inputVariables == null)
            {
                inputVariables = new Dictionary<string, string>();
            }
            IReadOnlyDictionary<string, object> server = servers[index];
            string url = (string)server["url"];
            if (server.ContainsKey("variables"))
            {
                // go through each variable and assign a value
                foreach (KeyValuePair<string, object> variable in (IReadOnlyDictionary<string, object>)server["variables"])
                {
                    IReadOnlyDictionary<string, object> serverVariables = (IReadOnlyDictionary<string, object>)(variable.Value);
                    if (inputVariables.ContainsKey(variable.Key))
                    {
                        if (((List<string>)serverVariables["enum_values"]).Contains(inputVariables[variable.Key]))
                        {
                            url = url.Replace("{" + variable.Key + "}", inputVariables[variable.Key]);
                        }
                        else
                        {
                            throw new InvalidOperationException($"The variable `{variable.Key}` in the server URL has invalid value #{inputVariables[variable.Key]}. Must be {(List<string>)serverVariables["enum_values"]}");
                        }
                    }
                    else
                    {
                        // use default value
                        url = url.Replace("{" + variable.Key + "}", (string)serverVariables["default_value"]);
                    }
                }
            }
            return url;
        }
        /// <summary>
        /// Gets and Sets the RemoteCertificateValidationCallback
        /// </summary>
        public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; set; }
        #endregion Properties
        #region Methods
        /// <summary>
        /// Returns a string with essential information for debugging.
        /// </summary>
        public static string ToDebugReport()
        {
            string report = "C# SDK (RoutingClient) Debug Report:\n";
            report += "    OS: " + System.Environment.OSVersion + "\n";
            report += "    .NET Framework Version: " + System.Environment.Version  + "\n";
            report += "    Version of the API: 1.22\n";
            report += "    SDK Package Version: 1.0.0\n";
            return report;
        }
        /// <summary>
        /// Add Api Key Header.
        /// </summary>
        /// <param name="key">Api Key name.</param>
        /// <param name="value">Api Key value.</param>
        /// <returns></returns>
        public void AddApiKey(string key, string value)
        {
            ApiKey[key] = value;
        }
        /// <summary>
        /// Sets the API key prefix.
        /// </summary>
        /// <param name="key">Api Key name.</param>
        /// <param name="value">Api Key value.</param>
        public void AddApiKeyPrefix(string key, string value)
        {
            ApiKeyPrefix[key] = value;
        }
        #endregion Methods
        #region Static Members
        /// <summary>
        /// Merge configurations.
        /// </summary>
        /// <param name="first">First configuration.</param>
        /// <param name="second">Second configuration.</param>
        /// <return>Merged configuration.</return>
        public static IReadableConfiguration MergeConfigurations(IReadableConfiguration first, IReadableConfiguration second)
        {
            if (second == null) return first ?? GlobalConfiguration.Instance;
            Dictionary<string, string> apiKey = first.ApiKey.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            Dictionary<string, string> apiKeyPrefix = first.ApiKeyPrefix.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            Dictionary<string, string> defaultHeaders = first.DefaultHeaders.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            foreach (var kvp in second.ApiKey) apiKey[kvp.Key] = kvp.Value;
            foreach (var kvp in second.ApiKeyPrefix) apiKeyPrefix[kvp.Key] = kvp.Value;
            foreach (var kvp in second.DefaultHeaders) defaultHeaders[kvp.Key] = kvp.Value;
            var config = new Configuration
            {
                ApiKey = apiKey,
                ApiKeyPrefix = apiKeyPrefix,
                DefaultHeaders = defaultHeaders,
                BasePath = second.BasePath ?? first.BasePath,
                Timeout = second.Timeout,
                Proxy = second.Proxy ?? first.Proxy,
                UserAgent = second.UserAgent ?? first.UserAgent,
                Username = second.Username ?? first.Username,
                Password = second.Password ?? first.Password,
                AccessToken = second.AccessToken ?? first.AccessToken,
                TempFolderPath = second.TempFolderPath ?? first.TempFolderPath,
                DateTimeFormat = second.DateTimeFormat ?? first.DateTimeFormat,
                ClientCertificates = second.ClientCertificates ?? first.ClientCertificates,
                UseDefaultCredentials = second.UseDefaultCredentials,
                RemoteCertificateValidationCallback = second.RemoteCertificateValidationCallback ?? first.RemoteCertificateValidationCallback,
            };
            return config;
        }
        #endregion Static Members
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// A delegate to ExceptionFactory method
    /// </summary>
    /// <param name="methodName">Method name</param>
    /// <param name="response">Response</param>
    /// <returns>Exceptions</returns>
    public delegate Exception ExceptionFactory(string methodName, IApiResponse response);
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// <see cref="GlobalConfiguration"/> provides a compile-time extension point for globally configuring
    /// API Clients.
    /// </summary>
    /// <remarks>
    /// A customized implementation via partial class may reside in another file and may
    /// be excluded from automatic generation via a .openapi-generator-ignore file.
    /// </remarks>
    public partial class GlobalConfiguration : Configuration
    {
        #region Private Members
        private static readonly object GlobalConfigSync = new { };
        private static IReadableConfiguration _globalConfiguration;
        #endregion Private Members
        #region Constructors
        /// <inheritdoc />
        private GlobalConfiguration()
        {
        }
        /// <inheritdoc />
        public GlobalConfiguration(IDictionary<string, string> defaultHeader, IDictionary<string, string> apiKey, IDictionary<string, string> apiKeyPrefix, string basePath = "http://localhost:3000/api") : base(defaultHeader, apiKey, apiKeyPrefix, basePath)
        {
        }
        static GlobalConfiguration()
        {
            Instance = new GlobalConfiguration();
        }
        #endregion Constructors
        /// <summary>
        /// Gets or sets the default Configuration.
        /// </summary>
        /// <value>Configuration.</value>
        public static IReadableConfiguration Instance
        {
            get { return _globalConfiguration; }
            set
            {
                lock (GlobalConfigSync)
                {
                    _globalConfiguration = value;
                }
            }
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Http methods supported by swagger
    /// </summary>
    public enum HttpMethod
    {
        /// <summary>HTTP GET request.</summary>
        Get,
        /// <summary>HTTP POST request.</summary>
        Post,
        /// <summary>HTTP PUT request.</summary>
        Put,
        /// <summary>HTTP DELETE request.</summary>
        Delete,
        /// <summary>HTTP HEAD request.</summary>
        Head,
        /// <summary>HTTP OPTIONS request.</summary>
        Options,
        /// <summary>HTTP PATCH request.</summary>
        Patch
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Represents configuration aspects required to interact with the API endpoints.
    /// </summary>
    public interface IApiAccessor
    {
        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        IReadableConfiguration Configuration { get; set; }
        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        string GetBasePath();
        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        ExceptionFactory ExceptionFactory { get; set; }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Contract for Asynchronous RESTful API interactions.
    ///
    /// This interface allows consumers to provide a custom API accessor client.
    /// </summary>
    public interface IAsynchronousClient
    {
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the GET http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the POST http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the PUT http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the DELETE http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the HEAD http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the OPTIONS http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Executes a non-blocking call to some <paramref name="path"/> using the PATCH http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>A task eventually representing the response data, decorated with <see cref="ApiResponse{T}"/></returns>
        Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Represents a readable-only configuration contract.
    /// </summary>
    public interface IReadableConfiguration
    {
        /// <summary>
        /// Gets the access token.
        /// </summary>
        /// <value>Access token.</value>
        string AccessToken { get; }
        /// <summary>
        /// Gets the API key.
        /// </summary>
        /// <value>API key.</value>
        IDictionary<string, string> ApiKey { get; }
        /// <summary>
        /// Gets the API key prefix.
        /// </summary>
        /// <value>API key prefix.</value>
        IDictionary<string, string> ApiKeyPrefix { get; }
        /// <summary>
        /// Gets the base path.
        /// </summary>
        /// <value>Base path.</value>
        string BasePath { get; }
        /// <summary>
        /// Gets the date time format.
        /// </summary>
        /// <value>Date time format.</value>
        string DateTimeFormat { get; }
        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <value>Default header.</value>
        [Obsolete("Use DefaultHeaders instead.")]
        IDictionary<string, string> DefaultHeader { get; }
        /// <summary>
        /// Gets the default headers.
        /// </summary>
        /// <value>Default headers.</value>
        IDictionary<string, string> DefaultHeaders { get; }
        /// <summary>
        /// Gets the temp folder path.
        /// </summary>
        /// <value>Temp folder path.</value>
        string TempFolderPath { get; }
        /// <summary>
        /// Gets the HTTP connection timeout (in milliseconds)
        /// </summary>
        /// <value>HTTP connection timeout.</value>
        int Timeout { get; }
        /// <summary>
        /// Gets the proxy.
        /// </summary>
        /// <value>Proxy.</value>
        WebProxy Proxy { get; }
        /// <summary>
        /// Gets the user agent.
        /// </summary>
        /// <value>User agent.</value>
        string UserAgent { get; }
        /// <summary>
        /// Gets the username.
        /// </summary>
        /// <value>Username.</value>
        string Username { get; }
        /// <summary>
        /// Gets the password.
        /// </summary>
        /// <value>Password.</value>
        string Password { get; }
        /// <summary>
        /// Determine whether or not the "default credentials" (e.g. the user account under which the current process is running) will be sent along to the server. The default is false.
        /// </summary>
        bool UseDefaultCredentials { get; }
        /// <summary>
        /// Get the servers associated with the operation.
        /// </summary>
        /// <value>Operation servers.</value>
        IReadOnlyDictionary<string, List<IReadOnlyDictionary<string, object>>> OperationServers { get; }
        /// <summary>
        /// Gets the API key with prefix.
        /// </summary>
        /// <param name="apiKeyIdentifier">API key identifier (authentication scheme).</param>
        /// <returns>API key with prefix.</returns>
        string GetApiKeyWithPrefix(string apiKeyIdentifier);
        /// <summary>
        /// Gets the Operation server url at the provided index.
        /// </summary>
        /// <param name="operation">Operation server name.</param>
        /// <param name="index">Index of the operation server settings.</param>
        /// <returns></returns>
        string GetOperationServerUrl(string operation, int index);
        /// <summary>
        /// Gets certificate collection to be sent with requests.
        /// </summary>
        /// <value>X509 Certificate collection.</value>
        X509CertificateCollection ClientCertificates { get; }
        /// <summary>
        /// Callback function for handling the validation of remote certificates. Useful for certificate pinning and
        /// overriding certificate errors in the scope of a request.
        /// </summary>
        RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Contract for Synchronous RESTful API interactions.
    ///
    /// This interface allows consumers to provide a custom API accessor client.
    /// </summary>
    public interface ISynchronousClient
    {
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the GET http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the POST http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the PUT http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the DELETE http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the HEAD http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the OPTIONS http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
        /// <summary>
        /// Executes a blocking call to some <paramref name="path"/> using the PATCH http verb.
        /// </summary>
        /// <param name="path">The relative path to invoke.</param>
        /// <param name="options">The request parameters to pass along to the client.</param>
        /// <param name="configuration">Per-request configurable settings.</param>
        /// <typeparam name="T">The return type.</typeparam>
        /// <returns>The response data, decorated with <see cref="ApiResponse{T}"/></returns>
        ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration = null);
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// A dictionary in which one key has many associated values.
    /// </summary>
    /// <typeparam name="TKey">The type of the key</typeparam>
    /// <typeparam name="TValue">The type of the value associated with the key.</typeparam>
    public class Multimap<TKey, TValue> : IDictionary<TKey, IList<TValue>>
    {
        #region Private Fields
        private readonly Dictionary<TKey, IList<TValue>> _dictionary;
        #endregion Private Fields
        #region Constructors
        /// <summary>
        /// Empty Constructor.
        /// </summary>
        public Multimap()
        {
            _dictionary = new Dictionary<TKey, IList<TValue>>();
        }
        /// <summary>
        /// Constructor with comparer.
        /// </summary>
        /// <param name="comparer"></param>
        public Multimap(IEqualityComparer<TKey> comparer)
        {
            _dictionary = new Dictionary<TKey, IList<TValue>>(comparer);
        }
        #endregion Constructors
        #region Enumerators
        /// <summary>
        /// To get the enumerator.
        /// </summary>
        /// <returns>Enumerator</returns>
        public IEnumerator<KeyValuePair<TKey, IList<TValue>>> GetEnumerator()
        {
            return _dictionary.GetEnumerator();
        }
        /// <summary>
        /// To get the enumerator.
        /// </summary>
        /// <returns>Enumerator</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return _dictionary.GetEnumerator();
        }
        #endregion Enumerators
        #region Public Members
        /// <summary>
        /// Add values to Multimap
        /// </summary>
        /// <param name="item">Key value pair</param>
        public void Add(KeyValuePair<TKey, IList<TValue>> item)
        {
            if (!TryAdd(item.Key, item.Value))
                throw new InvalidOperationException("Could not add values to Multimap.");
        }
        /// <summary>
        /// Add Multimap to Multimap
        /// </summary>
        /// <param name="multimap">Multimap</param>
        public void Add(Multimap<TKey, TValue> multimap)
        {
            foreach (var item in multimap)
            {
                if (!TryAdd(item.Key, item.Value))
                    throw new InvalidOperationException("Could not add values to Multimap.");
            }
        }
        /// <summary>
        /// Clear Multimap
        /// </summary>
        public void Clear()
        {
            _dictionary.Clear();
        }
        /// <summary>
        /// Determines whether Multimap contains the specified item.
        /// </summary>
        /// <param name="item">Key value pair</param>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        /// <returns>true if the Multimap contains the item; otherwise, false.</returns>
        public bool Contains(KeyValuePair<TKey, IList<TValue>> item)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        ///  Copy items of the Multimap to an array,
        ///     starting at a particular array index.
        /// </summary>
        /// <param name="array">The array that is the destination of the items copied
        ///     from Multimap. The array must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        public void CopyTo(KeyValuePair<TKey, IList<TValue>>[] array, int arrayIndex)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Removes the specified item from the Multimap.
        /// </summary>
        /// <param name="item">Key value pair</param>
        /// <returns>true if the item is successfully removed; otherwise, false.</returns>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        public bool Remove(KeyValuePair<TKey, IList<TValue>> item)
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// Gets the number of items contained in the Multimap.
        /// </summary>
        public int Count => _dictionary.Count;
        /// <summary>
        /// Gets a value indicating whether the Multimap is read-only.
        /// </summary>
        public bool IsReadOnly => false;
        /// <summary>
        /// Adds an item with the provided key and value to the Multimap.
        /// </summary>
        /// <param name="key">The object to use as the key of the item to add.</param>
        /// <param name="value">The object to use as the value of the item to add.</param>
        /// <exception cref="InvalidOperationException">Thrown when couldn't add the value to Multimap.</exception>
        public void Add(TKey key, IList<TValue> value)
        {
            if (value != null && value.Count > 0)
            {
                if (_dictionary.TryGetValue(key, out var list))
                {
                    foreach (var k in value) list.Add(k);
                }
                else
                {
                    list = new List<TValue>(value);
                    if (!TryAdd(key, list))
                        throw new InvalidOperationException("Could not add values to Multimap.");
                }
            }
        }
        /// <summary>
        /// Determines whether the Multimap contains an item with the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the Multimap.</param>
        /// <returns>true if the Multimap contains an item with
        ///     the key; otherwise, false.</returns>
        public bool ContainsKey(TKey key)
        {
            return _dictionary.ContainsKey(key);
        }
        /// <summary>
        /// Removes item with the specified key from the Multimap.
        /// </summary>
        /// <param name="key">The key to locate in the Multimap.</param>
        /// <returns>true if the item is successfully removed; otherwise, false.</returns>
        public bool Remove(TKey key)
        {
            return TryRemove(key, out var _);
        }
        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the
        ///     key is found; otherwise, the default value for the type of the value parameter.
        ///     This parameter is passed uninitialized.</param>
        /// <returns> true if the object that implements Multimap contains
        ///     an item with the specified key; otherwise, false.</returns>
        public bool TryGetValue(TKey key, out IList<TValue> value)
        {
            return _dictionary.TryGetValue(key, out value);
        }
        /// <summary>
        /// Gets or sets the item with the specified key.
        /// </summary>
        /// <param name="key">The key of the item to get or set.</param>
        /// <returns>The value of the specified key.</returns>
        public IList<TValue> this[TKey key]
        {
            get => _dictionary[key];
            set => _dictionary[key] = value;
        }
        /// <summary>
        /// Gets a System.Collections.Generic.ICollection containing the keys of the Multimap.
        /// </summary>
        public ICollection<TKey> Keys => _dictionary.Keys;
        /// <summary>
        /// Gets a System.Collections.Generic.ICollection containing the values of the Multimap.
        /// </summary>
        public ICollection<IList<TValue>> Values => _dictionary.Values;
        /// <summary>
        ///  Copy the items of the Multimap to an System.Array,
        ///     starting at a particular System.Array index.
        /// </summary>
        /// <param name="array">The one-dimensional System.Array that is the destination of the items copied
        ///     from Multimap. The System.Array must have zero-based indexing.</param>
        /// <param name="index">The zero-based index in array at which copying begins.</param>
        public void CopyTo(Array array, int index)
        {
            ((ICollection)_dictionary).CopyTo(array, index);
        }
        /// <summary>
        /// Adds an item with the provided key and value to the Multimap.
        /// </summary>
        /// <param name="key">The object to use as the key of the item to add.</param>
        /// <param name="value">The object to use as the value of the item to add.</param>
        /// <exception cref="InvalidOperationException">Thrown when couldn't add value to Multimap.</exception>
        public void Add(TKey key, TValue value)
        {
            if (value != null)
            {
                if (_dictionary.TryGetValue(key, out var list))
                {
                    list.Add(value);
                }
                else
                {
                    list = new List<TValue> { value };
                    if (!TryAdd(key, list))
                        throw new InvalidOperationException("Could not add value to Multimap.");
                }
            }
        }
        #endregion Public Members
        #region Private Members
        /**
         * Helper method to encapsulate generator differences between dictionary types.
         */
        private bool TryRemove(TKey key, out IList<TValue> value)
        {
            _dictionary.TryGetValue(key, out value);
            return _dictionary.Remove(key);
        }
        /**
         * Helper method to encapsulate generator differences between dictionary types.
         */
        private bool TryAdd(TKey key, IList<TValue> value)
        {
            try
            {
                _dictionary.Add(key, value);
            }
            catch (ArgumentException)
            {
                return false;
            }
            return true;
        }
        #endregion Private Members
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Formatter for 'date' openapi formats ss defined by full-date - RFC3339
    /// see https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#data-types
    /// </summary>
    public class OpenAPIDateConverter : IsoDateTimeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OpenAPIDateConverter" /> class.
        /// </summary>
        public OpenAPIDateConverter()
        {
            // full-date   = date-fullyear "-" date-month "-" date-mday
            DateTimeFormat = "yyyy-MM-dd";
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// A container for generalized request inputs. This type allows consumers to extend the request functionality
    /// by abstracting away from the default (built-in) request framework (e.g. RestSharp).
    /// </summary>
    public class RequestOptions
    {
        /// <summary>
        /// Parameters to be bound to path parts of the Request's URL
        /// </summary>
        public Dictionary<string, string> PathParameters { get; set; }
        /// <summary>
        /// Query parameters to be applied to the request.
        /// Keys may have 1 or more values associated.
        /// </summary>
        public Multimap<string, string> QueryParameters { get; set; }
        /// <summary>
        /// Header parameters to be applied to the request.
        /// Keys may have 1 or more values associated.
        /// </summary>
        public Multimap<string, string> HeaderParameters { get; set; }
        /// <summary>
        /// Form parameters to be sent along with the request.
        /// </summary>
        public Dictionary<string, string> FormParameters { get; set; }
        /// <summary>
        /// File parameters to be sent along with the request.
        /// </summary>
        public Multimap<string, Stream> FileParameters { get; set; }
        /// <summary>
        /// Cookies to be sent along with the request.
        /// </summary>
        public List<Cookie> Cookies { get; set; }
        /// <summary>
        /// Operation associated with the request path.
        /// </summary>
        public string Operation { get; set; }
        /// <summary>
        /// Index associated with the operation.
        /// </summary>
        public int OperationIndex { get; set; }
        /// <summary>
        /// Any data associated with a request body.
        /// </summary>
        public Object Data { get; set; }
        /// <summary>
        /// Constructs a new instance of <see cref="RequestOptions"/>
        /// </summary>
        public RequestOptions()
        {
            PathParameters = new Dictionary<string, string>();
            QueryParameters = new Multimap<string, string>();
            HeaderParameters = new Multimap<string, string>();
            FormParameters = new Dictionary<string, string>();
            FileParameters = new Multimap<string, Stream>();
            Cookies = new List<Cookie>();
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Client
{
    /// <summary>
    /// Configuration class to set the polly retry policies to be applied to the requests.
    /// </summary>
    public static class RetryConfiguration
    {
        /// <summary>
        /// Retry policy
        /// </summary>
        public static Policy<RestResponse> RetryPolicy { get; set; }
        /// <summary>
        /// Async retry policy
        /// </summary>
        public static AsyncPolicy<RestResponse> AsyncRetryPolicy { get; set; }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    ///  Abstract base class for oneOf, anyOf schemas in the OpenAPI specification
    /// </summary>
    public abstract partial class AbstractOpenAPISchema
    {
        /// <summary>
        ///  Custom JSON serializer
        /// </summary>
        static public readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            MissingMemberHandling = MissingMemberHandling.Error,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        /// <summary>
        ///  Custom JSON serializer for objects with additional properties
        /// </summary>
        static public readonly JsonSerializerSettings AdditionalPropertiesSerializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            MissingMemberHandling = MissingMemberHandling.Ignore,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };
        /// <summary>
        /// Gets or Sets the actual instance
        /// </summary>
        public abstract Object ActualInstance { get; set; }
        /// <summary>
        /// Gets or Sets IsNullable to indicate whether the instance is nullable
        /// </summary>
        public bool IsNullable { get; protected set; }
        /// <summary>
        /// Gets or Sets the schema type, which can be either `oneOf` or `anyOf`
        /// </summary>
        public string SchemaType { get; protected set; }
        /// <summary>
        /// Converts the instance into JSON string.
        /// </summary>
        public abstract string ToJson();
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Indicates if a route section is entered or exited. Not present if the violation type is _SCHEDULE_.  * &#x60;ENTER&#x60; - Entering a section.    * &#x60;EXIT&#x60; - Exiting a section.    * &#x60;PASS&#x60; - When the section is very small, it is passed.
    /// </summary>
    /// <value>Indicates if a route section is entered or exited. Not present if the violation type is _SCHEDULE_.  * &#x60;ENTER&#x60; - Entering a section.    * &#x60;EXIT&#x60; - Exiting a section.    * &#x60;PASS&#x60; - When the section is very small, it is passed.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum AccessType
    {
        /// <summary>
        /// Enum ENTER for value: ENTER
        /// </summary>
        [EnumMember(Value = "ENTER")]
        ENTER = 1,
        /// <summary>
        /// Enum EXIT for value: EXIT
        /// </summary>
        [EnumMember(Value = "EXIT")]
        EXIT = 2,
        /// <summary>
        /// Enum PASS for value: PASS
        /// </summary>
        [EnumMember(Value = "PASS")]
        PASS = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// AlternativeRoute
    /// </summary>
    [DataContract(Name = "AlternativeRoute")]
    public partial class AlternativeRoute : IEquatable<AlternativeRoute>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AlternativeRoute" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected AlternativeRoute() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="AlternativeRoute" /> class.
        /// </summary>
        /// <param name="distance">The distance of the alternative route [m]. (required).</param>
        /// <param name="travelTime">The travel time for the alternative route [s]. (required).</param>
        /// <param name="trafficDelay">The total delay due to live traffic on this alternative route [s].  This value contains the sum of all traffic events on this alternative route and  will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information..</param>
        /// <param name="violated">When the alternative route cannot be calculated for the given vehicle the resulting alternative route is marked as violated. (required).</param>
        /// <param name="polyline">The polyline of the alternative route in the format specified by **options[polylineFormat]**..</param>
        /// <param name="routeId">Route ID of the alternative route..</param>
        public AlternativeRoute(int distance = default(int), int travelTime = default(int), int trafficDelay = default(int), bool violated = default(bool), string polyline = default(string), Guid routeId = default(Guid))
        {
            this.Distance = distance;
            this.TravelTime = travelTime;
            this.Violated = violated;
            this.TrafficDelay = trafficDelay;
            this.Polyline = polyline;
            this.RouteId = routeId;
        }
        /// <summary>
        /// The distance of the alternative route [m].
        /// </summary>
        /// <value>The distance of the alternative route [m].</value>
        /// <example>1422</example>
        [DataMember(Name = "distance", IsRequired = true, EmitDefaultValue = true)]
        public int Distance { get; set; }
        /// <summary>
        /// The travel time for the alternative route [s].
        /// </summary>
        /// <value>The travel time for the alternative route [s].</value>
        /// <example>56</example>
        [DataMember(Name = "travelTime", IsRequired = true, EmitDefaultValue = true)]
        public int TravelTime { get; set; }
        /// <summary>
        /// The total delay due to live traffic on this alternative route [s].  This value contains the sum of all traffic events on this alternative route and  will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information.
        /// </summary>
        /// <value>The total delay due to live traffic on this alternative route [s].  This value contains the sum of all traffic events on this alternative route and  will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information.</value>
        /// <example>0</example>
        [DataMember(Name = "trafficDelay", EmitDefaultValue = false)]
        public int TrafficDelay { get; set; }
        /// <summary>
        /// When the alternative route cannot be calculated for the given vehicle the resulting alternative route is marked as violated.
        /// </summary>
        /// <value>When the alternative route cannot be calculated for the given vehicle the resulting alternative route is marked as violated.</value>
        /// <example>false</example>
        [DataMember(Name = "violated", IsRequired = true, EmitDefaultValue = true)]
        public bool Violated { get; set; }
        /// <summary>
        /// The polyline of the alternative route in the format specified by **options[polylineFormat]**.
        /// </summary>
        /// <value>The polyline of the alternative route in the format specified by **options[polylineFormat]**.</value>
        [DataMember(Name = "polyline", EmitDefaultValue = false)]
        public string Polyline { get; set; }
        /// <summary>
        /// Route ID of the alternative route.
        /// </summary>
        /// <value>Route ID of the alternative route.</value>
        [DataMember(Name = "routeId", EmitDefaultValue = false)]
        public Guid RouteId { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AlternativeRoute {\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TravelTime: ").Append(TravelTime).Append("\n");
            sb.Append("  TrafficDelay: ").Append(TrafficDelay).Append("\n");
            sb.Append("  Violated: ").Append(Violated).Append("\n");
            sb.Append("  Polyline: ").Append(Polyline).Append("\n");
            sb.Append("  RouteId: ").Append(RouteId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as AlternativeRoute);
        }
        /// <summary>
        /// Returns true if AlternativeRoute instances are equal
        /// </summary>
        /// <param name="input">Instance of AlternativeRoute to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AlternativeRoute input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Distance == input.Distance ||
                    this.Distance.Equals(input.Distance)
                ) && 
                (
                    this.TravelTime == input.TravelTime ||
                    this.TravelTime.Equals(input.TravelTime)
                ) && 
                (
                    this.TrafficDelay == input.TrafficDelay ||
                    this.TrafficDelay.Equals(input.TrafficDelay)
                ) && 
                (
                    this.Violated == input.Violated ||
                    this.Violated.Equals(input.Violated)
                ) && 
                (
                    this.Polyline == input.Polyline ||
                    (this.Polyline != null &&
                    this.Polyline.Equals(input.Polyline))
                ) && 
                (
                    this.RouteId == input.RouteId ||
                    (this.RouteId != null &&
                    this.RouteId.Equals(input.RouteId))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                hashCode = (hashCode * 59) + this.TravelTime.GetHashCode();
                hashCode = (hashCode * 59) + this.TrafficDelay.GetHashCode();
                hashCode = (hashCode * 59) + this.Violated.GetHashCode();
                if (this.Polyline != null)
                {
                    hashCode = (hashCode * 59) + this.Polyline.GetHashCode();
                }
                if (this.RouteId != null)
                {
                    hashCode = (hashCode * 59) + this.RouteId.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Distance (int) minimum
            if (this.Distance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Distance, must be a value greater than or equal to 0.", new [] { "Distance" });
            }
            // TravelTime (int) minimum
            if (this.TravelTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TravelTime, must be a value greater than or equal to 0.", new [] { "TravelTime" });
            }
            // TrafficDelay (int) minimum
            if (this.TrafficDelay < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TrafficDelay, must be a value greater than or equal to 0.", new [] { "TrafficDelay" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines AvoidFeature
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum AvoidFeature
    {
        /// <summary>
        /// Enum TOLL for value: TOLL
        /// </summary>
        [EnumMember(Value = "TOLL")]
        TOLL = 1,
        /// <summary>
        /// Enum FERRIES for value: FERRIES
        /// </summary>
        [EnumMember(Value = "FERRIES")]
        FERRIES = 2,
        /// <summary>
        /// Enum RAIL_SHUTTLES for value: RAIL_SHUTTLES
        /// </summary>
        [EnumMember(Value = "RAIL_SHUTTLES")]
        RAIL_SHUTTLES = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when a border of a country of a subdivision is crossed by the route, i.e. the current country code changes. Requires _BORDER_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "BorderEvent")]
    public partial class BorderEvent : IEquatable<BorderEvent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BorderEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected BorderEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BorderEvent" /> class.
        /// </summary>
        /// <param name="countryCode">The country or subdivision the route enters represented by its code according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. (required).</param>
        public BorderEvent(string countryCode = default(string))
        {
            // to ensure "countryCode" is required (not null)
            if (countryCode == null)
            {
                throw new ArgumentNullException("countryCode is a required property for BorderEvent and cannot be null");
            }
            this.CountryCode = countryCode;
        }
        /// <summary>
        /// The country or subdivision the route enters represented by its code according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>The country or subdivision the route enters represented by its code according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "countryCode", IsRequired = true, EmitDefaultValue = true)]
        public string CountryCode { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class BorderEvent {\n");
            sb.Append("  CountryCode: ").Append(CountryCode).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as BorderEvent);
        }
        /// <summary>
        /// Returns true if BorderEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of BorderEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BorderEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.CountryCode == input.CountryCode ||
                    (this.CountryCode != null &&
                    this.CountryCode.Equals(input.CountryCode))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CountryCode != null)
                {
                    hashCode = (hashCode * 59) + this.CountryCode.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The current status of the calculation.  * &#x60;RUNNING&#x60; - The calculation is still running.  * &#x60;SUCCEEDED&#x60; - The calculation has completed successfully.  * &#x60;FAILED&#x60; - The calculation has completed with a failure.
    /// </summary>
    /// <value>The current status of the calculation.  * &#x60;RUNNING&#x60; - The calculation is still running.  * &#x60;SUCCEEDED&#x60; - The calculation has completed successfully.  * &#x60;FAILED&#x60; - The calculation has completed with a failure.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum CalculationStatus
    {
        /// <summary>
        /// Enum RUNNING for value: RUNNING
        /// </summary>
        [EnumMember(Value = "RUNNING")]
        RUNNING = 1,
        /// <summary>
        /// Enum SUCCEEDED for value: SUCCEEDED
        /// </summary>
        [EnumMember(Value = "SUCCEEDED")]
        SUCCEEDED = 2,
        /// <summary>
        /// Enum FAILED for value: FAILED
        /// </summary>
        [EnumMember(Value = "FAILED")]
        FAILED = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// CausingError
    /// </summary>
    [DataContract(Name = "CausingError")]
    public partial class CausingError : IEquatable<CausingError>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CausingError" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CausingError() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CausingError" /> class.
        /// </summary>
        /// <param name="description">A human readable message that describes the error. (required).</param>
        /// <param name="errorCode">A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **Error codes for** &#x60;GENERAL_VALIDATION_ERROR&#x60;  * &#x60;GENERAL_INVALID_VALUE&#x60; - A parameter is set to an invalid value.   * &#x60;value&#x60; - The invalid value. * &#x60;GENERAL_UNRECOGNIZED_PARAMETER&#x60; - A parameter is unknown. * &#x60;GENERAL_MISSING_PARAMETER&#x60; - A required parameter is missing. * &#x60;GENERAL_MINIMUM_LENGTH_VIOLATED&#x60; - The minimum length is violated.   * &#x60;minimumLength&#x60; - The minimum length (integer). * &#x60;GENERAL_MAXIMUM_LENGTH_VIOLATED&#x60; - The maximum length is violated.   * &#x60;maximumLength&#x60; - The maximum length (integer). * &#x60;GENERAL_MINIMUM_VALUE_VIOLATED&#x60; - The minimum value restriction is violated.   * &#x60;minimumValue&#x60; - The minimum value (integer or double). * &#x60;GENERAL_MAXIMUM_VALUE_VIOLATED&#x60; - The maximum value restriction is violated.   * &#x60;maximumValue&#x60; - The maximum value (integer or double). * &#x60;GENERAL_DUPLICATE_PARAMETER&#x60; - A parameter is duplicated. * &#x60;GENERAL_INVALID_LIST&#x60; - A list has an invalid format such as duplicate commas.   * &#x60;value&#x60; - The invalid list. * &#x60;GENERAL_INVALID_INTERVAL&#x60; - A time interval is invalid, i.e. start is greater than end. * &#x60;ROUTING_INVALID_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is set to an invalid value.   * &#x60;attribute&#x60; - The invalid waypoint attribute. * &#x60;ROUTING_UNRECOGNIZED_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is unknown.   * &#x60;attribute&#x60; - The invalid waypoint key. * &#x60;ROUTING_DUPLICATE_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is duplicated.   * &#x60;attribute&#x60; - The duplicated waypoint key. * &#x60;ROUTING_WAYPOINT_ATTRIBUTE_CONFLICT&#x60; - Two waypoint attributes are in conflict with each other.   * &#x60;attribute&#x60; - The first conflicting attribute.   * &#x60;conflictingAttribute&#x60; - The second conflicting attribute. * &#x60;ROUTING_INVALID_MANIPULATION_WAYPOINT_ORDER&#x60; - The manipulation waypoint is not valid for start or destination. * &#x60;ROUTING_INVALID_COMBINED_TRANSPORT_WAYPOINT_ORDER&#x60; - The combinedTransport waypoint is not valid for start or destination. * &#x60;ROUTING_INVALID_WAYPOINT_LIST_FOR_ALTERNATIVE_ROUTES&#x60; - Alternative routes are supported only for two on-road or off-road waypoints. * &#x60;ROUTING_INVALID_WAYPOINT&#x60; - A waypoint contains multiple types or none of them, but exactly one must be specified. * &#x60;ROUTING_MUST_HAVE_WAYPOINTS_OR_ROUTE_ID&#x60; - The request must have either at least two **waypoints** or a **routeId**. * &#x60;ROUTING_EMISSIONS_MUTUALLY_EXCLUSIVE&#x60; - All emissions _EN16258_2012_ results and _ISO14083_2022_ or _ISO14083_2023_ results are mutually exclusive.   * &#x60;attribute&#x60; - The first conflicting emissions standard.   * &#x60;conflictingAttributes&#x60; - The list of other conflicting emissions standards. * &#x60;ROUTING_START_AND_ARRIVAL_TIME_MUTUALLY_EXCLUSIVE&#x60; - **options[startTime]** and **options[arrivalTime]** are mutually exclusive. - _The **parameter** remains empty._ * &#x60;ROUTING_ESTIMATED_DISTANCE_TOO_LONG&#x60; - The distance of the route (estimated by air-line) for non-motorized vehicles is too long. - _The **parameter** remains empty._   * &#x60;distance&#x60; - The estimated distance (integer).   * &#x60;limit&#x60; - The maximum allowable distance (integer). * &#x60;ROUTING_PARAMETER_CONFLICT&#x60; - Two parameters are in conflict with each other.   * &#x60;conflictingParameter&#x60; - The conflicting parameter.   * &#x60;message&#x60; - The error message. * &#x60;ROUTING_NO_VALID_COUNTRY_ALLOWED&#x60; - The list of allowed countries does not contain any of the available countries so that the effective list of countries allowed for routing is empty.   * &#x60;allowedCountries&#x60; - The list of allowed countries. * &#x60;ROUTING_ALL_VALID_COUNTRIES_PROHIBITED&#x60; - The list of prohibited countries contains all available countries so that the effective list of countries allowed for routing is empty.   * &#x60;prohibitedCountries&#x60; - The list of prohibited countries. * &#x60;ROUTING_ALLOWED_AND_PROHIBITED_COUNTRIES_CONFLICT&#x60; - The lists of allowed and prohibited countries contain the same countries so that the effective list of countries allowed for routing is empty. - _The **parameter** remains empty._   * &#x60;allowedCountries&#x60; - The list of allowed countries.   * &#x60;prohibitedCountries&#x60; - The list of prohibited countries. * &#x60;ROUTING_MAXIMUM_HORIZON_VALUE_VIOLATED&#x60; - The maximum value of horizon is violated.   * &#x60;limit&#x60; - The maximum allowable horizon (integer). * &#x60;ROUTING_MUST_HAVE_ONE_WAYPOINT_OR_ROUTE_ID&#x60; - The request must have either a **waypoint** or a **routeId**. * &#x60;ROUTING_HORIZONS_EQUAL_OR_NOT_ASCENDING&#x60; - The horizons have equal values or are not ascending.   * &#x60;value&#x60; - The invalid horizon. * &#x60;ROUTING_ROUTE_TOO_LONG_FOR_REACHABILITY&#x60; - The route is too long to be used with reachable areas or locations.   * &#x60;length&#x60; - The actual route length (integer).   * &#x60;limit&#x60; - The maximum allowable route length (integer). * &#x60;ROUTING_ALLOWED_AND_PROHIBITED_COUNTRIES_IN_CONFLICT_WITH_ROUTE_ID&#x60; - The lists of allowed and prohibited countries are in conflict with the **routeId** which passes an effectively prohibited country.   * &#x60;value&#x60; - The value in conflict. * &#x60;ROUTING_ROUTE_ID_NOT_FOUND&#x60; - The **routeId** cannot be found.   * &#x60;value&#x60; - The routeId. * &#x60;ROUTING_ROUTE_ID_CANNOT_BE_USED&#x60; - The **routeId** cannot be used for this operation as it was created by a service other than routing and lacks a routing context.   * &#x60;value&#x60; - The routeId. * &#x60;ROUTING_PROFILE_NOT_FOUND&#x60; - The requested **profile** could not be found.   * &#x60;value&#x60; - The profile name. * &#x60;ROUTING_UNSUPPORTED_CURRENCY&#x60; - The specified currency is not supported.   * &#x60;currency&#x60; - The unsupported currency. * &#x60;ROUTING_PARAMETER_ONLY_SUPPORTED_BY_POST&#x60; - A requested parameter is only supported for the appropriate POST operation.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_OPENING_INTERVALS_REQUIRE_TIME&#x60; - When using opening intervals with a waypoint and with **options[trafficMode]** _AVERAGE_ either a start or an arrival time has to be specified. * &#x60;ROUTING_ARRIVAL_TIME_WITH_SCHEDULE&#x60; - **options[arrivalTime]** cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_INVALID_NUMBER_OF_COORDINATES&#x60; - The polyline cannot be parsed because the number of coordinates is not even or less than 4.   * &#x60;value&#x60; - The invalid parameter value.   * &#x60;polylineIndex&#x60; - The index denoting the polyline in which the error was found (integer). * &#x60;ROUTING_INVALID_COORDINATE&#x60; - The provided coordinate is not in the valid range or cannot be parsed.   * &#x60;value&#x60; - The invalid parameter value.   * &#x60;polylineIndex&#x60; - The index denoting the polyline in which the error was found (integer).   * &#x60;coordinateIndex&#x60; - The index denoting the erroneous coordinate within the polyline (integer). * &#x60;ROUTING_FEATURE_NOT_SUPPORTED_WITH_MONETARY_COSTS&#x60; - The requested feature is not supported when **options[routingMode]** is _MONETARY_.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_MUST_HAVE_MONETARY_COST_VALUE&#x60; - Both values **monetaryCostOptions[costPerKilometer]** and **monetaryCostOptions[workingCostPerHour]** are zero. Use a value greater zero for at least one of this **monetaryCostOptions** parameters. * &#x60;ROUTING_CUSTOM_ROAD_ATTRIBUTE_SCENARIO_NOT_FOUND&#x60; - At least one of the requested **options[customRoadAttributeScenarios]** could not be found.   * &#x60;scenarios&#x60; - The scenarios which could not be found (comma-separated list). * &#x60;ROUTING_POSITION_AND_WAYPOINT_MUTUALLY_EXCLUSIVE&#x60; - **position** and **waypoint** are mutually exclusive. - _The **parameter** remains empty._ * &#x60;ROUTING_VEHICLE_POSITION_MISSING&#x60; - The position of the vehicle must be specified by either **position** or **waypoint**. - _The **parameter** remains empty._ * &#x60;ROUTING_UNSUPPORTED_WAYPOINT_TYPE_FOR_ETA_CALCULATION&#x60; - The ETA calculation does not support route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints.   * &#x60;waypointIndex&#x60; - The index of the waypoint (integer). * &#x60;ROUTING_MISSING_WAYPOINT_NAME&#x60; - The requested route for the **routeId** contains a waypoint which does not have a name.   * &#x60;waypointIndex&#x60; - The index of the waypoint (integer). * &#x60;ROUTING_DUPLICATE_WAYPOINT_NAME&#x60; - The requested route for the **routeId** contains waypoints with a duplicate name.   * &#x60;waypointIndexes&#x60; - The indexes of the waypoints with the duplicated name (comma-separated list).   * &#x60;name&#x60; - The duplicate waypoint name. * &#x60;ROUTING_WAYPOINT_NAME_NOT_FOUND&#x60; - The waypoint name could not be found in the requested route for the **routeId**.   * &#x60;name&#x60; - The invalid waypoint name. * &#x60;ROUTING_VEHICLE_POSITION_BEFORE_FIRST_WAYPOINT&#x60; - The position of the vehicle cannot be before the first waypoint. * &#x60;ROUTING_ROUTE_ID_REQUIRES_WORKLOGBOOK&#x60; - The route associated with the given **routeId** has been calculated with a **driver** and requires the **workLogbook** to be specified in the ETA request. * &#x60;ROUTING_ROUTE_ID_DOES_NOT_SUPPORT_WORKLOGBOOK&#x60; - The route associated with the given **routeId** has been calculated without a **driver** and does not support the **workLogbook** specified in the ETA request.  **Error codes for** &#x60;ROUTING_ERROR&#x60;  * &#x60;ROUTING_WAYPOINT_CANNOT_BE_MATCHED&#x60; - The waypoint cannot be matched to the nearest possible road. * &#x60;ROUTING_ROUTE_NOT_FOUND&#x60; - A route between at least two waypoints could not be found for the current configuration and profile. - _The **parameter** remains empty._ * &#x60;ROUTING_TIMEOUT&#x60; - The route calculation has timed out. * &#x60;ROUTING_UTC_OFFSET_CANNOT_BE_DETERMINED&#x60; - The UTC offset of the start waypoint cannot be determined. * &#x60;ROUTING_BLOCK_INTERSECTING_ROADS_TOO_MANY_SEGMENTS&#x60; - The maximum number of road segments intersecting one polyline must not exceed 5000.  **Error codes for** &#x60;ROUTING_RESTRICTION_EXCEEDED&#x60;  * &#x60;ROUTING_TOO_MANY_WAYPOINTS&#x60; - The request contains too many waypoints.   * &#x60;limit&#x60;- The maximum allowed number of waypoints for a single request (integer).  **Error codes for** &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60;  * &#x60;GENERAL_INVALID_ID&#x60; - The ID does not exist.   * &#x60;value&#x60; - The invalid ID. (required).</param>
        /// <param name="varParameter">The name of the affected query or path parameter or a JSONPath to the affected property of the request..</param>
        /// <param name="details">Additional properties specific to this error class..</param>
        public CausingError(string description = default(string), string errorCode = default(string), string varParameter = default(string), Dictionary<string, Object> details = default(Dictionary<string, Object>))
        {
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for CausingError and cannot be null");
            }
            this.Description = description;
            // to ensure "errorCode" is required (not null)
            if (errorCode == null)
            {
                throw new ArgumentNullException("errorCode is a required property for CausingError and cannot be null");
            }
            this.ErrorCode = errorCode;
            this.VarParameter = varParameter;
            this.Details = details;
        }
        /// <summary>
        /// A human readable message that describes the error.
        /// </summary>
        /// <value>A human readable message that describes the error.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = true)]
        public string Description { get; set; }
        /// <summary>
        /// A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **Error codes for** &#x60;GENERAL_VALIDATION_ERROR&#x60;  * &#x60;GENERAL_INVALID_VALUE&#x60; - A parameter is set to an invalid value.   * &#x60;value&#x60; - The invalid value. * &#x60;GENERAL_UNRECOGNIZED_PARAMETER&#x60; - A parameter is unknown. * &#x60;GENERAL_MISSING_PARAMETER&#x60; - A required parameter is missing. * &#x60;GENERAL_MINIMUM_LENGTH_VIOLATED&#x60; - The minimum length is violated.   * &#x60;minimumLength&#x60; - The minimum length (integer). * &#x60;GENERAL_MAXIMUM_LENGTH_VIOLATED&#x60; - The maximum length is violated.   * &#x60;maximumLength&#x60; - The maximum length (integer). * &#x60;GENERAL_MINIMUM_VALUE_VIOLATED&#x60; - The minimum value restriction is violated.   * &#x60;minimumValue&#x60; - The minimum value (integer or double). * &#x60;GENERAL_MAXIMUM_VALUE_VIOLATED&#x60; - The maximum value restriction is violated.   * &#x60;maximumValue&#x60; - The maximum value (integer or double). * &#x60;GENERAL_DUPLICATE_PARAMETER&#x60; - A parameter is duplicated. * &#x60;GENERAL_INVALID_LIST&#x60; - A list has an invalid format such as duplicate commas.   * &#x60;value&#x60; - The invalid list. * &#x60;GENERAL_INVALID_INTERVAL&#x60; - A time interval is invalid, i.e. start is greater than end. * &#x60;ROUTING_INVALID_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is set to an invalid value.   * &#x60;attribute&#x60; - The invalid waypoint attribute. * &#x60;ROUTING_UNRECOGNIZED_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is unknown.   * &#x60;attribute&#x60; - The invalid waypoint key. * &#x60;ROUTING_DUPLICATE_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is duplicated.   * &#x60;attribute&#x60; - The duplicated waypoint key. * &#x60;ROUTING_WAYPOINT_ATTRIBUTE_CONFLICT&#x60; - Two waypoint attributes are in conflict with each other.   * &#x60;attribute&#x60; - The first conflicting attribute.   * &#x60;conflictingAttribute&#x60; - The second conflicting attribute. * &#x60;ROUTING_INVALID_MANIPULATION_WAYPOINT_ORDER&#x60; - The manipulation waypoint is not valid for start or destination. * &#x60;ROUTING_INVALID_COMBINED_TRANSPORT_WAYPOINT_ORDER&#x60; - The combinedTransport waypoint is not valid for start or destination. * &#x60;ROUTING_INVALID_WAYPOINT_LIST_FOR_ALTERNATIVE_ROUTES&#x60; - Alternative routes are supported only for two on-road or off-road waypoints. * &#x60;ROUTING_INVALID_WAYPOINT&#x60; - A waypoint contains multiple types or none of them, but exactly one must be specified. * &#x60;ROUTING_MUST_HAVE_WAYPOINTS_OR_ROUTE_ID&#x60; - The request must have either at least two **waypoints** or a **routeId**. * &#x60;ROUTING_EMISSIONS_MUTUALLY_EXCLUSIVE&#x60; - All emissions _EN16258_2012_ results and _ISO14083_2022_ or _ISO14083_2023_ results are mutually exclusive.   * &#x60;attribute&#x60; - The first conflicting emissions standard.   * &#x60;conflictingAttributes&#x60; - The list of other conflicting emissions standards. * &#x60;ROUTING_START_AND_ARRIVAL_TIME_MUTUALLY_EXCLUSIVE&#x60; - **options[startTime]** and **options[arrivalTime]** are mutually exclusive. - _The **parameter** remains empty._ * &#x60;ROUTING_ESTIMATED_DISTANCE_TOO_LONG&#x60; - The distance of the route (estimated by air-line) for non-motorized vehicles is too long. - _The **parameter** remains empty._   * &#x60;distance&#x60; - The estimated distance (integer).   * &#x60;limit&#x60; - The maximum allowable distance (integer). * &#x60;ROUTING_PARAMETER_CONFLICT&#x60; - Two parameters are in conflict with each other.   * &#x60;conflictingParameter&#x60; - The conflicting parameter.   * &#x60;message&#x60; - The error message. * &#x60;ROUTING_NO_VALID_COUNTRY_ALLOWED&#x60; - The list of allowed countries does not contain any of the available countries so that the effective list of countries allowed for routing is empty.   * &#x60;allowedCountries&#x60; - The list of allowed countries. * &#x60;ROUTING_ALL_VALID_COUNTRIES_PROHIBITED&#x60; - The list of prohibited countries contains all available countries so that the effective list of countries allowed for routing is empty.   * &#x60;prohibitedCountries&#x60; - The list of prohibited countries. * &#x60;ROUTING_ALLOWED_AND_PROHIBITED_COUNTRIES_CONFLICT&#x60; - The lists of allowed and prohibited countries contain the same countries so that the effective list of countries allowed for routing is empty. - _The **parameter** remains empty._   * &#x60;allowedCountries&#x60; - The list of allowed countries.   * &#x60;prohibitedCountries&#x60; - The list of prohibited countries. * &#x60;ROUTING_MAXIMUM_HORIZON_VALUE_VIOLATED&#x60; - The maximum value of horizon is violated.   * &#x60;limit&#x60; - The maximum allowable horizon (integer). * &#x60;ROUTING_MUST_HAVE_ONE_WAYPOINT_OR_ROUTE_ID&#x60; - The request must have either a **waypoint** or a **routeId**. * &#x60;ROUTING_HORIZONS_EQUAL_OR_NOT_ASCENDING&#x60; - The horizons have equal values or are not ascending.   * &#x60;value&#x60; - The invalid horizon. * &#x60;ROUTING_ROUTE_TOO_LONG_FOR_REACHABILITY&#x60; - The route is too long to be used with reachable areas or locations.   * &#x60;length&#x60; - The actual route length (integer).   * &#x60;limit&#x60; - The maximum allowable route length (integer). * &#x60;ROUTING_ALLOWED_AND_PROHIBITED_COUNTRIES_IN_CONFLICT_WITH_ROUTE_ID&#x60; - The lists of allowed and prohibited countries are in conflict with the **routeId** which passes an effectively prohibited country.   * &#x60;value&#x60; - The value in conflict. * &#x60;ROUTING_ROUTE_ID_NOT_FOUND&#x60; - The **routeId** cannot be found.   * &#x60;value&#x60; - The routeId. * &#x60;ROUTING_ROUTE_ID_CANNOT_BE_USED&#x60; - The **routeId** cannot be used for this operation as it was created by a service other than routing and lacks a routing context.   * &#x60;value&#x60; - The routeId. * &#x60;ROUTING_PROFILE_NOT_FOUND&#x60; - The requested **profile** could not be found.   * &#x60;value&#x60; - The profile name. * &#x60;ROUTING_UNSUPPORTED_CURRENCY&#x60; - The specified currency is not supported.   * &#x60;currency&#x60; - The unsupported currency. * &#x60;ROUTING_PARAMETER_ONLY_SUPPORTED_BY_POST&#x60; - A requested parameter is only supported for the appropriate POST operation.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_OPENING_INTERVALS_REQUIRE_TIME&#x60; - When using opening intervals with a waypoint and with **options[trafficMode]** _AVERAGE_ either a start or an arrival time has to be specified. * &#x60;ROUTING_ARRIVAL_TIME_WITH_SCHEDULE&#x60; - **options[arrivalTime]** cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_INVALID_NUMBER_OF_COORDINATES&#x60; - The polyline cannot be parsed because the number of coordinates is not even or less than 4.   * &#x60;value&#x60; - The invalid parameter value.   * &#x60;polylineIndex&#x60; - The index denoting the polyline in which the error was found (integer). * &#x60;ROUTING_INVALID_COORDINATE&#x60; - The provided coordinate is not in the valid range or cannot be parsed.   * &#x60;value&#x60; - The invalid parameter value.   * &#x60;polylineIndex&#x60; - The index denoting the polyline in which the error was found (integer).   * &#x60;coordinateIndex&#x60; - The index denoting the erroneous coordinate within the polyline (integer). * &#x60;ROUTING_FEATURE_NOT_SUPPORTED_WITH_MONETARY_COSTS&#x60; - The requested feature is not supported when **options[routingMode]** is _MONETARY_.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_MUST_HAVE_MONETARY_COST_VALUE&#x60; - Both values **monetaryCostOptions[costPerKilometer]** and **monetaryCostOptions[workingCostPerHour]** are zero. Use a value greater zero for at least one of this **monetaryCostOptions** parameters. * &#x60;ROUTING_CUSTOM_ROAD_ATTRIBUTE_SCENARIO_NOT_FOUND&#x60; - At least one of the requested **options[customRoadAttributeScenarios]** could not be found.   * &#x60;scenarios&#x60; - The scenarios which could not be found (comma-separated list). * &#x60;ROUTING_POSITION_AND_WAYPOINT_MUTUALLY_EXCLUSIVE&#x60; - **position** and **waypoint** are mutually exclusive. - _The **parameter** remains empty._ * &#x60;ROUTING_VEHICLE_POSITION_MISSING&#x60; - The position of the vehicle must be specified by either **position** or **waypoint**. - _The **parameter** remains empty._ * &#x60;ROUTING_UNSUPPORTED_WAYPOINT_TYPE_FOR_ETA_CALCULATION&#x60; - The ETA calculation does not support route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints.   * &#x60;waypointIndex&#x60; - The index of the waypoint (integer). * &#x60;ROUTING_MISSING_WAYPOINT_NAME&#x60; - The requested route for the **routeId** contains a waypoint which does not have a name.   * &#x60;waypointIndex&#x60; - The index of the waypoint (integer). * &#x60;ROUTING_DUPLICATE_WAYPOINT_NAME&#x60; - The requested route for the **routeId** contains waypoints with a duplicate name.   * &#x60;waypointIndexes&#x60; - The indexes of the waypoints with the duplicated name (comma-separated list).   * &#x60;name&#x60; - The duplicate waypoint name. * &#x60;ROUTING_WAYPOINT_NAME_NOT_FOUND&#x60; - The waypoint name could not be found in the requested route for the **routeId**.   * &#x60;name&#x60; - The invalid waypoint name. * &#x60;ROUTING_VEHICLE_POSITION_BEFORE_FIRST_WAYPOINT&#x60; - The position of the vehicle cannot be before the first waypoint. * &#x60;ROUTING_ROUTE_ID_REQUIRES_WORKLOGBOOK&#x60; - The route associated with the given **routeId** has been calculated with a **driver** and requires the **workLogbook** to be specified in the ETA request. * &#x60;ROUTING_ROUTE_ID_DOES_NOT_SUPPORT_WORKLOGBOOK&#x60; - The route associated with the given **routeId** has been calculated without a **driver** and does not support the **workLogbook** specified in the ETA request.  **Error codes for** &#x60;ROUTING_ERROR&#x60;  * &#x60;ROUTING_WAYPOINT_CANNOT_BE_MATCHED&#x60; - The waypoint cannot be matched to the nearest possible road. * &#x60;ROUTING_ROUTE_NOT_FOUND&#x60; - A route between at least two waypoints could not be found for the current configuration and profile. - _The **parameter** remains empty._ * &#x60;ROUTING_TIMEOUT&#x60; - The route calculation has timed out. * &#x60;ROUTING_UTC_OFFSET_CANNOT_BE_DETERMINED&#x60; - The UTC offset of the start waypoint cannot be determined. * &#x60;ROUTING_BLOCK_INTERSECTING_ROADS_TOO_MANY_SEGMENTS&#x60; - The maximum number of road segments intersecting one polyline must not exceed 5000.  **Error codes for** &#x60;ROUTING_RESTRICTION_EXCEEDED&#x60;  * &#x60;ROUTING_TOO_MANY_WAYPOINTS&#x60; - The request contains too many waypoints.   * &#x60;limit&#x60;- The maximum allowed number of waypoints for a single request (integer).  **Error codes for** &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60;  * &#x60;GENERAL_INVALID_ID&#x60; - The ID does not exist.   * &#x60;value&#x60; - The invalid ID.
        /// </summary>
        /// <value>A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **Error codes for** &#x60;GENERAL_VALIDATION_ERROR&#x60;  * &#x60;GENERAL_INVALID_VALUE&#x60; - A parameter is set to an invalid value.   * &#x60;value&#x60; - The invalid value. * &#x60;GENERAL_UNRECOGNIZED_PARAMETER&#x60; - A parameter is unknown. * &#x60;GENERAL_MISSING_PARAMETER&#x60; - A required parameter is missing. * &#x60;GENERAL_MINIMUM_LENGTH_VIOLATED&#x60; - The minimum length is violated.   * &#x60;minimumLength&#x60; - The minimum length (integer). * &#x60;GENERAL_MAXIMUM_LENGTH_VIOLATED&#x60; - The maximum length is violated.   * &#x60;maximumLength&#x60; - The maximum length (integer). * &#x60;GENERAL_MINIMUM_VALUE_VIOLATED&#x60; - The minimum value restriction is violated.   * &#x60;minimumValue&#x60; - The minimum value (integer or double). * &#x60;GENERAL_MAXIMUM_VALUE_VIOLATED&#x60; - The maximum value restriction is violated.   * &#x60;maximumValue&#x60; - The maximum value (integer or double). * &#x60;GENERAL_DUPLICATE_PARAMETER&#x60; - A parameter is duplicated. * &#x60;GENERAL_INVALID_LIST&#x60; - A list has an invalid format such as duplicate commas.   * &#x60;value&#x60; - The invalid list. * &#x60;GENERAL_INVALID_INTERVAL&#x60; - A time interval is invalid, i.e. start is greater than end. * &#x60;ROUTING_INVALID_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is set to an invalid value.   * &#x60;attribute&#x60; - The invalid waypoint attribute. * &#x60;ROUTING_UNRECOGNIZED_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is unknown.   * &#x60;attribute&#x60; - The invalid waypoint key. * &#x60;ROUTING_DUPLICATE_WAYPOINT_ATTRIBUTE&#x60; - A waypoint attribute is duplicated.   * &#x60;attribute&#x60; - The duplicated waypoint key. * &#x60;ROUTING_WAYPOINT_ATTRIBUTE_CONFLICT&#x60; - Two waypoint attributes are in conflict with each other.   * &#x60;attribute&#x60; - The first conflicting attribute.   * &#x60;conflictingAttribute&#x60; - The second conflicting attribute. * &#x60;ROUTING_INVALID_MANIPULATION_WAYPOINT_ORDER&#x60; - The manipulation waypoint is not valid for start or destination. * &#x60;ROUTING_INVALID_COMBINED_TRANSPORT_WAYPOINT_ORDER&#x60; - The combinedTransport waypoint is not valid for start or destination. * &#x60;ROUTING_INVALID_WAYPOINT_LIST_FOR_ALTERNATIVE_ROUTES&#x60; - Alternative routes are supported only for two on-road or off-road waypoints. * &#x60;ROUTING_INVALID_WAYPOINT&#x60; - A waypoint contains multiple types or none of them, but exactly one must be specified. * &#x60;ROUTING_MUST_HAVE_WAYPOINTS_OR_ROUTE_ID&#x60; - The request must have either at least two **waypoints** or a **routeId**. * &#x60;ROUTING_EMISSIONS_MUTUALLY_EXCLUSIVE&#x60; - All emissions _EN16258_2012_ results and _ISO14083_2022_ or _ISO14083_2023_ results are mutually exclusive.   * &#x60;attribute&#x60; - The first conflicting emissions standard.   * &#x60;conflictingAttributes&#x60; - The list of other conflicting emissions standards. * &#x60;ROUTING_START_AND_ARRIVAL_TIME_MUTUALLY_EXCLUSIVE&#x60; - **options[startTime]** and **options[arrivalTime]** are mutually exclusive. - _The **parameter** remains empty._ * &#x60;ROUTING_ESTIMATED_DISTANCE_TOO_LONG&#x60; - The distance of the route (estimated by air-line) for non-motorized vehicles is too long. - _The **parameter** remains empty._   * &#x60;distance&#x60; - The estimated distance (integer).   * &#x60;limit&#x60; - The maximum allowable distance (integer). * &#x60;ROUTING_PARAMETER_CONFLICT&#x60; - Two parameters are in conflict with each other.   * &#x60;conflictingParameter&#x60; - The conflicting parameter.   * &#x60;message&#x60; - The error message. * &#x60;ROUTING_NO_VALID_COUNTRY_ALLOWED&#x60; - The list of allowed countries does not contain any of the available countries so that the effective list of countries allowed for routing is empty.   * &#x60;allowedCountries&#x60; - The list of allowed countries. * &#x60;ROUTING_ALL_VALID_COUNTRIES_PROHIBITED&#x60; - The list of prohibited countries contains all available countries so that the effective list of countries allowed for routing is empty.   * &#x60;prohibitedCountries&#x60; - The list of prohibited countries. * &#x60;ROUTING_ALLOWED_AND_PROHIBITED_COUNTRIES_CONFLICT&#x60; - The lists of allowed and prohibited countries contain the same countries so that the effective list of countries allowed for routing is empty. - _The **parameter** remains empty._   * &#x60;allowedCountries&#x60; - The list of allowed countries.   * &#x60;prohibitedCountries&#x60; - The list of prohibited countries. * &#x60;ROUTING_MAXIMUM_HORIZON_VALUE_VIOLATED&#x60; - The maximum value of horizon is violated.   * &#x60;limit&#x60; - The maximum allowable horizon (integer). * &#x60;ROUTING_MUST_HAVE_ONE_WAYPOINT_OR_ROUTE_ID&#x60; - The request must have either a **waypoint** or a **routeId**. * &#x60;ROUTING_HORIZONS_EQUAL_OR_NOT_ASCENDING&#x60; - The horizons have equal values or are not ascending.   * &#x60;value&#x60; - The invalid horizon. * &#x60;ROUTING_ROUTE_TOO_LONG_FOR_REACHABILITY&#x60; - The route is too long to be used with reachable areas or locations.   * &#x60;length&#x60; - The actual route length (integer).   * &#x60;limit&#x60; - The maximum allowable route length (integer). * &#x60;ROUTING_ALLOWED_AND_PROHIBITED_COUNTRIES_IN_CONFLICT_WITH_ROUTE_ID&#x60; - The lists of allowed and prohibited countries are in conflict with the **routeId** which passes an effectively prohibited country.   * &#x60;value&#x60; - The value in conflict. * &#x60;ROUTING_ROUTE_ID_NOT_FOUND&#x60; - The **routeId** cannot be found.   * &#x60;value&#x60; - The routeId. * &#x60;ROUTING_ROUTE_ID_CANNOT_BE_USED&#x60; - The **routeId** cannot be used for this operation as it was created by a service other than routing and lacks a routing context.   * &#x60;value&#x60; - The routeId. * &#x60;ROUTING_PROFILE_NOT_FOUND&#x60; - The requested **profile** could not be found.   * &#x60;value&#x60; - The profile name. * &#x60;ROUTING_UNSUPPORTED_CURRENCY&#x60; - The specified currency is not supported.   * &#x60;currency&#x60; - The unsupported currency. * &#x60;ROUTING_PARAMETER_ONLY_SUPPORTED_BY_POST&#x60; - A requested parameter is only supported for the appropriate POST operation.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_OPENING_INTERVALS_REQUIRE_TIME&#x60; - When using opening intervals with a waypoint and with **options[trafficMode]** _AVERAGE_ either a start or an arrival time has to be specified. * &#x60;ROUTING_ARRIVAL_TIME_WITH_SCHEDULE&#x60; - **options[arrivalTime]** cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_INVALID_NUMBER_OF_COORDINATES&#x60; - The polyline cannot be parsed because the number of coordinates is not even or less than 4.   * &#x60;value&#x60; - The invalid parameter value.   * &#x60;polylineIndex&#x60; - The index denoting the polyline in which the error was found (integer). * &#x60;ROUTING_INVALID_COORDINATE&#x60; - The provided coordinate is not in the valid range or cannot be parsed.   * &#x60;value&#x60; - The invalid parameter value.   * &#x60;polylineIndex&#x60; - The index denoting the polyline in which the error was found (integer).   * &#x60;coordinateIndex&#x60; - The index denoting the erroneous coordinate within the polyline (integer). * &#x60;ROUTING_FEATURE_NOT_SUPPORTED_WITH_MONETARY_COSTS&#x60; - The requested feature is not supported when **options[routingMode]** is _MONETARY_.   * &#x60;value&#x60; - The invalid parameter value. * &#x60;ROUTING_MUST_HAVE_MONETARY_COST_VALUE&#x60; - Both values **monetaryCostOptions[costPerKilometer]** and **monetaryCostOptions[workingCostPerHour]** are zero. Use a value greater zero for at least one of this **monetaryCostOptions** parameters. * &#x60;ROUTING_CUSTOM_ROAD_ATTRIBUTE_SCENARIO_NOT_FOUND&#x60; - At least one of the requested **options[customRoadAttributeScenarios]** could not be found.   * &#x60;scenarios&#x60; - The scenarios which could not be found (comma-separated list). * &#x60;ROUTING_POSITION_AND_WAYPOINT_MUTUALLY_EXCLUSIVE&#x60; - **position** and **waypoint** are mutually exclusive. - _The **parameter** remains empty._ * &#x60;ROUTING_VEHICLE_POSITION_MISSING&#x60; - The position of the vehicle must be specified by either **position** or **waypoint**. - _The **parameter** remains empty._ * &#x60;ROUTING_UNSUPPORTED_WAYPOINT_TYPE_FOR_ETA_CALCULATION&#x60; - The ETA calculation does not support route-manipulation waypoints, combined-transport waypoints or vehicle parameters at waypoints.   * &#x60;waypointIndex&#x60; - The index of the waypoint (integer). * &#x60;ROUTING_MISSING_WAYPOINT_NAME&#x60; - The requested route for the **routeId** contains a waypoint which does not have a name.   * &#x60;waypointIndex&#x60; - The index of the waypoint (integer). * &#x60;ROUTING_DUPLICATE_WAYPOINT_NAME&#x60; - The requested route for the **routeId** contains waypoints with a duplicate name.   * &#x60;waypointIndexes&#x60; - The indexes of the waypoints with the duplicated name (comma-separated list).   * &#x60;name&#x60; - The duplicate waypoint name. * &#x60;ROUTING_WAYPOINT_NAME_NOT_FOUND&#x60; - The waypoint name could not be found in the requested route for the **routeId**.   * &#x60;name&#x60; - The invalid waypoint name. * &#x60;ROUTING_VEHICLE_POSITION_BEFORE_FIRST_WAYPOINT&#x60; - The position of the vehicle cannot be before the first waypoint. * &#x60;ROUTING_ROUTE_ID_REQUIRES_WORKLOGBOOK&#x60; - The route associated with the given **routeId** has been calculated with a **driver** and requires the **workLogbook** to be specified in the ETA request. * &#x60;ROUTING_ROUTE_ID_DOES_NOT_SUPPORT_WORKLOGBOOK&#x60; - The route associated with the given **routeId** has been calculated without a **driver** and does not support the **workLogbook** specified in the ETA request.  **Error codes for** &#x60;ROUTING_ERROR&#x60;  * &#x60;ROUTING_WAYPOINT_CANNOT_BE_MATCHED&#x60; - The waypoint cannot be matched to the nearest possible road. * &#x60;ROUTING_ROUTE_NOT_FOUND&#x60; - A route between at least two waypoints could not be found for the current configuration and profile. - _The **parameter** remains empty._ * &#x60;ROUTING_TIMEOUT&#x60; - The route calculation has timed out. * &#x60;ROUTING_UTC_OFFSET_CANNOT_BE_DETERMINED&#x60; - The UTC offset of the start waypoint cannot be determined. * &#x60;ROUTING_BLOCK_INTERSECTING_ROADS_TOO_MANY_SEGMENTS&#x60; - The maximum number of road segments intersecting one polyline must not exceed 5000.  **Error codes for** &#x60;ROUTING_RESTRICTION_EXCEEDED&#x60;  * &#x60;ROUTING_TOO_MANY_WAYPOINTS&#x60; - The request contains too many waypoints.   * &#x60;limit&#x60;- The maximum allowed number of waypoints for a single request (integer).  **Error codes for** &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60;  * &#x60;GENERAL_INVALID_ID&#x60; - The ID does not exist.   * &#x60;value&#x60; - The invalid ID.</value>
        [DataMember(Name = "errorCode", IsRequired = true, EmitDefaultValue = true)]
        public string ErrorCode { get; set; }
        /// <summary>
        /// The name of the affected query or path parameter or a JSONPath to the affected property of the request.
        /// </summary>
        /// <value>The name of the affected query or path parameter or a JSONPath to the affected property of the request.</value>
        [DataMember(Name = "parameter", EmitDefaultValue = false)]
        public string VarParameter { get; set; }
        /// <summary>
        /// Additional properties specific to this error class.
        /// </summary>
        /// <value>Additional properties specific to this error class.</value>
        [DataMember(Name = "details", EmitDefaultValue = false)]
        public Dictionary<string, Object> Details { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CausingError {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ErrorCode: ").Append(ErrorCode).Append("\n");
            sb.Append("  VarParameter: ").Append(VarParameter).Append("\n");
            sb.Append("  Details: ").Append(Details).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CausingError);
        }
        /// <summary>
        /// Returns true if CausingError instances are equal
        /// </summary>
        /// <param name="input">Instance of CausingError to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CausingError input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ErrorCode == input.ErrorCode ||
                    (this.ErrorCode != null &&
                    this.ErrorCode.Equals(input.ErrorCode))
                ) && 
                (
                    this.VarParameter == input.VarParameter ||
                    (this.VarParameter != null &&
                    this.VarParameter.Equals(input.VarParameter))
                ) && 
                (
                    this.Details == input.Details ||
                    this.Details != null &&
                    input.Details != null &&
                    this.Details.SequenceEqual(input.Details)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.ErrorCode != null)
                {
                    hashCode = (hashCode * 59) + this.ErrorCode.GetHashCode();
                }
                if (this.VarParameter != null)
                {
                    hashCode = (hashCode * 59) + this.VarParameter.GetHashCode();
                }
                if (this.Details != null)
                {
                    hashCode = (hashCode * 59) + this.Details.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Influences the route course, so that the route uses a ferry or railway connection between the given locations. Both locations will be matched to the nearest ports looking for a direct connection. If no connection can be found, this waypoint will be ignored, and the warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED_ will be returned. If more than one connection is found, the best one will be used, and the alternative connections will be returned in the response in a warning _ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS_. This waypoint will not appear as a waypoint event in the response and may not be used as start or destination. We will refer to this type of waypoint as a _combined-transport waypoint_.
    /// </summary>
    [DataContract(Name = "CombinedTransport")]
    public partial class CombinedTransport : IEquatable<CombinedTransport>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CombinedTransport" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CombinedTransport() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CombinedTransport" /> class.
        /// </summary>
        /// <param name="start">start (required).</param>
        /// <param name="destination">destination (required).</param>
        public CombinedTransport(CombinedTransportLocation start = default(CombinedTransportLocation), CombinedTransportLocation destination = default(CombinedTransportLocation))
        {
            // to ensure "start" is required (not null)
            if (start == null)
            {
                throw new ArgumentNullException("start is a required property for CombinedTransport and cannot be null");
            }
            this.Start = start;
            // to ensure "destination" is required (not null)
            if (destination == null)
            {
                throw new ArgumentNullException("destination is a required property for CombinedTransport and cannot be null");
            }
            this.Destination = destination;
        }
        /// <summary>
        /// Gets or Sets Start
        /// </summary>
        [DataMember(Name = "start", IsRequired = true, EmitDefaultValue = true)]
        public CombinedTransportLocation Start { get; set; }
        /// <summary>
        /// Gets or Sets Destination
        /// </summary>
        [DataMember(Name = "destination", IsRequired = true, EmitDefaultValue = true)]
        public CombinedTransportLocation Destination { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CombinedTransport {\n");
            sb.Append("  Start: ").Append(Start).Append("\n");
            sb.Append("  Destination: ").Append(Destination).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CombinedTransport);
        }
        /// <summary>
        /// Returns true if CombinedTransport instances are equal
        /// </summary>
        /// <param name="input">Instance of CombinedTransport to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CombinedTransport input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Start == input.Start ||
                    (this.Start != null &&
                    this.Start.Equals(input.Start))
                ) && 
                (
                    this.Destination == input.Destination ||
                    (this.Destination != null &&
                    this.Destination.Equals(input.Destination))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Start != null)
                {
                    hashCode = (hashCode * 59) + this.Start.GetHashCode();
                }
                if (this.Destination != null)
                {
                    hashCode = (hashCode * 59) + this.Destination.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when a combined transport is entered or exited. Requires _COMBINED_TRANSPORT_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "CombinedTransportEvent")]
    public partial class CombinedTransportEvent : IEquatable<CombinedTransportEvent>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name = "type", IsRequired = true, EmitDefaultValue = true)]
        public CombinedTransportType Type { get; set; }
        /// <summary>
        /// Gets or Sets AccessType
        /// </summary>
        [DataMember(Name = "accessType", IsRequired = true, EmitDefaultValue = true)]
        public AccessType AccessType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CombinedTransportEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CombinedTransportEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CombinedTransportEvent" /> class.
        /// </summary>
        /// <param name="name">The name of the combined transport. (required).</param>
        /// <param name="type">type (required).</param>
        /// <param name="accessType">accessType (required).</param>
        /// <param name="relatedEventIndex">For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise..</param>
        public CombinedTransportEvent(string name = default(string), CombinedTransportType type = default(CombinedTransportType), AccessType accessType = default(AccessType), int relatedEventIndex = default(int))
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for CombinedTransportEvent and cannot be null");
            }
            this.Name = name;
            this.Type = type;
            this.AccessType = accessType;
            this.RelatedEventIndex = relatedEventIndex;
        }
        /// <summary>
        /// The name of the combined transport.
        /// </summary>
        /// <value>The name of the combined transport.</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }
        /// <summary>
        /// For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.
        /// </summary>
        /// <value>For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.</value>
        [DataMember(Name = "relatedEventIndex", EmitDefaultValue = false)]
        public int RelatedEventIndex { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CombinedTransportEvent {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  AccessType: ").Append(AccessType).Append("\n");
            sb.Append("  RelatedEventIndex: ").Append(RelatedEventIndex).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CombinedTransportEvent);
        }
        /// <summary>
        /// Returns true if CombinedTransportEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of CombinedTransportEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CombinedTransportEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Type == input.Type ||
                    this.Type.Equals(input.Type)
                ) && 
                (
                    this.AccessType == input.AccessType ||
                    this.AccessType.Equals(input.AccessType)
                ) && 
                (
                    this.RelatedEventIndex == input.RelatedEventIndex ||
                    this.RelatedEventIndex.Equals(input.RelatedEventIndex)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Type.GetHashCode();
                hashCode = (hashCode * 59) + this.AccessType.GetHashCode();
                hashCode = (hashCode * 59) + this.RelatedEventIndex.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // RelatedEventIndex (int) minimum
            if (this.RelatedEventIndex < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RelatedEventIndex, must be a value greater than or equal to 0.", new [] { "RelatedEventIndex" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Represents the start or destination location of a combined transport, e.g. the port.
    /// </summary>
    [DataContract(Name = "CombinedTransportLocation")]
    public partial class CombinedTransportLocation : IEquatable<CombinedTransportLocation>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CombinedTransportLocation" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CombinedTransportLocation() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CombinedTransportLocation" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        public CombinedTransportLocation(double latitude = default(double), double longitude = default(double))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CombinedTransportLocation {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CombinedTransportLocation);
        }
        /// <summary>
        /// Returns true if CombinedTransportLocation instances are equal
        /// </summary>
        /// <param name="input">Instance of CombinedTransportLocation to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CombinedTransportLocation input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The type of the combined transport, i.e. how the vehicle is transported.  * &#x60;BOAT&#x60; - The combined transport is by boat, i.e. on a ferry.  * &#x60;RAIL&#x60; - The combined transport is by rail, i.e. on a train or rail shuttle.
    /// </summary>
    /// <value>The type of the combined transport, i.e. how the vehicle is transported.  * &#x60;BOAT&#x60; - The combined transport is by boat, i.e. on a ferry.  * &#x60;RAIL&#x60; - The combined transport is by rail, i.e. on a train or rail shuttle.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum CombinedTransportType
    {
        /// <summary>
        /// Enum BOAT for value: BOAT
        /// </summary>
        [EnumMember(Value = "BOAT")]
        BOAT = 1,
        /// <summary>
        /// Enum RAIL for value: RAIL
        /// </summary>
        [EnumMember(Value = "RAIL")]
        RAIL = 2
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Information about the currencies that are listed in the toll costs and/or toll sections objects.
    /// </summary>
    [DataContract(Name = "Currencies")]
    public partial class Currencies : IEquatable<Currencies>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Currencies" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Currencies() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Currencies" /> class.
        /// </summary>
        /// <param name="date">The date of the exchange rates formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). (required).</param>
        /// <param name="provider">The provider of the exchange rates. (required).</param>
        /// <param name="baseCurrency">The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code as provided in the request. (required).</param>
        /// <param name="exchangeRates">The exchange rates that were used to determine the converted prices. (required).</param>
        public Currencies(DateTime date = default(DateTime), string provider = default(string), string baseCurrency = default(string), List<ExchangeRate> exchangeRates = default(List<ExchangeRate>))
        {
            this.Date = date;
            // to ensure "provider" is required (not null)
            if (provider == null)
            {
                throw new ArgumentNullException("provider is a required property for Currencies and cannot be null");
            }
            this.Provider = provider;
            // to ensure "baseCurrency" is required (not null)
            if (baseCurrency == null)
            {
                throw new ArgumentNullException("baseCurrency is a required property for Currencies and cannot be null");
            }
            this.BaseCurrency = baseCurrency;
            // to ensure "exchangeRates" is required (not null)
            if (exchangeRates == null)
            {
                throw new ArgumentNullException("exchangeRates is a required property for Currencies and cannot be null");
            }
            this.ExchangeRates = exchangeRates;
        }
        /// <summary>
        /// The date of the exchange rates formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
        /// </summary>
        /// <value>The date of the exchange rates formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).</value>
        [DataMember(Name = "date", IsRequired = true, EmitDefaultValue = true)]
        [JsonConverter(typeof(OpenAPIDateConverter))]
        public DateTime Date { get; set; }
        /// <summary>
        /// The provider of the exchange rates.
        /// </summary>
        /// <value>The provider of the exchange rates.</value>
        [DataMember(Name = "provider", IsRequired = true, EmitDefaultValue = true)]
        public string Provider { get; set; }
        /// <summary>
        /// The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code as provided in the request.
        /// </summary>
        /// <value>The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code as provided in the request.</value>
        [DataMember(Name = "baseCurrency", IsRequired = true, EmitDefaultValue = true)]
        public string BaseCurrency { get; set; }
        /// <summary>
        /// The exchange rates that were used to determine the converted prices.
        /// </summary>
        /// <value>The exchange rates that were used to determine the converted prices.</value>
        [DataMember(Name = "exchangeRates", IsRequired = true, EmitDefaultValue = true)]
        public List<ExchangeRate> ExchangeRates { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Currencies {\n");
            sb.Append("  Date: ").Append(Date).Append("\n");
            sb.Append("  Provider: ").Append(Provider).Append("\n");
            sb.Append("  BaseCurrency: ").Append(BaseCurrency).Append("\n");
            sb.Append("  ExchangeRates: ").Append(ExchangeRates).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Currencies);
        }
        /// <summary>
        /// Returns true if Currencies instances are equal
        /// </summary>
        /// <param name="input">Instance of Currencies to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Currencies input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Date == input.Date ||
                    (this.Date != null &&
                    this.Date.Equals(input.Date))
                ) && 
                (
                    this.Provider == input.Provider ||
                    (this.Provider != null &&
                    this.Provider.Equals(input.Provider))
                ) && 
                (
                    this.BaseCurrency == input.BaseCurrency ||
                    (this.BaseCurrency != null &&
                    this.BaseCurrency.Equals(input.BaseCurrency))
                ) && 
                (
                    this.ExchangeRates == input.ExchangeRates ||
                    this.ExchangeRates != null &&
                    input.ExchangeRates != null &&
                    this.ExchangeRates.SequenceEqual(input.ExchangeRates)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Date != null)
                {
                    hashCode = (hashCode * 59) + this.Date.GetHashCode();
                }
                if (this.Provider != null)
                {
                    hashCode = (hashCode * 59) + this.Provider.GetHashCode();
                }
                if (this.BaseCurrency != null)
                {
                    hashCode = (hashCode * 59) + this.BaseCurrency.GetHashCode();
                }
                if (this.ExchangeRates != null)
                {
                    hashCode = (hashCode * 59) + this.ExchangeRates.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.BaseCurrency != null) {
                // BaseCurrency (string) pattern
                Regex regexBaseCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
                if (!regexBaseCurrency.Match(this.BaseCurrency).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for BaseCurrency, must match a pattern of " + regexBaseCurrency, new [] { "BaseCurrency" });
                }
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Driver
    /// </summary>
    [DataContract(Name = "Driver")]
    public partial class Driver : IEquatable<Driver>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets WorkingHoursPreset
        /// </summary>
        [DataMember(Name = "workingHoursPreset", IsRequired = true, EmitDefaultValue = true)]
        public WorkingHoursPreset WorkingHoursPreset { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Driver" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Driver() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Driver" /> class.
        /// </summary>
        /// <param name="workingHoursPreset">workingHoursPreset (required).</param>
        public Driver(WorkingHoursPreset workingHoursPreset = default(WorkingHoursPreset))
        {
            this.WorkingHoursPreset = workingHoursPreset;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Driver {\n");
            sb.Append("  WorkingHoursPreset: ").Append(WorkingHoursPreset).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Driver);
        }
        /// <summary>
        /// Returns true if Driver instances are equal
        /// </summary>
        /// <param name="input">Instance of Driver to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Driver input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.WorkingHoursPreset == input.WorkingHoursPreset ||
                    this.WorkingHoursPreset.Equals(input.WorkingHoursPreset)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.WorkingHoursPreset.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// DriverBody
    /// </summary>
    [DataContract(Name = "DriverBody")]
    public partial class DriverBody : IEquatable<DriverBody>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets WorkingHoursPreset
        /// </summary>
        [DataMember(Name = "workingHoursPreset", IsRequired = true, EmitDefaultValue = true)]
        public WorkingHoursPreset WorkingHoursPreset { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="DriverBody" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected DriverBody() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DriverBody" /> class.
        /// </summary>
        /// <param name="workingHoursPreset">workingHoursPreset (required).</param>
        /// <param name="workLogbook">workLogbook.</param>
        public DriverBody(WorkingHoursPreset workingHoursPreset = default(WorkingHoursPreset), WorkLogbook workLogbook = default(WorkLogbook))
        {
            this.WorkingHoursPreset = workingHoursPreset;
            this.WorkLogbook = workLogbook;
        }
        /// <summary>
        /// Gets or Sets WorkLogbook
        /// </summary>
        [DataMember(Name = "workLogbook", EmitDefaultValue = false)]
        public WorkLogbook WorkLogbook { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DriverBody {\n");
            sb.Append("  WorkingHoursPreset: ").Append(WorkingHoursPreset).Append("\n");
            sb.Append("  WorkLogbook: ").Append(WorkLogbook).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DriverBody);
        }
        /// <summary>
        /// Returns true if DriverBody instances are equal
        /// </summary>
        /// <param name="input">Instance of DriverBody to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DriverBody input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.WorkingHoursPreset == input.WorkingHoursPreset ||
                    this.WorkingHoursPreset.Equals(input.WorkingHoursPreset)
                ) && 
                (
                    this.WorkLogbook == input.WorkLogbook ||
                    (this.WorkLogbook != null &&
                    this.WorkLogbook.Equals(input.WorkLogbook))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.WorkingHoursPreset.GetHashCode();
                if (this.WorkLogbook != null)
                {
                    hashCode = (hashCode * 59) + this.WorkLogbook.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Specifies the driving direction, i.e. from start to destination or from destination to start..  * &#x60;OUTBOUND&#x60; - Indicates an outbound routing from start to destination, i.e. the area which can be reached from the location within the given horizon. Use this value to calculate which can be covered e.g. by an emergency service such as a fire department.  * &#x60;INBOUND&#x60; - Indicates an inbound routing from destination to start, i.e. from where the location can be reached within the given horizon. Use this value to calculate the catchment area, e.g. of a school or a hospital.
    /// </summary>
    /// <value>Specifies the driving direction, i.e. from start to destination or from destination to start..  * &#x60;OUTBOUND&#x60; - Indicates an outbound routing from start to destination, i.e. the area which can be reached from the location within the given horizon. Use this value to calculate which can be covered e.g. by an emergency service such as a fire department.  * &#x60;INBOUND&#x60; - Indicates an inbound routing from destination to start, i.e. from where the location can be reached within the given horizon. Use this value to calculate the catchment area, e.g. of a school or a hospital.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum DrivingDirection
    {
        /// <summary>
        /// Enum OUTBOUND for value: OUTBOUND
        /// </summary>
        [EnumMember(Value = "OUTBOUND")]
        OUTBOUND = 1,
        /// <summary>
        /// Enum INBOUND for value: INBOUND
        /// </summary>
        [EnumMember(Value = "INBOUND")]
        INBOUND = 2
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The electricity type of the vehicle.  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. 
    /// </summary>
    /// <value>The electricity type of the vehicle.  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ElectricityType
    {
        /// <summary>
        /// Enum BATTERY for value: BATTERY
        /// </summary>
        [EnumMember(Value = "BATTERY")]
        BATTERY = 1,
        /// <summary>
        /// Enum HYDROGEN_FUEL_CELL for value: HYDROGEN_FUEL_CELL
        /// </summary>
        [EnumMember(Value = "HYDROGEN_FUEL_CELL")]
        HYDROGEN_FUEL_CELL = 2,
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Emissions such as the CO2-equivalent (CO2e) according to the selected standards.  The CO2e value is the unit for comparing the radiative forcing of a greenhouse gas to carbon dioxide according to [ISO 14064-1:2006](https://en.wikipedia.org/wiki/ISO_14064).
    /// </summary>
    [DataContract(Name = "Emissions")]
    public partial class Emissions : IEquatable<Emissions>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Emissions" /> class.
        /// </summary>
        /// <param name="en162582012">en162582012.</param>
        /// <param name="iso140832022">iso140832022.</param>
        /// <param name="iso140832023">iso140832023.</param>
        /// <param name="frenchCO2eDecree2017639">frenchCO2eDecree2017639.</param>
        public Emissions(EmissionsEN162582012 en162582012 = default(EmissionsEN162582012), EmissionsISO140832022 iso140832022 = default(EmissionsISO140832022), EmissionsISO140832023 iso140832023 = default(EmissionsISO140832023), EmissionsFrenchCO2eDecree2017639 frenchCO2eDecree2017639 = default(EmissionsFrenchCO2eDecree2017639))
        {
            this.En162582012 = en162582012;
            this.Iso140832022 = iso140832022;
            this.Iso140832023 = iso140832023;
            this.FrenchCO2eDecree2017639 = frenchCO2eDecree2017639;
        }
        /// <summary>
        /// Gets or Sets En162582012
        /// </summary>
        [DataMember(Name = "en16258_2012", EmitDefaultValue = false)]
        public EmissionsEN162582012 En162582012 { get; set; }
        /// <summary>
        /// Gets or Sets Iso140832022
        /// </summary>
        [DataMember(Name = "iso14083_2022", EmitDefaultValue = false)]
        public EmissionsISO140832022 Iso140832022 { get; set; }
        /// <summary>
        /// Gets or Sets Iso140832023
        /// </summary>
        [DataMember(Name = "iso14083_2023", EmitDefaultValue = false)]
        public EmissionsISO140832023 Iso140832023 { get; set; }
        /// <summary>
        /// Gets or Sets FrenchCO2eDecree2017639
        /// </summary>
        [DataMember(Name = "frenchCO2eDecree2017_639", EmitDefaultValue = false)]
        public EmissionsFrenchCO2eDecree2017639 FrenchCO2eDecree2017639 { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Emissions {\n");
            sb.Append("  En162582012: ").Append(En162582012).Append("\n");
            sb.Append("  Iso140832022: ").Append(Iso140832022).Append("\n");
            sb.Append("  Iso140832023: ").Append(Iso140832023).Append("\n");
            sb.Append("  FrenchCO2eDecree2017639: ").Append(FrenchCO2eDecree2017639).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Emissions);
        }
        /// <summary>
        /// Returns true if Emissions instances are equal
        /// </summary>
        /// <param name="input">Instance of Emissions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Emissions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.En162582012 == input.En162582012 ||
                    (this.En162582012 != null &&
                    this.En162582012.Equals(input.En162582012))
                ) && 
                (
                    this.Iso140832022 == input.Iso140832022 ||
                    (this.Iso140832022 != null &&
                    this.Iso140832022.Equals(input.Iso140832022))
                ) && 
                (
                    this.Iso140832023 == input.Iso140832023 ||
                    (this.Iso140832023 != null &&
                    this.Iso140832023.Equals(input.Iso140832023))
                ) && 
                (
                    this.FrenchCO2eDecree2017639 == input.FrenchCO2eDecree2017639 ||
                    (this.FrenchCO2eDecree2017639 != null &&
                    this.FrenchCO2eDecree2017639.Equals(input.FrenchCO2eDecree2017639))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.En162582012 != null)
                {
                    hashCode = (hashCode * 59) + this.En162582012.GetHashCode();
                }
                if (this.Iso140832022 != null)
                {
                    hashCode = (hashCode * 59) + this.Iso140832022.GetHashCode();
                }
                if (this.Iso140832023 != null)
                {
                    hashCode = (hashCode * 59) + this.Iso140832023.GetHashCode();
                }
                if (this.FrenchCO2eDecree2017639 != null)
                {
                    hashCode = (hashCode * 59) + this.FrenchCO2eDecree2017639.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Emissions according to EN16258 from 2012 (a.k.a. CEN standard).
    /// </summary>
    [DataContract(Name = "Emissions_EN16258_2012")]
    public partial class EmissionsEN162582012 : IEquatable<EmissionsEN162582012>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsEN162582012" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EmissionsEN162582012() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsEN162582012" /> class.
        /// </summary>
        /// <param name="fuelConsumption">The total fuel consumption [kg]. (required).</param>
        /// <param name="co2eTankToWheel">The amount of emitted CO2e from tank to wheel [kg]. (required).</param>
        /// <param name="co2eWellToWheel">The amount of emitted CO2e from well to wheel [kg]. (required).</param>
        /// <param name="energyUseTankToWheel">The tank-to-wheel energy use [MJ]. (required).</param>
        /// <param name="energyUseWellToWheel">The well-to-wheel energy use [MJ]. (required).</param>
        public EmissionsEN162582012(double fuelConsumption = default(double), double co2eTankToWheel = default(double), double co2eWellToWheel = default(double), double energyUseTankToWheel = default(double), double energyUseWellToWheel = default(double))
        {
            this.FuelConsumption = fuelConsumption;
            this.Co2eTankToWheel = co2eTankToWheel;
            this.Co2eWellToWheel = co2eWellToWheel;
            this.EnergyUseTankToWheel = energyUseTankToWheel;
            this.EnergyUseWellToWheel = energyUseWellToWheel;
        }
        /// <summary>
        /// The total fuel consumption [kg].
        /// </summary>
        /// <value>The total fuel consumption [kg].</value>
        [DataMember(Name = "fuelConsumption", IsRequired = true, EmitDefaultValue = true)]
        public double FuelConsumption { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from tank to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from tank to wheel [kg].</value>
        [DataMember(Name = "co2eTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eTankToWheel { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from well to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from well to wheel [kg].</value>
        [DataMember(Name = "co2eWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eWellToWheel { get; set; }
        /// <summary>
        /// The tank-to-wheel energy use [MJ].
        /// </summary>
        /// <value>The tank-to-wheel energy use [MJ].</value>
        [DataMember(Name = "energyUseTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyUseTankToWheel { get; set; }
        /// <summary>
        /// The well-to-wheel energy use [MJ].
        /// </summary>
        /// <value>The well-to-wheel energy use [MJ].</value>
        [DataMember(Name = "energyUseWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyUseWellToWheel { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EmissionsEN162582012 {\n");
            sb.Append("  FuelConsumption: ").Append(FuelConsumption).Append("\n");
            sb.Append("  Co2eTankToWheel: ").Append(Co2eTankToWheel).Append("\n");
            sb.Append("  Co2eWellToWheel: ").Append(Co2eWellToWheel).Append("\n");
            sb.Append("  EnergyUseTankToWheel: ").Append(EnergyUseTankToWheel).Append("\n");
            sb.Append("  EnergyUseWellToWheel: ").Append(EnergyUseWellToWheel).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EmissionsEN162582012);
        }
        /// <summary>
        /// Returns true if EmissionsEN162582012 instances are equal
        /// </summary>
        /// <param name="input">Instance of EmissionsEN162582012 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EmissionsEN162582012 input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.FuelConsumption == input.FuelConsumption ||
                    this.FuelConsumption.Equals(input.FuelConsumption)
                ) && 
                (
                    this.Co2eTankToWheel == input.Co2eTankToWheel ||
                    this.Co2eTankToWheel.Equals(input.Co2eTankToWheel)
                ) && 
                (
                    this.Co2eWellToWheel == input.Co2eWellToWheel ||
                    this.Co2eWellToWheel.Equals(input.Co2eWellToWheel)
                ) && 
                (
                    this.EnergyUseTankToWheel == input.EnergyUseTankToWheel ||
                    this.EnergyUseTankToWheel.Equals(input.EnergyUseTankToWheel)
                ) && 
                (
                    this.EnergyUseWellToWheel == input.EnergyUseWellToWheel ||
                    this.EnergyUseWellToWheel.Equals(input.EnergyUseWellToWheel)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.FuelConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eTankToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eWellToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyUseTankToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyUseWellToWheel.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // FuelConsumption (double) minimum
            if (this.FuelConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FuelConsumption, must be a value greater than or equal to 0.", new [] { "FuelConsumption" });
            }
            // Co2eTankToWheel (double) minimum
            if (this.Co2eTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eTankToWheel, must be a value greater than or equal to 0.", new [] { "Co2eTankToWheel" });
            }
            // Co2eWellToWheel (double) minimum
            if (this.Co2eWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eWellToWheel, must be a value greater than or equal to 0.", new [] { "Co2eWellToWheel" });
            }
            // EnergyUseTankToWheel (double) minimum
            if (this.EnergyUseTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyUseTankToWheel, must be a value greater than or equal to 0.", new [] { "EnergyUseTankToWheel" });
            }
            // EnergyUseWellToWheel (double) minimum
            if (this.EnergyUseWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyUseWellToWheel, must be a value greater than or equal to 0.", new [] { "EnergyUseWellToWheel" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Emissions according to the French CO2E decree from 2017.
    /// </summary>
    [DataContract(Name = "Emissions_French_CO2e_Decree_2017_639")]
    public partial class EmissionsFrenchCO2eDecree2017639 : IEquatable<EmissionsFrenchCO2eDecree2017639>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsFrenchCO2eDecree2017639" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EmissionsFrenchCO2eDecree2017639() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsFrenchCO2eDecree2017639" /> class.
        /// </summary>
        /// <param name="co2eWellToWheel">The amount of emitted CO2e from well to wheel [kg]. (required).</param>
        /// <param name="co2eTankToWheel">The amount of emitted CO2e from tank to wheel [kg]. (required).</param>
        public EmissionsFrenchCO2eDecree2017639(double co2eWellToWheel = default(double), double co2eTankToWheel = default(double))
        {
            this.Co2eWellToWheel = co2eWellToWheel;
            this.Co2eTankToWheel = co2eTankToWheel;
        }
        /// <summary>
        /// The amount of emitted CO2e from well to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from well to wheel [kg].</value>
        [DataMember(Name = "co2eWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eWellToWheel { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from tank to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from tank to wheel [kg].</value>
        [DataMember(Name = "co2eTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eTankToWheel { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EmissionsFrenchCO2eDecree2017639 {\n");
            sb.Append("  Co2eWellToWheel: ").Append(Co2eWellToWheel).Append("\n");
            sb.Append("  Co2eTankToWheel: ").Append(Co2eTankToWheel).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EmissionsFrenchCO2eDecree2017639);
        }
        /// <summary>
        /// Returns true if EmissionsFrenchCO2eDecree2017639 instances are equal
        /// </summary>
        /// <param name="input">Instance of EmissionsFrenchCO2eDecree2017639 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EmissionsFrenchCO2eDecree2017639 input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Co2eWellToWheel == input.Co2eWellToWheel ||
                    this.Co2eWellToWheel.Equals(input.Co2eWellToWheel)
                ) && 
                (
                    this.Co2eTankToWheel == input.Co2eTankToWheel ||
                    this.Co2eTankToWheel.Equals(input.Co2eTankToWheel)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Co2eWellToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eTankToWheel.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Co2eWellToWheel (double) minimum
            if (this.Co2eWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eWellToWheel, must be a value greater than or equal to 0.", new [] { "Co2eWellToWheel" });
            }
            // Co2eTankToWheel (double) minimum
            if (this.Co2eTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eTankToWheel, must be a value greater than or equal to 0.", new [] { "Co2eTankToWheel" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Emissions according to the draft version of ISO 14083:2023.
    /// </summary>
    [DataContract(Name = "Emissions_ISO14083_2022")]
    public partial class EmissionsISO140832022 : IEquatable<EmissionsISO140832022>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsISO140832022" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EmissionsISO140832022() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsISO140832022" /> class.
        /// </summary>
        /// <param name="fuelConsumption">The total conventional fuel consumption [kg]. (required).</param>
        /// <param name="electricityConsumption">The total electric power consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh]. (required).</param>
        /// <param name="co2eTankToWheel">The amount of emitted CO2e from tank to wheel [kg]. (required).</param>
        /// <param name="co2eWellToWheel">The amount of emitted CO2e from well to wheel [kg]. (required).</param>
        /// <param name="energyUseTankToWheel">The tank-to-wheel energy use [MJ]. (required).</param>
        /// <param name="energyUseWellToWheel">The well-to-wheel energy use [MJ]. (required).</param>
        public EmissionsISO140832022(double fuelConsumption = default(double), double electricityConsumption = default(double), double co2eTankToWheel = default(double), double co2eWellToWheel = default(double), double energyUseTankToWheel = default(double), double energyUseWellToWheel = default(double))
        {
            this.FuelConsumption = fuelConsumption;
            this.ElectricityConsumption = electricityConsumption;
            this.Co2eTankToWheel = co2eTankToWheel;
            this.Co2eWellToWheel = co2eWellToWheel;
            this.EnergyUseTankToWheel = energyUseTankToWheel;
            this.EnergyUseWellToWheel = energyUseWellToWheel;
        }
        /// <summary>
        /// The total conventional fuel consumption [kg].
        /// </summary>
        /// <value>The total conventional fuel consumption [kg].</value>
        [DataMember(Name = "fuelConsumption", IsRequired = true, EmitDefaultValue = true)]
        public double FuelConsumption { get; set; }
        /// <summary>
        /// The total electric power consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh].
        /// </summary>
        /// <value>The total electric power consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh].</value>
        [DataMember(Name = "electricityConsumption", IsRequired = true, EmitDefaultValue = true)]
        public double ElectricityConsumption { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from tank to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from tank to wheel [kg].</value>
        [DataMember(Name = "co2eTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eTankToWheel { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from well to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from well to wheel [kg].</value>
        [DataMember(Name = "co2eWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eWellToWheel { get; set; }
        /// <summary>
        /// The tank-to-wheel energy use [MJ].
        /// </summary>
        /// <value>The tank-to-wheel energy use [MJ].</value>
        [DataMember(Name = "energyUseTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyUseTankToWheel { get; set; }
        /// <summary>
        /// The well-to-wheel energy use [MJ].
        /// </summary>
        /// <value>The well-to-wheel energy use [MJ].</value>
        [DataMember(Name = "energyUseWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyUseWellToWheel { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EmissionsISO140832022 {\n");
            sb.Append("  FuelConsumption: ").Append(FuelConsumption).Append("\n");
            sb.Append("  ElectricityConsumption: ").Append(ElectricityConsumption).Append("\n");
            sb.Append("  Co2eTankToWheel: ").Append(Co2eTankToWheel).Append("\n");
            sb.Append("  Co2eWellToWheel: ").Append(Co2eWellToWheel).Append("\n");
            sb.Append("  EnergyUseTankToWheel: ").Append(EnergyUseTankToWheel).Append("\n");
            sb.Append("  EnergyUseWellToWheel: ").Append(EnergyUseWellToWheel).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EmissionsISO140832022);
        }
        /// <summary>
        /// Returns true if EmissionsISO140832022 instances are equal
        /// </summary>
        /// <param name="input">Instance of EmissionsISO140832022 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EmissionsISO140832022 input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.FuelConsumption == input.FuelConsumption ||
                    this.FuelConsumption.Equals(input.FuelConsumption)
                ) && 
                (
                    this.ElectricityConsumption == input.ElectricityConsumption ||
                    this.ElectricityConsumption.Equals(input.ElectricityConsumption)
                ) && 
                (
                    this.Co2eTankToWheel == input.Co2eTankToWheel ||
                    this.Co2eTankToWheel.Equals(input.Co2eTankToWheel)
                ) && 
                (
                    this.Co2eWellToWheel == input.Co2eWellToWheel ||
                    this.Co2eWellToWheel.Equals(input.Co2eWellToWheel)
                ) && 
                (
                    this.EnergyUseTankToWheel == input.EnergyUseTankToWheel ||
                    this.EnergyUseTankToWheel.Equals(input.EnergyUseTankToWheel)
                ) && 
                (
                    this.EnergyUseWellToWheel == input.EnergyUseWellToWheel ||
                    this.EnergyUseWellToWheel.Equals(input.EnergyUseWellToWheel)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.FuelConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.ElectricityConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eTankToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eWellToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyUseTankToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyUseWellToWheel.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // FuelConsumption (double) minimum
            if (this.FuelConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FuelConsumption, must be a value greater than or equal to 0.", new [] { "FuelConsumption" });
            }
            // ElectricityConsumption (double) minimum
            if (this.ElectricityConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ElectricityConsumption, must be a value greater than or equal to 0.", new [] { "ElectricityConsumption" });
            }
            // Co2eTankToWheel (double) minimum
            if (this.Co2eTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eTankToWheel, must be a value greater than or equal to 0.", new [] { "Co2eTankToWheel" });
            }
            // Co2eWellToWheel (double) minimum
            if (this.Co2eWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eWellToWheel, must be a value greater than or equal to 0.", new [] { "Co2eWellToWheel" });
            }
            // EnergyUseTankToWheel (double) minimum
            if (this.EnergyUseTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyUseTankToWheel, must be a value greater than or equal to 0.", new [] { "EnergyUseTankToWheel" });
            }
            // EnergyUseWellToWheel (double) minimum
            if (this.EnergyUseWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyUseWellToWheel, must be a value greater than or equal to 0.", new [] { "EnergyUseWellToWheel" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Emissions according to ISO 14083:2023 (a.k.a. ISO standard).
    /// </summary>
    [DataContract(Name = "Emissions_ISO14083_2023")]
    public partial class EmissionsISO140832023 : IEquatable<EmissionsISO140832023>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsISO140832023" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EmissionsISO140832023() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EmissionsISO140832023" /> class.
        /// </summary>
        /// <param name="fuelConsumption">The total conventional fuel consumption [kg]. (required).</param>
        /// <param name="electricityConsumption">The total electric power consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh]. (required).</param>
        /// <param name="co2eTankToWheel">The amount of emitted CO2e from tank to wheel [kg]. (required).</param>
        /// <param name="co2eWellToWheel">The amount of emitted CO2e from well to wheel [kg]. (required).</param>
        /// <param name="energyUseTankToWheel">The tank-to-wheel energy use [MJ]. (required).</param>
        /// <param name="energyUseWellToWheel">The well-to-wheel energy use [MJ]. (required).</param>
        public EmissionsISO140832023(double fuelConsumption = default(double), double electricityConsumption = default(double), double co2eTankToWheel = default(double), double co2eWellToWheel = default(double), double energyUseTankToWheel = default(double), double energyUseWellToWheel = default(double))
        {
            this.FuelConsumption = fuelConsumption;
            this.ElectricityConsumption = electricityConsumption;
            this.Co2eTankToWheel = co2eTankToWheel;
            this.Co2eWellToWheel = co2eWellToWheel;
            this.EnergyUseTankToWheel = energyUseTankToWheel;
            this.EnergyUseWellToWheel = energyUseWellToWheel;
        }
        /// <summary>
        /// The total conventional fuel consumption [kg].
        /// </summary>
        /// <value>The total conventional fuel consumption [kg].</value>
        [DataMember(Name = "fuelConsumption", IsRequired = true, EmitDefaultValue = true)]
        public double FuelConsumption { get; set; }
        /// <summary>
        /// The total electric power consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh].
        /// </summary>
        /// <value>The total electric power consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh].</value>
        [DataMember(Name = "electricityConsumption", IsRequired = true, EmitDefaultValue = true)]
        public double ElectricityConsumption { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from tank to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from tank to wheel [kg].</value>
        [DataMember(Name = "co2eTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eTankToWheel { get; set; }
        /// <summary>
        /// The amount of emitted CO2e from well to wheel [kg].
        /// </summary>
        /// <value>The amount of emitted CO2e from well to wheel [kg].</value>
        [DataMember(Name = "co2eWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double Co2eWellToWheel { get; set; }
        /// <summary>
        /// The tank-to-wheel energy use [MJ].
        /// </summary>
        /// <value>The tank-to-wheel energy use [MJ].</value>
        [DataMember(Name = "energyUseTankToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyUseTankToWheel { get; set; }
        /// <summary>
        /// The well-to-wheel energy use [MJ].
        /// </summary>
        /// <value>The well-to-wheel energy use [MJ].</value>
        [DataMember(Name = "energyUseWellToWheel", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyUseWellToWheel { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EmissionsISO140832023 {\n");
            sb.Append("  FuelConsumption: ").Append(FuelConsumption).Append("\n");
            sb.Append("  ElectricityConsumption: ").Append(ElectricityConsumption).Append("\n");
            sb.Append("  Co2eTankToWheel: ").Append(Co2eTankToWheel).Append("\n");
            sb.Append("  Co2eWellToWheel: ").Append(Co2eWellToWheel).Append("\n");
            sb.Append("  EnergyUseTankToWheel: ").Append(EnergyUseTankToWheel).Append("\n");
            sb.Append("  EnergyUseWellToWheel: ").Append(EnergyUseWellToWheel).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EmissionsISO140832023);
        }
        /// <summary>
        /// Returns true if EmissionsISO140832023 instances are equal
        /// </summary>
        /// <param name="input">Instance of EmissionsISO140832023 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EmissionsISO140832023 input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.FuelConsumption == input.FuelConsumption ||
                    this.FuelConsumption.Equals(input.FuelConsumption)
                ) && 
                (
                    this.ElectricityConsumption == input.ElectricityConsumption ||
                    this.ElectricityConsumption.Equals(input.ElectricityConsumption)
                ) && 
                (
                    this.Co2eTankToWheel == input.Co2eTankToWheel ||
                    this.Co2eTankToWheel.Equals(input.Co2eTankToWheel)
                ) && 
                (
                    this.Co2eWellToWheel == input.Co2eWellToWheel ||
                    this.Co2eWellToWheel.Equals(input.Co2eWellToWheel)
                ) && 
                (
                    this.EnergyUseTankToWheel == input.EnergyUseTankToWheel ||
                    this.EnergyUseTankToWheel.Equals(input.EnergyUseTankToWheel)
                ) && 
                (
                    this.EnergyUseWellToWheel == input.EnergyUseWellToWheel ||
                    this.EnergyUseWellToWheel.Equals(input.EnergyUseWellToWheel)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.FuelConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.ElectricityConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eTankToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.Co2eWellToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyUseTankToWheel.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyUseWellToWheel.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // FuelConsumption (double) minimum
            if (this.FuelConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FuelConsumption, must be a value greater than or equal to 0.", new [] { "FuelConsumption" });
            }
            // ElectricityConsumption (double) minimum
            if (this.ElectricityConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ElectricityConsumption, must be a value greater than or equal to 0.", new [] { "ElectricityConsumption" });
            }
            // Co2eTankToWheel (double) minimum
            if (this.Co2eTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eTankToWheel, must be a value greater than or equal to 0.", new [] { "Co2eTankToWheel" });
            }
            // Co2eWellToWheel (double) minimum
            if (this.Co2eWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2eWellToWheel, must be a value greater than or equal to 0.", new [] { "Co2eWellToWheel" });
            }
            // EnergyUseTankToWheel (double) minimum
            if (this.EnergyUseTankToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyUseTankToWheel, must be a value greater than or equal to 0.", new [] { "EnergyUseTankToWheel" });
            }
            // EnergyUseWellToWheel (double) minimum
            if (this.EnergyUseWellToWheel < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyUseWellToWheel, must be a value greater than or equal to 0.", new [] { "EnergyUseWellToWheel" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The emission standard of the vehicle valid in the European Union.  Values different from _NONE_ supported for **engineType** _COMBUSTION_ and _HBYRID_. Relevant for &#x60;toll&#x60;, &#x60;emissions&#x60;. 
    /// </summary>
    /// <value>The emission standard of the vehicle valid in the European Union.  Values different from _NONE_ supported for **engineType** _COMBUSTION_ and _HBYRID_. Relevant for &#x60;toll&#x60;, &#x60;emissions&#x60;. </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum EmissionStandard
    {
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 1,
        /// <summary>
        /// Enum EURO_0 for value: EURO_0
        /// </summary>
        [EnumMember(Value = "EURO_0")]
        EURO_0 = 2,
        /// <summary>
        /// Enum EURO_1 for value: EURO_1
        /// </summary>
        [EnumMember(Value = "EURO_1")]
        EURO_1 = 3,
        /// <summary>
        /// Enum EURO_2 for value: EURO_2
        /// </summary>
        [EnumMember(Value = "EURO_2")]
        EURO_2 = 4,
        /// <summary>
        /// Enum EURO_3 for value: EURO_3
        /// </summary>
        [EnumMember(Value = "EURO_3")]
        EURO_3 = 5,
        /// <summary>
        /// Enum EURO_4 for value: EURO_4
        /// </summary>
        [EnumMember(Value = "EURO_4")]
        EURO_4 = 6,
        /// <summary>
        /// Enum EURO_5 for value: EURO_5
        /// </summary>
        [EnumMember(Value = "EURO_5")]
        EURO_5 = 7,
        /// <summary>
        /// Enum EURO_EEV for value: EURO_EEV
        /// </summary>
        [EnumMember(Value = "EURO_EEV")]
        EURO_EEV = 8,
        /// <summary>
        /// Enum EURO_6 for value: EURO_6
        /// </summary>
        [EnumMember(Value = "EURO_6")]
        EURO_6 = 9,
        /// <summary>
        /// Enum EURO_6C for value: EURO_6C
        /// </summary>
        [EnumMember(Value = "EURO_6C")]
        EURO_6C = 10,
        /// <summary>
        /// Enum EURO_6D_TEMP for value: EURO_6D_TEMP
        /// </summary>
        [EnumMember(Value = "EURO_6D_TEMP")]
        EURO_6D_TEMP = 11,
        /// <summary>
        /// Enum EURO_6D for value: EURO_6D
        /// </summary>
        [EnumMember(Value = "EURO_6D")]
        EURO_6D = 12,
        /// <summary>
        /// Enum EURO_6E for value: EURO_6E
        /// </summary>
        [EnumMember(Value = "EURO_6E")]
        EURO_6E = 13,
        /// <summary>
        /// Enum EURO_7 for value: EURO_7
        /// </summary>
        [EnumMember(Value = "EURO_7")]
        EURO_7 = 14
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The engine type of the vehicle. When changing the engine type further parameters must be specified to define a valid vehicle and to obtain proper results. For a hybrid or an electric vehicle **electricityType** and **averageElectricityConsumption** must be specified, for a hybrid vehicle additionally the **hybridRatio**.  Relevant for &#x60;toll&#x60;, &#x60;emissions&#x60;. 
    /// </summary>
    /// <value>The engine type of the vehicle. When changing the engine type further parameters must be specified to define a valid vehicle and to obtain proper results. For a hybrid or an electric vehicle **electricityType** and **averageElectricityConsumption** must be specified, for a hybrid vehicle additionally the **hybridRatio**.  Relevant for &#x60;toll&#x60;, &#x60;emissions&#x60;. </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum EngineType
    {
        /// <summary>
        /// Enum COMBUSTION for value: COMBUSTION
        /// </summary>
        [EnumMember(Value = "COMBUSTION")]
        COMBUSTION = 1,
        /// <summary>
        /// Enum ELECTRIC for value: ELECTRIC
        /// </summary>
        [EnumMember(Value = "ELECTRIC")]
        ELECTRIC = 2,
        /// <summary>
        /// Enum HYBRID for value: HYBRID
        /// </summary>
        [EnumMember(Value = "HYBRID")]
        HYBRID = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ErrorResponse
    /// </summary>
    [DataContract(Name = "ErrorResponse")]
    public partial class ErrorResponse : IEquatable<ErrorResponse>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ErrorResponse" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ErrorResponse() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ErrorResponse" /> class.
        /// </summary>
        /// <param name="description">A human readable message that describes the error. (required).</param>
        /// <param name="errorCode">A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **HTTP status code: 400**   * &#x60;GENERAL_VALIDATION_ERROR&#x60; - The validation of the request failed. Details can be found in **causes**. * &#x60;GENERAL_PARSING_ERROR&#x60; - The JSON syntax is invalid. * &#x60;ROUTING_ERROR&#x60; - The calculation failed. Details can be found in **causes**.  **HTTP status code: 401**   * &#x60;GENERAL_UNAUTHENTICATED&#x60; - Invalid or missing authentication credentials.   * &#x60;message&#x60; - An additional error message.  **HTTP status code: 403**   * &#x60;GENERAL_FORBIDDEN&#x60; - Insufficient access rights. * &#x60;GENERAL_QUOTA_EXCEEDED&#x60; - The transaction limit is exceeded.   * &#x60;message&#x60; - An additional error message. * &#x60;ROUTING_RESTRICTION_EXCEEDED&#x60; - A product-specific restriction is exceeded.  **HTTP status code: 404**   * &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60; - A requested resource does not exist.   * &#x60;message&#x60; - An additional error message.  **HTTP status code: 429**   * &#x60;GENERAL_RATE_LIMIT_EXCEEDED&#x60; - The rate limit is exceeded.  **HTTP status code: 500**   * &#x60;GENERAL_INTERNAL_SERVER_ERROR&#x60; - The request could not be processed due to an internal error.   * &#x60;message&#x60; - An additional error message.   * &#x60;hint&#x60; - A hint how to solve the problem.  **HTTP status code: 503**   * &#x60;GENERAL_SERVICE_UNAVAILABLE&#x60; - The service is temporarily unavailable.  **HTTP status code: 4xx-5xx**   * &#x60;GENERAL_INTERNAL_GATEWAY_ERROR&#x60; - The request could not be processed due to an internal gateway error.   * &#x60;hint&#x60; - A hint how to solve the problem. (required).</param>
        /// <param name="traceId">A unique identifier of the corresponding trace forest. It can be used to trace errors by the support. (required).</param>
        /// <param name="errorId">A unique identifier specific to this error instance. It can be used to trace errors by the support..</param>
        /// <param name="causes">A list of affected parameters and/or properties that caused this error..</param>
        /// <param name="details">Additional properties specific to this error class..</param>
        public ErrorResponse(string description = default(string), string errorCode = default(string), string traceId = default(string), string errorId = default(string), List<CausingError> causes = default(List<CausingError>), Dictionary<string, Object> details = default(Dictionary<string, Object>))
        {
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for ErrorResponse and cannot be null");
            }
            this.Description = description;
            // to ensure "errorCode" is required (not null)
            if (errorCode == null)
            {
                throw new ArgumentNullException("errorCode is a required property for ErrorResponse and cannot be null");
            }
            this.ErrorCode = errorCode;
            // to ensure "traceId" is required (not null)
            if (traceId == null)
            {
                throw new ArgumentNullException("traceId is a required property for ErrorResponse and cannot be null");
            }
            this.TraceId = traceId;
            this.ErrorId = errorId;
            this.Causes = causes;
            this.Details = details;
        }
        /// <summary>
        /// A human readable message that describes the error.
        /// </summary>
        /// <value>A human readable message that describes the error.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = true)]
        public string Description { get; set; }
        /// <summary>
        /// A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **HTTP status code: 400**   * &#x60;GENERAL_VALIDATION_ERROR&#x60; - The validation of the request failed. Details can be found in **causes**. * &#x60;GENERAL_PARSING_ERROR&#x60; - The JSON syntax is invalid. * &#x60;ROUTING_ERROR&#x60; - The calculation failed. Details can be found in **causes**.  **HTTP status code: 401**   * &#x60;GENERAL_UNAUTHENTICATED&#x60; - Invalid or missing authentication credentials.   * &#x60;message&#x60; - An additional error message.  **HTTP status code: 403**   * &#x60;GENERAL_FORBIDDEN&#x60; - Insufficient access rights. * &#x60;GENERAL_QUOTA_EXCEEDED&#x60; - The transaction limit is exceeded.   * &#x60;message&#x60; - An additional error message. * &#x60;ROUTING_RESTRICTION_EXCEEDED&#x60; - A product-specific restriction is exceeded.  **HTTP status code: 404**   * &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60; - A requested resource does not exist.   * &#x60;message&#x60; - An additional error message.  **HTTP status code: 429**   * &#x60;GENERAL_RATE_LIMIT_EXCEEDED&#x60; - The rate limit is exceeded.  **HTTP status code: 500**   * &#x60;GENERAL_INTERNAL_SERVER_ERROR&#x60; - The request could not be processed due to an internal error.   * &#x60;message&#x60; - An additional error message.   * &#x60;hint&#x60; - A hint how to solve the problem.  **HTTP status code: 503**   * &#x60;GENERAL_SERVICE_UNAVAILABLE&#x60; - The service is temporarily unavailable.  **HTTP status code: 4xx-5xx**   * &#x60;GENERAL_INTERNAL_GATEWAY_ERROR&#x60; - The request could not be processed due to an internal gateway error.   * &#x60;hint&#x60; - A hint how to solve the problem.
        /// </summary>
        /// <value>A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.    **HTTP status code: 400**   * &#x60;GENERAL_VALIDATION_ERROR&#x60; - The validation of the request failed. Details can be found in **causes**. * &#x60;GENERAL_PARSING_ERROR&#x60; - The JSON syntax is invalid. * &#x60;ROUTING_ERROR&#x60; - The calculation failed. Details can be found in **causes**.  **HTTP status code: 401**   * &#x60;GENERAL_UNAUTHENTICATED&#x60; - Invalid or missing authentication credentials.   * &#x60;message&#x60; - An additional error message.  **HTTP status code: 403**   * &#x60;GENERAL_FORBIDDEN&#x60; - Insufficient access rights. * &#x60;GENERAL_QUOTA_EXCEEDED&#x60; - The transaction limit is exceeded.   * &#x60;message&#x60; - An additional error message. * &#x60;ROUTING_RESTRICTION_EXCEEDED&#x60; - A product-specific restriction is exceeded.  **HTTP status code: 404**   * &#x60;GENERAL_RESOURCE_NOT_FOUND&#x60; - A requested resource does not exist.   * &#x60;message&#x60; - An additional error message.  **HTTP status code: 429**   * &#x60;GENERAL_RATE_LIMIT_EXCEEDED&#x60; - The rate limit is exceeded.  **HTTP status code: 500**   * &#x60;GENERAL_INTERNAL_SERVER_ERROR&#x60; - The request could not be processed due to an internal error.   * &#x60;message&#x60; - An additional error message.   * &#x60;hint&#x60; - A hint how to solve the problem.  **HTTP status code: 503**   * &#x60;GENERAL_SERVICE_UNAVAILABLE&#x60; - The service is temporarily unavailable.  **HTTP status code: 4xx-5xx**   * &#x60;GENERAL_INTERNAL_GATEWAY_ERROR&#x60; - The request could not be processed due to an internal gateway error.   * &#x60;hint&#x60; - A hint how to solve the problem.</value>
        [DataMember(Name = "errorCode", IsRequired = true, EmitDefaultValue = true)]
        public string ErrorCode { get; set; }
        /// <summary>
        /// A unique identifier of the corresponding trace forest. It can be used to trace errors by the support.
        /// </summary>
        /// <value>A unique identifier of the corresponding trace forest. It can be used to trace errors by the support.</value>
        [DataMember(Name = "traceId", IsRequired = true, EmitDefaultValue = true)]
        public string TraceId { get; set; }
        /// <summary>
        /// A unique identifier specific to this error instance. It can be used to trace errors by the support.
        /// </summary>
        /// <value>A unique identifier specific to this error instance. It can be used to trace errors by the support.</value>
        [DataMember(Name = "errorId", EmitDefaultValue = false)]
        public string ErrorId { get; set; }
        /// <summary>
        /// A list of affected parameters and/or properties that caused this error.
        /// </summary>
        /// <value>A list of affected parameters and/or properties that caused this error.</value>
        [DataMember(Name = "causes", EmitDefaultValue = false)]
        public List<CausingError> Causes { get; set; }
        /// <summary>
        /// Additional properties specific to this error class.
        /// </summary>
        /// <value>Additional properties specific to this error class.</value>
        [DataMember(Name = "details", EmitDefaultValue = false)]
        public Dictionary<string, Object> Details { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ErrorResponse {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ErrorCode: ").Append(ErrorCode).Append("\n");
            sb.Append("  TraceId: ").Append(TraceId).Append("\n");
            sb.Append("  ErrorId: ").Append(ErrorId).Append("\n");
            sb.Append("  Causes: ").Append(Causes).Append("\n");
            sb.Append("  Details: ").Append(Details).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ErrorResponse);
        }
        /// <summary>
        /// Returns true if ErrorResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of ErrorResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ErrorResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ErrorCode == input.ErrorCode ||
                    (this.ErrorCode != null &&
                    this.ErrorCode.Equals(input.ErrorCode))
                ) && 
                (
                    this.TraceId == input.TraceId ||
                    (this.TraceId != null &&
                    this.TraceId.Equals(input.TraceId))
                ) && 
                (
                    this.ErrorId == input.ErrorId ||
                    (this.ErrorId != null &&
                    this.ErrorId.Equals(input.ErrorId))
                ) && 
                (
                    this.Causes == input.Causes ||
                    this.Causes != null &&
                    input.Causes != null &&
                    this.Causes.SequenceEqual(input.Causes)
                ) && 
                (
                    this.Details == input.Details ||
                    this.Details != null &&
                    input.Details != null &&
                    this.Details.SequenceEqual(input.Details)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.ErrorCode != null)
                {
                    hashCode = (hashCode * 59) + this.ErrorCode.GetHashCode();
                }
                if (this.TraceId != null)
                {
                    hashCode = (hashCode * 59) + this.TraceId.GetHashCode();
                }
                if (this.ErrorId != null)
                {
                    hashCode = (hashCode * 59) + this.ErrorId.GetHashCode();
                }
                if (this.Causes != null)
                {
                    hashCode = (hashCode * 59) + this.Causes.GetHashCode();
                }
                if (this.Details != null)
                {
                    hashCode = (hashCode * 59) + this.Details.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The response of an ETA calculation.
    /// </summary>
    [DataContract(Name = "EtaResponse")]
    public partial class EtaResponse : IEquatable<EtaResponse>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EtaResponse" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EtaResponse() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EtaResponse" /> class.
        /// </summary>
        /// <param name="remainingWaypoints">The ETA and the remaining distance and travel time to the waypoints not yet reached by the route. (required).</param>
        /// <param name="routeId">If the route has been recalculated, this is the ID of the new route. That will happen when it is likely that the vehicle has left the route, so the vehicle position is too far away from the route, or when the estimated time of arrival at the last waypoint is delayed in a way that another route may result in arriving earlier..</param>
        /// <param name="warnings">A list of warnings concerning the validity of the result..</param>
        public EtaResponse(List<RemainingWaypoint> remainingWaypoints = default(List<RemainingWaypoint>), Guid routeId = default(Guid), List<Warning> warnings = default(List<Warning>))
        {
            // to ensure "remainingWaypoints" is required (not null)
            if (remainingWaypoints == null)
            {
                throw new ArgumentNullException("remainingWaypoints is a required property for EtaResponse and cannot be null");
            }
            this.RemainingWaypoints = remainingWaypoints;
            this.RouteId = routeId;
            this.Warnings = warnings;
        }
        /// <summary>
        /// The ETA and the remaining distance and travel time to the waypoints not yet reached by the route.
        /// </summary>
        /// <value>The ETA and the remaining distance and travel time to the waypoints not yet reached by the route.</value>
        [DataMember(Name = "remainingWaypoints", IsRequired = true, EmitDefaultValue = true)]
        public List<RemainingWaypoint> RemainingWaypoints { get; set; }
        /// <summary>
        /// If the route has been recalculated, this is the ID of the new route. That will happen when it is likely that the vehicle has left the route, so the vehicle position is too far away from the route, or when the estimated time of arrival at the last waypoint is delayed in a way that another route may result in arriving earlier.
        /// </summary>
        /// <value>If the route has been recalculated, this is the ID of the new route. That will happen when it is likely that the vehicle has left the route, so the vehicle position is too far away from the route, or when the estimated time of arrival at the last waypoint is delayed in a way that another route may result in arriving earlier.</value>
        [DataMember(Name = "routeId", EmitDefaultValue = false)]
        public Guid RouteId { get; set; }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EtaResponse {\n");
            sb.Append("  RemainingWaypoints: ").Append(RemainingWaypoints).Append("\n");
            sb.Append("  RouteId: ").Append(RouteId).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EtaResponse);
        }
        /// <summary>
        /// Returns true if EtaResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of EtaResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EtaResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.RemainingWaypoints == input.RemainingWaypoints ||
                    this.RemainingWaypoints != null &&
                    input.RemainingWaypoints != null &&
                    this.RemainingWaypoints.SequenceEqual(input.RemainingWaypoints)
                ) && 
                (
                    this.RouteId == input.RouteId ||
                    (this.RouteId != null &&
                    this.RouteId.Equals(input.RouteId))
                ) && 
                (
                    this.Warnings == input.Warnings ||
                    this.Warnings != null &&
                    input.Warnings != null &&
                    this.Warnings.SequenceEqual(input.Warnings)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.RemainingWaypoints != null)
                {
                    hashCode = (hashCode * 59) + this.RemainingWaypoints.GetHashCode();
                }
                if (this.RouteId != null)
                {
                    hashCode = (hashCode * 59) + this.RouteId.GetHashCode();
                }
                if (this.Warnings != null)
                {
                    hashCode = (hashCode * 59) + this.Warnings.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines EtcSubscriptionTypes
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum EtcSubscriptionTypes
    {
        /// <summary>
        /// Enum AT_GOBOX for value: AT_GOBOX
        /// </summary>
        [EnumMember(Value = "AT_GOBOX")]
        AT_GOBOX = 1,
        /// <summary>
        /// Enum BE_TELETOL for value: BE_TELETOL
        /// </summary>
        [EnumMember(Value = "BE_TELETOL")]
        BE_TELETOL = 2,
        /// <summary>
        /// Enum BE_VIAPASS for value: BE_VIAPASS
        /// </summary>
        [EnumMember(Value = "BE_VIAPASS")]
        BE_VIAPASS = 3,
        /// <summary>
        /// Enum CH_LSVA for value: CH_LSVA
        /// </summary>
        [EnumMember(Value = "CH_LSVA")]
        CH_LSVA = 4,
        /// <summary>
        /// Enum DE_QUICKBOX for value: DE_QUICKBOX
        /// </summary>
        [EnumMember(Value = "DE_QUICKBOX")]
        DE_QUICKBOX = 5,
        /// <summary>
        /// Enum DE_TOLLCOLLECT for value: DE_TOLLCOLLECT
        /// </summary>
        [EnumMember(Value = "DE_TOLLCOLLECT")]
        DE_TOLLCOLLECT = 6,
        /// <summary>
        /// Enum DE_WARNOWTUNNEL_RFID for value: DE_WARNOWTUNNEL_RFID
        /// </summary>
        [EnumMember(Value = "DE_WARNOWTUNNEL_RFID")]
        DE_WARNOWTUNNEL_RFID = 7,
        /// <summary>
        /// Enum DK_BROPAS_BUSINESS for value: DK_BROPAS_BUSINESS
        /// </summary>
        [EnumMember(Value = "DK_BROPAS_BUSINESS")]
        DK_BROPAS_BUSINESS = 8,
        /// <summary>
        /// Enum IT_TELEPASS for value: IT_TELEPASS
        /// </summary>
        [EnumMember(Value = "IT_TELEPASS")]
        IT_TELEPASS = 9,
        /// <summary>
        /// Enum NL_TELECARD for value: NL_TELECARD
        /// </summary>
        [EnumMember(Value = "NL_TELECARD")]
        NL_TELECARD = 10,
        /// <summary>
        /// Enum NL_TTAG for value: NL_TTAG
        /// </summary>
        [EnumMember(Value = "NL_TTAG")]
        NL_TTAG = 11,
        /// <summary>
        /// Enum NO_AUTOPASS for value: NO_AUTOPASS
        /// </summary>
        [EnumMember(Value = "NO_AUTOPASS")]
        NO_AUTOPASS = 12,
        /// <summary>
        /// Enum PT_VIA_VERDE for value: PT_VIA_VERDE
        /// </summary>
        [EnumMember(Value = "PT_VIA_VERDE")]
        PT_VIA_VERDE = 13,
        /// <summary>
        /// Enum US_APASS for value: US_APASS
        /// </summary>
        [EnumMember(Value = "US_APASS")]
        US_APASS = 14,
        /// <summary>
        /// Enum US_BREEZEBY for value: US_BREEZEBY
        /// </summary>
        [EnumMember(Value = "US_BREEZEBY")]
        US_BREEZEBY = 15,
        /// <summary>
        /// Enum US_DOWNBEACH_EXPRESSPASS for value: US_DOWNBEACH_EXPRESSPASS
        /// </summary>
        [EnumMember(Value = "US_DOWNBEACH_EXPRESSPASS")]
        US_DOWNBEACH_EXPRESSPASS = 16,
        /// <summary>
        /// Enum US_EPASS for value: US_EPASS
        /// </summary>
        [EnumMember(Value = "US_EPASS")]
        US_EPASS = 17,
        /// <summary>
        /// Enum US_EXPRESSACCOUNT for value: US_EXPRESSACCOUNT
        /// </summary>
        [EnumMember(Value = "US_EXPRESSACCOUNT")]
        US_EXPRESSACCOUNT = 18,
        /// <summary>
        /// Enum US_EXPRESSCARD for value: US_EXPRESSCARD
        /// </summary>
        [EnumMember(Value = "US_EXPRESSCARD")]
        US_EXPRESSCARD = 19,
        /// <summary>
        /// Enum US_EXPRESSPASS for value: US_EXPRESSPASS
        /// </summary>
        [EnumMember(Value = "US_EXPRESSPASS")]
        US_EXPRESSPASS = 20,
        /// <summary>
        /// Enum US_EXPRESSTOLL for value: US_EXPRESSTOLL
        /// </summary>
        [EnumMember(Value = "US_EXPRESSTOLL")]
        US_EXPRESSTOLL = 21,
        /// <summary>
        /// Enum US_EZPASS for value: US_EZPASS
        /// </summary>
        [EnumMember(Value = "US_EZPASS")]
        US_EZPASS = 22,
        /// <summary>
        /// Enum US_EZTAG for value: US_EZTAG
        /// </summary>
        [EnumMember(Value = "US_EZTAG")]
        US_EZTAG = 23,
        /// <summary>
        /// Enum US_FASTRAK for value: US_FASTRAK
        /// </summary>
        [EnumMember(Value = "US_FASTRAK")]
        US_FASTRAK = 24,
        /// <summary>
        /// Enum US_GEAUXPASS for value: US_GEAUXPASS
        /// </summary>
        [EnumMember(Value = "US_GEAUXPASS")]
        US_GEAUXPASS = 25,
        /// <summary>
        /// Enum US_GOODTOGO for value: US_GOODTOGO
        /// </summary>
        [EnumMember(Value = "US_GOODTOGO")]
        US_GOODTOGO = 26,
        /// <summary>
        /// Enum US_GOPASS for value: US_GOPASS
        /// </summary>
        [EnumMember(Value = "US_GOPASS")]
        US_GOPASS = 27,
        /// <summary>
        /// Enum US_IPASS for value: US_IPASS
        /// </summary>
        [EnumMember(Value = "US_IPASS")]
        US_IPASS = 28,
        /// <summary>
        /// Enum US_KTAG for value: US_KTAG
        /// </summary>
        [EnumMember(Value = "US_KTAG")]
        US_KTAG = 29,
        /// <summary>
        /// Enum US_LEEWAY for value: US_LEEWAY
        /// </summary>
        [EnumMember(Value = "US_LEEWAY")]
        US_LEEWAY = 30,
        /// <summary>
        /// Enum US_MACKINACBRIDGE_MACPASS for value: US_MACKINACBRIDGE_MACPASS
        /// </summary>
        [EnumMember(Value = "US_MACKINACBRIDGE_MACPASS")]
        US_MACKINACBRIDGE_MACPASS = 31,
        /// <summary>
        /// Enum US_MARYLAND_EZPASS for value: US_MARYLAND_EZPASS
        /// </summary>
        [EnumMember(Value = "US_MARYLAND_EZPASS")]
        US_MARYLAND_EZPASS = 32,
        /// <summary>
        /// Enum US_MASSACHUSETTS_EZPASS for value: US_MASSACHUSETTS_EZPASS
        /// </summary>
        [EnumMember(Value = "US_MASSACHUSETTS_EZPASS")]
        US_MASSACHUSETTS_EZPASS = 33,
        /// <summary>
        /// Enum US_NC_QUICKPASS for value: US_NC_QUICKPASS
        /// </summary>
        [EnumMember(Value = "US_NC_QUICKPASS")]
        US_NC_QUICKPASS = 34,
        /// <summary>
        /// Enum US_NEWHAMPSHIRE_EZPASS for value: US_NEWHAMPSHIRE_EZPASS
        /// </summary>
        [EnumMember(Value = "US_NEWHAMPSHIRE_EZPASS")]
        US_NEWHAMPSHIRE_EZPASS = 35,
        /// <summary>
        /// Enum US_NEWJERSEY_EZPASS for value: US_NEWJERSEY_EZPASS
        /// </summary>
        [EnumMember(Value = "US_NEWJERSEY_EZPASS")]
        US_NEWJERSEY_EZPASS = 36,
        /// <summary>
        /// Enum US_NEWYORK_EZPASS for value: US_NEWYORK_EZPASS
        /// </summary>
        [EnumMember(Value = "US_NEWYORK_EZPASS")]
        US_NEWYORK_EZPASS = 37,
        /// <summary>
        /// Enum US_NEXPRESS for value: US_NEXPRESS
        /// </summary>
        [EnumMember(Value = "US_NEXPRESS")]
        US_NEXPRESS = 38,
        /// <summary>
        /// Enum US_OHIO_EZPASS for value: US_OHIO_EZPASS
        /// </summary>
        [EnumMember(Value = "US_OHIO_EZPASS")]
        US_OHIO_EZPASS = 39,
        /// <summary>
        /// Enum US_PALPASS for value: US_PALPASS
        /// </summary>
        [EnumMember(Value = "US_PALPASS")]
        US_PALPASS = 40,
        /// <summary>
        /// Enum US_PIKEPASS for value: US_PIKEPASS
        /// </summary>
        [EnumMember(Value = "US_PIKEPASS")]
        US_PIKEPASS = 41,
        /// <summary>
        /// Enum US_RIVERLINK for value: US_RIVERLINK
        /// </summary>
        [EnumMember(Value = "US_RIVERLINK")]
        US_RIVERLINK = 42,
        /// <summary>
        /// Enum US_RIVERLINK_NOTRANSPONDER for value: US_RIVERLINK_NOTRANSPONDER
        /// </summary>
        [EnumMember(Value = "US_RIVERLINK_NOTRANSPONDER")]
        US_RIVERLINK_NOTRANSPONDER = 43,
        /// <summary>
        /// Enum US_SEAWAYTRANSITCARD for value: US_SEAWAYTRANSITCARD
        /// </summary>
        [EnumMember(Value = "US_SEAWAYTRANSITCARD")]
        US_SEAWAYTRANSITCARD = 44,
        /// <summary>
        /// Enum US_SUNPASS for value: US_SUNPASS
        /// </summary>
        [EnumMember(Value = "US_SUNPASS")]
        US_SUNPASS = 45,
        /// <summary>
        /// Enum US_TOLLTAG for value: US_TOLLTAG
        /// </summary>
        [EnumMember(Value = "US_TOLLTAG")]
        US_TOLLTAG = 46,
        /// <summary>
        /// Enum US_TXTAG for value: US_TXTAG
        /// </summary>
        [EnumMember(Value = "US_TXTAG")]
        US_TXTAG = 47,
        /// <summary>
        /// Enum US_VIRGINIA_EZPASS for value: US_VIRGINIA_EZPASS
        /// </summary>
        [EnumMember(Value = "US_VIRGINIA_EZPASS")]
        US_VIRGINIA_EZPASS = 48,
        /// <summary>
        /// Enum US_WESTVIRGINIA_EZPASS for value: US_WESTVIRGINIA_EZPASS
        /// </summary>
        [EnumMember(Value = "US_WESTVIRGINIA_EZPASS")]
        US_WESTVIRGINIA_EZPASS = 49,
        /// <summary>
        /// Enum US_PEACHPASS for value: US_PEACHPASS
        /// </summary>
        [EnumMember(Value = "US_PEACHPASS")]
        US_PEACHPASS = 50,
        /// <summary>
        /// Enum US_NEXUS for value: US_NEXUS
        /// </summary>
        [EnumMember(Value = "US_NEXUS")]
        US_NEXUS = 51,
        /// <summary>
        /// Enum US_DELAWARE_EZPASS for value: US_DELAWARE_EZPASS
        /// </summary>
        [EnumMember(Value = "US_DELAWARE_EZPASS")]
        US_DELAWARE_EZPASS = 52,
        /// <summary>
        /// Enum US_GROSSEILETOLLBRIDGE_PASSTAG for value: US_GROSSEILETOLLBRIDGE_PASSTAG
        /// </summary>
        [EnumMember(Value = "US_GROSSEILETOLLBRIDGE_PASSTAG")]
        US_GROSSEILETOLLBRIDGE_PASSTAG = 53,
        /// <summary>
        /// Enum US_EZPASS_PAYBYPLATE for value: US_EZPASS_PAYBYPLATE
        /// </summary>
        [EnumMember(Value = "US_EZPASS_PAYBYPLATE")]
        US_EZPASS_PAYBYPLATE = 54
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Event
    /// </summary>
    [DataContract(Name = "Event")]
    public partial class Event : IEquatable<Event>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Event" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Event() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Event" /> class.
        /// </summary>
        /// <param name="latitude">The latitude of the position where the event takes place in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude of the position where the event takes place in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        /// <param name="startsAt">The time at which the event starts formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Will not be present for **trafficMode** _AVERAGE_ when neither **startTime** nor **arrivalTime** is specified..</param>
        /// <param name="distanceFromStart">The distance from the start to this event [m]. (required).</param>
        /// <param name="travelTimeFromStart">The travel time from the start to this event [s]. (required).</param>
        /// <param name="countryCode">Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. (required).</param>
        /// <param name="utcOffset">The offset to UTC [min]. Will not contain daylight-saving time for **trafficMode** _AVERAGE_ when neither **startTime** nor **arrivalTime** is specified. (required).</param>
        /// <param name="toll">toll.</param>
        /// <param name="maneuver">maneuver.</param>
        /// <param name="border">border.</param>
        /// <param name="violation">violation.</param>
        /// <param name="waypoint">waypoint.</param>
        /// <param name="utcOffsetChange">utcOffsetChange.</param>
        /// <param name="schedule">schedule.</param>
        /// <param name="combinedTransport">combinedTransport.</param>
        /// <param name="traffic">traffic.</param>
        public Event(double latitude = default(double), double longitude = default(double), DateTime startsAt = default(DateTime), int distanceFromStart = default(int), int travelTimeFromStart = default(int), string countryCode = default(string), int utcOffset = default(int), TollEvent toll = default(TollEvent), ManeuverEvent maneuver = default(ManeuverEvent), BorderEvent border = default(BorderEvent), ViolationEvent violation = default(ViolationEvent), WaypointEvent waypoint = default(WaypointEvent), UTCOffsetChangeEvent utcOffsetChange = default(UTCOffsetChangeEvent), ScheduleEvent schedule = default(ScheduleEvent), CombinedTransportEvent combinedTransport = default(CombinedTransportEvent), TrafficEvent traffic = default(TrafficEvent))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
            this.DistanceFromStart = distanceFromStart;
            this.TravelTimeFromStart = travelTimeFromStart;
            // to ensure "countryCode" is required (not null)
            if (countryCode == null)
            {
                throw new ArgumentNullException("countryCode is a required property for Event and cannot be null");
            }
            this.CountryCode = countryCode;
            this.UtcOffset = utcOffset;
            this.StartsAt = startsAt;
            this.Toll = toll;
            this.Maneuver = maneuver;
            this.Border = border;
            this.Violation = violation;
            this.Waypoint = waypoint;
            this.UtcOffsetChange = utcOffsetChange;
            this.Schedule = schedule;
            this.CombinedTransport = combinedTransport;
            this.Traffic = traffic;
        }
        /// <summary>
        /// The latitude of the position where the event takes place in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude of the position where the event takes place in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.254878</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude of the position where the event takes place in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude of the position where the event takes place in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>8.544585</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// The time at which the event starts formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Will not be present for **trafficMode** _AVERAGE_ when neither **startTime** nor **arrivalTime** is specified.
        /// </summary>
        /// <value>The time at which the event starts formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Will not be present for **trafficMode** _AVERAGE_ when neither **startTime** nor **arrivalTime** is specified.</value>
        /// <example>2020-04-06T06:00Z</example>
        [DataMember(Name = "startsAt", EmitDefaultValue = false)]
        public DateTime StartsAt { get; set; }
        /// <summary>
        /// The distance from the start to this event [m].
        /// </summary>
        /// <value>The distance from the start to this event [m].</value>
        /// <example>1422</example>
        [DataMember(Name = "distanceFromStart", IsRequired = true, EmitDefaultValue = true)]
        public int DistanceFromStart { get; set; }
        /// <summary>
        /// The travel time from the start to this event [s].
        /// </summary>
        /// <value>The travel time from the start to this event [s].</value>
        /// <example>56</example>
        [DataMember(Name = "travelTimeFromStart", IsRequired = true, EmitDefaultValue = true)]
        public int TravelTimeFromStart { get; set; }
        /// <summary>
        /// Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        /// <example>DE</example>
        [DataMember(Name = "countryCode", IsRequired = true, EmitDefaultValue = true)]
        public string CountryCode { get; set; }
        /// <summary>
        /// The offset to UTC [min]. Will not contain daylight-saving time for **trafficMode** _AVERAGE_ when neither **startTime** nor **arrivalTime** is specified.
        /// </summary>
        /// <value>The offset to UTC [min]. Will not contain daylight-saving time for **trafficMode** _AVERAGE_ when neither **startTime** nor **arrivalTime** is specified.</value>
        [DataMember(Name = "utcOffset", IsRequired = true, EmitDefaultValue = true)]
        public int UtcOffset { get; set; }
        /// <summary>
        /// Gets or Sets Toll
        /// </summary>
        [DataMember(Name = "toll", EmitDefaultValue = false)]
        public TollEvent Toll { get; set; }
        /// <summary>
        /// Gets or Sets Maneuver
        /// </summary>
        [DataMember(Name = "maneuver", EmitDefaultValue = false)]
        public ManeuverEvent Maneuver { get; set; }
        /// <summary>
        /// Gets or Sets Border
        /// </summary>
        [DataMember(Name = "border", EmitDefaultValue = false)]
        public BorderEvent Border { get; set; }
        /// <summary>
        /// Gets or Sets Violation
        /// </summary>
        [DataMember(Name = "violation", EmitDefaultValue = false)]
        public ViolationEvent Violation { get; set; }
        /// <summary>
        /// Gets or Sets Waypoint
        /// </summary>
        [DataMember(Name = "waypoint", EmitDefaultValue = false)]
        public WaypointEvent Waypoint { get; set; }
        /// <summary>
        /// Gets or Sets UtcOffsetChange
        /// </summary>
        [DataMember(Name = "utcOffsetChange", EmitDefaultValue = false)]
        public UTCOffsetChangeEvent UtcOffsetChange { get; set; }
        /// <summary>
        /// Gets or Sets Schedule
        /// </summary>
        [DataMember(Name = "schedule", EmitDefaultValue = false)]
        public ScheduleEvent Schedule { get; set; }
        /// <summary>
        /// Gets or Sets CombinedTransport
        /// </summary>
        [DataMember(Name = "combinedTransport", EmitDefaultValue = false)]
        public CombinedTransportEvent CombinedTransport { get; set; }
        /// <summary>
        /// Gets or Sets Traffic
        /// </summary>
        [DataMember(Name = "traffic", EmitDefaultValue = false)]
        public TrafficEvent Traffic { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Event {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("  StartsAt: ").Append(StartsAt).Append("\n");
            sb.Append("  DistanceFromStart: ").Append(DistanceFromStart).Append("\n");
            sb.Append("  TravelTimeFromStart: ").Append(TravelTimeFromStart).Append("\n");
            sb.Append("  CountryCode: ").Append(CountryCode).Append("\n");
            sb.Append("  UtcOffset: ").Append(UtcOffset).Append("\n");
            sb.Append("  Toll: ").Append(Toll).Append("\n");
            sb.Append("  Maneuver: ").Append(Maneuver).Append("\n");
            sb.Append("  Border: ").Append(Border).Append("\n");
            sb.Append("  Violation: ").Append(Violation).Append("\n");
            sb.Append("  Waypoint: ").Append(Waypoint).Append("\n");
            sb.Append("  UtcOffsetChange: ").Append(UtcOffsetChange).Append("\n");
            sb.Append("  Schedule: ").Append(Schedule).Append("\n");
            sb.Append("  CombinedTransport: ").Append(CombinedTransport).Append("\n");
            sb.Append("  Traffic: ").Append(Traffic).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Event);
        }
        /// <summary>
        /// Returns true if Event instances are equal
        /// </summary>
        /// <param name="input">Instance of Event to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Event input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                ) && 
                (
                    this.StartsAt == input.StartsAt ||
                    (this.StartsAt != null &&
                    this.StartsAt.Equals(input.StartsAt))
                ) && 
                (
                    this.DistanceFromStart == input.DistanceFromStart ||
                    this.DistanceFromStart.Equals(input.DistanceFromStart)
                ) && 
                (
                    this.TravelTimeFromStart == input.TravelTimeFromStart ||
                    this.TravelTimeFromStart.Equals(input.TravelTimeFromStart)
                ) && 
                (
                    this.CountryCode == input.CountryCode ||
                    (this.CountryCode != null &&
                    this.CountryCode.Equals(input.CountryCode))
                ) && 
                (
                    this.UtcOffset == input.UtcOffset ||
                    this.UtcOffset.Equals(input.UtcOffset)
                ) && 
                (
                    this.Toll == input.Toll ||
                    (this.Toll != null &&
                    this.Toll.Equals(input.Toll))
                ) && 
                (
                    this.Maneuver == input.Maneuver ||
                    (this.Maneuver != null &&
                    this.Maneuver.Equals(input.Maneuver))
                ) && 
                (
                    this.Border == input.Border ||
                    (this.Border != null &&
                    this.Border.Equals(input.Border))
                ) && 
                (
                    this.Violation == input.Violation ||
                    (this.Violation != null &&
                    this.Violation.Equals(input.Violation))
                ) && 
                (
                    this.Waypoint == input.Waypoint ||
                    (this.Waypoint != null &&
                    this.Waypoint.Equals(input.Waypoint))
                ) && 
                (
                    this.UtcOffsetChange == input.UtcOffsetChange ||
                    (this.UtcOffsetChange != null &&
                    this.UtcOffsetChange.Equals(input.UtcOffsetChange))
                ) && 
                (
                    this.Schedule == input.Schedule ||
                    (this.Schedule != null &&
                    this.Schedule.Equals(input.Schedule))
                ) && 
                (
                    this.CombinedTransport == input.CombinedTransport ||
                    (this.CombinedTransport != null &&
                    this.CombinedTransport.Equals(input.CombinedTransport))
                ) && 
                (
                    this.Traffic == input.Traffic ||
                    (this.Traffic != null &&
                    this.Traffic.Equals(input.Traffic))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                if (this.StartsAt != null)
                {
                    hashCode = (hashCode * 59) + this.StartsAt.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.DistanceFromStart.GetHashCode();
                hashCode = (hashCode * 59) + this.TravelTimeFromStart.GetHashCode();
                if (this.CountryCode != null)
                {
                    hashCode = (hashCode * 59) + this.CountryCode.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.UtcOffset.GetHashCode();
                if (this.Toll != null)
                {
                    hashCode = (hashCode * 59) + this.Toll.GetHashCode();
                }
                if (this.Maneuver != null)
                {
                    hashCode = (hashCode * 59) + this.Maneuver.GetHashCode();
                }
                if (this.Border != null)
                {
                    hashCode = (hashCode * 59) + this.Border.GetHashCode();
                }
                if (this.Violation != null)
                {
                    hashCode = (hashCode * 59) + this.Violation.GetHashCode();
                }
                if (this.Waypoint != null)
                {
                    hashCode = (hashCode * 59) + this.Waypoint.GetHashCode();
                }
                if (this.UtcOffsetChange != null)
                {
                    hashCode = (hashCode * 59) + this.UtcOffsetChange.GetHashCode();
                }
                if (this.Schedule != null)
                {
                    hashCode = (hashCode * 59) + this.Schedule.GetHashCode();
                }
                if (this.CombinedTransport != null)
                {
                    hashCode = (hashCode * 59) + this.CombinedTransport.GetHashCode();
                }
                if (this.Traffic != null)
                {
                    hashCode = (hashCode * 59) + this.Traffic.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            // DistanceFromStart (int) minimum
            if (this.DistanceFromStart < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DistanceFromStart, must be a value greater than or equal to 0.", new [] { "DistanceFromStart" });
            }
            // TravelTimeFromStart (int) minimum
            if (this.TravelTimeFromStart < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TravelTimeFromStart, must be a value greater than or equal to 0.", new [] { "TravelTimeFromStart" });
            }
            // UtcOffset (int) maximum
            if (this.UtcOffset > (int)840)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UtcOffset, must be a value less than or equal to 840.", new [] { "UtcOffset" });
            }
            // UtcOffset (int) minimum
            if (this.UtcOffset < (int)-720)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UtcOffset, must be a value greater than or equal to -720.", new [] { "UtcOffset" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ExchangeRate
    /// </summary>
    [DataContract(Name = "ExchangeRate")]
    public partial class ExchangeRate : IEquatable<ExchangeRate>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ExchangeRate" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ExchangeRate() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ExchangeRate" /> class.
        /// </summary>
        /// <param name="currency">The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code of the currency from which a price has been converted. (required).</param>
        /// <param name="rate">The exchange rate to convert a price from the base currency to this currency. (required).</param>
        public ExchangeRate(string currency = default(string), double rate = default(double))
        {
            // to ensure "currency" is required (not null)
            if (currency == null)
            {
                throw new ArgumentNullException("currency is a required property for ExchangeRate and cannot be null");
            }
            this.Currency = currency;
            this.Rate = rate;
        }
        /// <summary>
        /// The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code of the currency from which a price has been converted.
        /// </summary>
        /// <value>The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code of the currency from which a price has been converted.</value>
        [DataMember(Name = "currency", IsRequired = true, EmitDefaultValue = true)]
        public string Currency { get; set; }
        /// <summary>
        /// The exchange rate to convert a price from the base currency to this currency.
        /// </summary>
        /// <value>The exchange rate to convert a price from the base currency to this currency.</value>
        [DataMember(Name = "rate", IsRequired = true, EmitDefaultValue = true)]
        public double Rate { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ExchangeRate {\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  Rate: ").Append(Rate).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ExchangeRate);
        }
        /// <summary>
        /// Returns true if ExchangeRate instances are equal
        /// </summary>
        /// <param name="input">Instance of ExchangeRate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ExchangeRate input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                ) && 
                (
                    this.Rate == input.Rate ||
                    this.Rate.Equals(input.Rate)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Currency != null)
                {
                    hashCode = (hashCode * 59) + this.Currency.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Rate.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Currency != null) {
                // Currency (string) pattern
                Regex regexCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
                if (!regexCurrency.Match(this.Currency).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Currency, must match a pattern of " + regexCurrency, new [] { "Currency" });
                }
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The fuel type of the vehicle. The fuel types _CNG_GASOLINE_ and _LNG_GASOLINE_ are used for dual-fuel vehicles, therefore the **dualFuelRatio** has to be specified. These fuel types cannot be used with hybrid vehicles.  Supported for **engineType** _COMBUSTION_ and _HYBRID_. Relevant for &#x60;emissions&#x60;. 
    /// </summary>
    /// <value>The fuel type of the vehicle. The fuel types _CNG_GASOLINE_ and _LNG_GASOLINE_ are used for dual-fuel vehicles, therefore the **dualFuelRatio** has to be specified. These fuel types cannot be used with hybrid vehicles.  Supported for **engineType** _COMBUSTION_ and _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum FuelType
    {
        /// <summary>
        /// Enum GASOLINE for value: GASOLINE
        /// </summary>
        [EnumMember(Value = "GASOLINE")]
        GASOLINE = 1,
        /// <summary>
        /// Enum DIESEL for value: DIESEL
        /// </summary>
        [EnumMember(Value = "DIESEL")]
        DIESEL = 2,
        /// <summary>
        /// Enum COMPRESSED_NATURAL_GAS for value: COMPRESSED_NATURAL_GAS
        /// </summary>
        [EnumMember(Value = "COMPRESSED_NATURAL_GAS")]
        COMPRESSED_NATURAL_GAS = 3,
        /// <summary>
        /// Enum LIQUEFIED_PETROLEUM_GAS for value: LIQUEFIED_PETROLEUM_GAS
        /// </summary>
        [EnumMember(Value = "LIQUEFIED_PETROLEUM_GAS")]
        LIQUEFIED_PETROLEUM_GAS = 4,
        /// <summary>
        /// Enum LIQUEFIED_NATURAL_GAS for value: LIQUEFIED_NATURAL_GAS
        /// </summary>
        [EnumMember(Value = "LIQUEFIED_NATURAL_GAS")]
        LIQUEFIED_NATURAL_GAS = 5,
        /// <summary>
        /// Enum CNG_GASOLINE for value: CNG_GASOLINE
        /// </summary>
        [EnumMember(Value = "CNG_GASOLINE")]
        CNG_GASOLINE = 6,
        /// <summary>
        /// Enum LPG_GASOLINE for value: LPG_GASOLINE
        /// </summary>
        [EnumMember(Value = "LPG_GASOLINE")]
        LPG_GASOLINE = 7,
        /// <summary>
        /// Enum ETHANOL for value: ETHANOL
        /// </summary>
        [EnumMember(Value = "ETHANOL")]
        ETHANOL = 8,
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 9
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines HazardousMaterials
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum HazardousMaterials
    {
        /// <summary>
        /// Enum HAZARDOUS_TO_WATER for value: HAZARDOUS_TO_WATER
        /// </summary>
        [EnumMember(Value = "HAZARDOUS_TO_WATER")]
        HAZARDOUS_TO_WATER = 1,
        /// <summary>
        /// Enum EXPLOSIVE for value: EXPLOSIVE
        /// </summary>
        [EnumMember(Value = "EXPLOSIVE")]
        EXPLOSIVE = 2,
        /// <summary>
        /// Enum FLAMMABLE for value: FLAMMABLE
        /// </summary>
        [EnumMember(Value = "FLAMMABLE")]
        FLAMMABLE = 3,
        /// <summary>
        /// Enum RADIOACTIVE for value: RADIOACTIVE
        /// </summary>
        [EnumMember(Value = "RADIOACTIVE")]
        RADIOACTIVE = 4,
        /// <summary>
        /// Enum INHALATION_HAZARD for value: INHALATION_HAZARD
        /// </summary>
        [EnumMember(Value = "INHALATION_HAZARD")]
        INHALATION_HAZARD = 5,
        /// <summary>
        /// Enum MEDICAL_WASTE for value: MEDICAL_WASTE
        /// </summary>
        [EnumMember(Value = "MEDICAL_WASTE")]
        MEDICAL_WASTE = 6,
        /// <summary>
        /// Enum OTHER for value: OTHER
        /// </summary>
        [EnumMember(Value = "OTHER")]
        OTHER = 7,
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 8
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Specifies the geographical horizon.  * &#x60;DISTANCE&#x60; - Represents a geographical horizon that is described by a distance. Every point or road segment that is reachable from the source within the specified distance is included in the horizon.  * &#x60;TRAVEL_TIME&#x60; - Represents a geographical horizon that is described by a travel time. Every point or road segment that is reachable from the source within the specified travel time is included in the horizon.
    /// </summary>
    /// <value>Specifies the geographical horizon.  * &#x60;DISTANCE&#x60; - Represents a geographical horizon that is described by a distance. Every point or road segment that is reachable from the source within the specified distance is included in the horizon.  * &#x60;TRAVEL_TIME&#x60; - Represents a geographical horizon that is described by a travel time. Every point or road segment that is reachable from the source within the specified travel time is included in the horizon.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum HorizonType
    {
        /// <summary>
        /// Enum DISTANCE for value: DISTANCE
        /// </summary>
        [EnumMember(Value = "DISTANCE")]
        DISTANCE = 1,
        /// <summary>
        /// Enum TRAVEL_TIME for value: TRAVEL_TIME
        /// </summary>
        [EnumMember(Value = "TRAVEL_TIME")]
        TRAVEL_TIME = 2
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Leg
    /// </summary>
    [DataContract(Name = "Leg")]
    public partial class Leg : IEquatable<Leg>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Leg" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Leg() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Leg" /> class.
        /// </summary>
        /// <param name="distance">The distance of the leg [m]. (required).</param>
        /// <param name="travelTime">The travel time for the leg [s]. (required).</param>
        /// <param name="trafficDelay">The total delay due to live traffic on this leg [s].  This value contains the sum of all traffic events on this leg and will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information..</param>
        /// <param name="violated">When the leg cannot be calculated for the given vehicle the resulting leg is marked as violated. (required).</param>
        /// <param name="tollCosts">tollCosts.</param>
        /// <param name="polyline">The polyline of the leg in the format specified by **options[polylineFormat]**..</param>
        public Leg(int distance = default(int), int travelTime = default(int), int trafficDelay = default(int), bool violated = default(bool), TollCosts tollCosts = default(TollCosts), string polyline = default(string))
        {
            this.Distance = distance;
            this.TravelTime = travelTime;
            this.Violated = violated;
            this.TrafficDelay = trafficDelay;
            this.TollCosts = tollCosts;
            this.Polyline = polyline;
        }
        /// <summary>
        /// The distance of the leg [m].
        /// </summary>
        /// <value>The distance of the leg [m].</value>
        /// <example>1422</example>
        [DataMember(Name = "distance", IsRequired = true, EmitDefaultValue = true)]
        public int Distance { get; set; }
        /// <summary>
        /// The travel time for the leg [s].
        /// </summary>
        /// <value>The travel time for the leg [s].</value>
        /// <example>56</example>
        [DataMember(Name = "travelTime", IsRequired = true, EmitDefaultValue = true)]
        public int TravelTime { get; set; }
        /// <summary>
        /// The total delay due to live traffic on this leg [s].  This value contains the sum of all traffic events on this leg and will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information.
        /// </summary>
        /// <value>The total delay due to live traffic on this leg [s].  This value contains the sum of all traffic events on this leg and will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information.</value>
        /// <example>0</example>
        [DataMember(Name = "trafficDelay", EmitDefaultValue = false)]
        public int TrafficDelay { get; set; }
        /// <summary>
        /// When the leg cannot be calculated for the given vehicle the resulting leg is marked as violated.
        /// </summary>
        /// <value>When the leg cannot be calculated for the given vehicle the resulting leg is marked as violated.</value>
        /// <example>false</example>
        [DataMember(Name = "violated", IsRequired = true, EmitDefaultValue = true)]
        public bool Violated { get; set; }
        /// <summary>
        /// Gets or Sets TollCosts
        /// </summary>
        [DataMember(Name = "tollCosts", EmitDefaultValue = false)]
        public TollCosts TollCosts { get; set; }
        /// <summary>
        /// The polyline of the leg in the format specified by **options[polylineFormat]**.
        /// </summary>
        /// <value>The polyline of the leg in the format specified by **options[polylineFormat]**.</value>
        [DataMember(Name = "polyline", EmitDefaultValue = false)]
        public string Polyline { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Leg {\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TravelTime: ").Append(TravelTime).Append("\n");
            sb.Append("  TrafficDelay: ").Append(TrafficDelay).Append("\n");
            sb.Append("  Violated: ").Append(Violated).Append("\n");
            sb.Append("  TollCosts: ").Append(TollCosts).Append("\n");
            sb.Append("  Polyline: ").Append(Polyline).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Leg);
        }
        /// <summary>
        /// Returns true if Leg instances are equal
        /// </summary>
        /// <param name="input">Instance of Leg to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Leg input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Distance == input.Distance ||
                    this.Distance.Equals(input.Distance)
                ) && 
                (
                    this.TravelTime == input.TravelTime ||
                    this.TravelTime.Equals(input.TravelTime)
                ) && 
                (
                    this.TrafficDelay == input.TrafficDelay ||
                    this.TrafficDelay.Equals(input.TrafficDelay)
                ) && 
                (
                    this.Violated == input.Violated ||
                    this.Violated.Equals(input.Violated)
                ) && 
                (
                    this.TollCosts == input.TollCosts ||
                    (this.TollCosts != null &&
                    this.TollCosts.Equals(input.TollCosts))
                ) && 
                (
                    this.Polyline == input.Polyline ||
                    (this.Polyline != null &&
                    this.Polyline.Equals(input.Polyline))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                hashCode = (hashCode * 59) + this.TravelTime.GetHashCode();
                hashCode = (hashCode * 59) + this.TrafficDelay.GetHashCode();
                hashCode = (hashCode * 59) + this.Violated.GetHashCode();
                if (this.TollCosts != null)
                {
                    hashCode = (hashCode * 59) + this.TollCosts.GetHashCode();
                }
                if (this.Polyline != null)
                {
                    hashCode = (hashCode * 59) + this.Polyline.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Distance (int) minimum
            if (this.Distance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Distance, must be a value greater than or equal to 0.", new [] { "Distance" });
            }
            // TravelTime (int) minimum
            if (this.TravelTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TravelTime, must be a value greater than or equal to 0.", new [] { "TravelTime" });
            }
            // TrafficDelay (int) minimum
            if (this.TrafficDelay < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TrafficDelay, must be a value greater than or equal to 0.", new [] { "TrafficDelay" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Location
    /// </summary>
    [DataContract(Name = "Location")]
    public partial class Location : IEquatable<Location>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Location" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Location() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Location" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        public Location(double latitude = default(double), double longitude = default(double))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Location {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Location);
        }
        /// <summary>
        /// Returns true if Location instances are equal
        /// </summary>
        /// <param name="input">Instance of Location to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Location input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Locations
    /// </summary>
    [DataContract(Name = "Locations")]
    public partial class Locations : IEquatable<Locations>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Locations" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Locations() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Locations" /> class.
        /// </summary>
        /// <param name="varLocations">varLocations (required).</param>
        public Locations(List<Location> varLocations = default(List<Location>))
        {
            // to ensure "varLocations" is required (not null)
            if (varLocations == null)
            {
                throw new ArgumentNullException("varLocations is a required property for Locations and cannot be null");
            }
            this.VarLocations = varLocations;
        }
        /// <summary>
        /// Gets or Sets VarLocations
        /// </summary>
        [DataMember(Name = "locations", IsRequired = true, EmitDefaultValue = true)]
        public List<Location> VarLocations { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Locations {\n");
            sb.Append("  VarLocations: ").Append(VarLocations).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Locations);
        }
        /// <summary>
        /// Returns true if Locations instances are equal
        /// </summary>
        /// <param name="input">Instance of Locations to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Locations input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.VarLocations == input.VarLocations ||
                    this.VarLocations != null &&
                    input.VarLocations != null &&
                    this.VarLocations.SequenceEqual(input.VarLocations)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.VarLocations != null)
                {
                    hashCode = (hashCode * 59) + this.VarLocations.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines LowEmissionZoneTypes
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum LowEmissionZoneTypes
    {
        /// <summary>
        /// Enum DE_GREEN for value: DE_GREEN
        /// </summary>
        [EnumMember(Value = "DE_GREEN")]
        DE_GREEN = 1,
        /// <summary>
        /// Enum DE_YELLOW for value: DE_YELLOW
        /// </summary>
        [EnumMember(Value = "DE_YELLOW")]
        DE_YELLOW = 2,
        /// <summary>
        /// Enum DE_RED for value: DE_RED
        /// </summary>
        [EnumMember(Value = "DE_RED")]
        DE_RED = 3,
        /// <summary>
        /// Enum DE_NONE for value: DE_NONE
        /// </summary>
        [EnumMember(Value = "DE_NONE")]
        DE_NONE = 4
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when the driver has to perform a maneuver, e.g. to turn or to enter a roundabout. Requires _MANEUVER_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "ManeuverEvent")]
    public partial class ManeuverEvent : IEquatable<ManeuverEvent>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name = "type", IsRequired = true, EmitDefaultValue = true)]
        public ManeuverType Type { get; set; }
        /// <summary>
        /// Gets or Sets CombinedTransportType
        /// </summary>
        [DataMember(Name = "combinedTransportType", EmitDefaultValue = false)]
        public CombinedTransportType? CombinedTransportType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ManeuverEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ManeuverEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ManeuverEvent" /> class.
        /// </summary>
        /// <param name="type">type (required).</param>
        /// <param name="relativeDirection">The direction of the outgoing road relative to continuing in the same direction as the incoming road (clockwise)..</param>
        /// <param name="absoluteDirection">The absolute direction of the outgoing road (clockwise). North represents 0 degrees..</param>
        /// <param name="description">A descriptive text for the current maneuver. The language can be specified by the parameter **options[language]**. A warning with **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ and the actual language is returned when the requested language is not available. Geographical names such as town and road names are always given in the local language. (required).</param>
        /// <param name="roadAhead">roadAhead.</param>
        /// <param name="directionSignText">The city names and road numbers on a signpost at the current location to follow for the current maneuver. Empty if no signpost is present or the data is not available..</param>
        /// <param name="exitNumber">The number of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is _CHANGE_ or _EXIT_. Empty if the data does not contain an exit number..</param>
        /// <param name="exitName">The name of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is _CHANGE_ or _EXIT_. Empty if the data does not contain an exit name..</param>
        /// <param name="roundaboutExit">The exit number at a roundabout. Only drivable roads are counted. Only present if the maneuver type is _TAKE\\_ROUNDABOUT_..</param>
        /// <param name="combinedTransportName">The name of the combined transport to take a the current location. Only present if the maneuver type is _TAKE\\_COMBINED\\_TRANSPORT_..</param>
        /// <param name="combinedTransportType">combinedTransportType.</param>
        /// <param name="crossingRoadName">The name of the crossing road at which a U-turn has to be made. Only present if the maneuver type is _MAKE\\_U\\_TURN_ and if the U-turn takes place at a crossing..</param>
        public ManeuverEvent(ManeuverType type = default(ManeuverType), int relativeDirection = default(int), int absoluteDirection = default(int), string description = default(string), RoadAhead roadAhead = default(RoadAhead), string directionSignText = default(string), string exitNumber = default(string), string exitName = default(string), int roundaboutExit = default(int), string combinedTransportName = default(string), CombinedTransportType? combinedTransportType = default(CombinedTransportType?), string crossingRoadName = default(string))
        {
            this.Type = type;
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for ManeuverEvent and cannot be null");
            }
            this.Description = description;
            this.RelativeDirection = relativeDirection;
            this.AbsoluteDirection = absoluteDirection;
            this.RoadAhead = roadAhead;
            this.DirectionSignText = directionSignText;
            this.ExitNumber = exitNumber;
            this.ExitName = exitName;
            this.RoundaboutExit = roundaboutExit;
            this.CombinedTransportName = combinedTransportName;
            this.CombinedTransportType = combinedTransportType;
            this.CrossingRoadName = crossingRoadName;
        }
        /// <summary>
        /// The direction of the outgoing road relative to continuing in the same direction as the incoming road (clockwise).
        /// </summary>
        /// <value>The direction of the outgoing road relative to continuing in the same direction as the incoming road (clockwise).</value>
        [DataMember(Name = "relativeDirection", EmitDefaultValue = false)]
        public int RelativeDirection { get; set; }
        /// <summary>
        /// The absolute direction of the outgoing road (clockwise). North represents 0 degrees.
        /// </summary>
        /// <value>The absolute direction of the outgoing road (clockwise). North represents 0 degrees.</value>
        [DataMember(Name = "absoluteDirection", EmitDefaultValue = false)]
        public int AbsoluteDirection { get; set; }
        /// <summary>
        /// A descriptive text for the current maneuver. The language can be specified by the parameter **options[language]**. A warning with **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ and the actual language is returned when the requested language is not available. Geographical names such as town and road names are always given in the local language.
        /// </summary>
        /// <value>A descriptive text for the current maneuver. The language can be specified by the parameter **options[language]**. A warning with **warningCode** _ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE_ and the actual language is returned when the requested language is not available. Geographical names such as town and road names are always given in the local language.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = true)]
        public string Description { get; set; }
        /// <summary>
        /// Gets or Sets RoadAhead
        /// </summary>
        [DataMember(Name = "roadAhead", EmitDefaultValue = false)]
        public RoadAhead RoadAhead { get; set; }
        /// <summary>
        /// The city names and road numbers on a signpost at the current location to follow for the current maneuver. Empty if no signpost is present or the data is not available.
        /// </summary>
        /// <value>The city names and road numbers on a signpost at the current location to follow for the current maneuver. Empty if no signpost is present or the data is not available.</value>
        [DataMember(Name = "directionSignText", EmitDefaultValue = false)]
        public string DirectionSignText { get; set; }
        /// <summary>
        /// The number of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is _CHANGE_ or _EXIT_. Empty if the data does not contain an exit number.
        /// </summary>
        /// <value>The number of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is _CHANGE_ or _EXIT_. Empty if the data does not contain an exit number.</value>
        [DataMember(Name = "exitNumber", EmitDefaultValue = false)]
        public string ExitNumber { get; set; }
        /// <summary>
        /// The name of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is _CHANGE_ or _EXIT_. Empty if the data does not contain an exit name.
        /// </summary>
        /// <value>The name of an exit or interchange of a highway or a freeway-like road. Only present if the maneuver type is _CHANGE_ or _EXIT_. Empty if the data does not contain an exit name.</value>
        [DataMember(Name = "exitName", EmitDefaultValue = false)]
        public string ExitName { get; set; }
        /// <summary>
        /// The exit number at a roundabout. Only drivable roads are counted. Only present if the maneuver type is _TAKE\\_ROUNDABOUT_.
        /// </summary>
        /// <value>The exit number at a roundabout. Only drivable roads are counted. Only present if the maneuver type is _TAKE\\_ROUNDABOUT_.</value>
        [DataMember(Name = "roundaboutExit", EmitDefaultValue = false)]
        public int RoundaboutExit { get; set; }
        /// <summary>
        /// The name of the combined transport to take a the current location. Only present if the maneuver type is _TAKE\\_COMBINED\\_TRANSPORT_.
        /// </summary>
        /// <value>The name of the combined transport to take a the current location. Only present if the maneuver type is _TAKE\\_COMBINED\\_TRANSPORT_.</value>
        [DataMember(Name = "combinedTransportName", EmitDefaultValue = false)]
        public string CombinedTransportName { get; set; }
        /// <summary>
        /// The name of the crossing road at which a U-turn has to be made. Only present if the maneuver type is _MAKE\\_U\\_TURN_ and if the U-turn takes place at a crossing.
        /// </summary>
        /// <value>The name of the crossing road at which a U-turn has to be made. Only present if the maneuver type is _MAKE\\_U\\_TURN_ and if the U-turn takes place at a crossing.</value>
        [DataMember(Name = "crossingRoadName", EmitDefaultValue = false)]
        public string CrossingRoadName { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ManeuverEvent {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  RelativeDirection: ").Append(RelativeDirection).Append("\n");
            sb.Append("  AbsoluteDirection: ").Append(AbsoluteDirection).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  RoadAhead: ").Append(RoadAhead).Append("\n");
            sb.Append("  DirectionSignText: ").Append(DirectionSignText).Append("\n");
            sb.Append("  ExitNumber: ").Append(ExitNumber).Append("\n");
            sb.Append("  ExitName: ").Append(ExitName).Append("\n");
            sb.Append("  RoundaboutExit: ").Append(RoundaboutExit).Append("\n");
            sb.Append("  CombinedTransportName: ").Append(CombinedTransportName).Append("\n");
            sb.Append("  CombinedTransportType: ").Append(CombinedTransportType).Append("\n");
            sb.Append("  CrossingRoadName: ").Append(CrossingRoadName).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ManeuverEvent);
        }
        /// <summary>
        /// Returns true if ManeuverEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of ManeuverEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ManeuverEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Type == input.Type ||
                    this.Type.Equals(input.Type)
                ) && 
                (
                    this.RelativeDirection == input.RelativeDirection ||
                    this.RelativeDirection.Equals(input.RelativeDirection)
                ) && 
                (
                    this.AbsoluteDirection == input.AbsoluteDirection ||
                    this.AbsoluteDirection.Equals(input.AbsoluteDirection)
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.RoadAhead == input.RoadAhead ||
                    (this.RoadAhead != null &&
                    this.RoadAhead.Equals(input.RoadAhead))
                ) && 
                (
                    this.DirectionSignText == input.DirectionSignText ||
                    (this.DirectionSignText != null &&
                    this.DirectionSignText.Equals(input.DirectionSignText))
                ) && 
                (
                    this.ExitNumber == input.ExitNumber ||
                    (this.ExitNumber != null &&
                    this.ExitNumber.Equals(input.ExitNumber))
                ) && 
                (
                    this.ExitName == input.ExitName ||
                    (this.ExitName != null &&
                    this.ExitName.Equals(input.ExitName))
                ) && 
                (
                    this.RoundaboutExit == input.RoundaboutExit ||
                    this.RoundaboutExit.Equals(input.RoundaboutExit)
                ) && 
                (
                    this.CombinedTransportName == input.CombinedTransportName ||
                    (this.CombinedTransportName != null &&
                    this.CombinedTransportName.Equals(input.CombinedTransportName))
                ) && 
                (
                    this.CombinedTransportType == input.CombinedTransportType ||
                    this.CombinedTransportType.Equals(input.CombinedTransportType)
                ) && 
                (
                    this.CrossingRoadName == input.CrossingRoadName ||
                    (this.CrossingRoadName != null &&
                    this.CrossingRoadName.Equals(input.CrossingRoadName))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Type.GetHashCode();
                hashCode = (hashCode * 59) + this.RelativeDirection.GetHashCode();
                hashCode = (hashCode * 59) + this.AbsoluteDirection.GetHashCode();
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.RoadAhead != null)
                {
                    hashCode = (hashCode * 59) + this.RoadAhead.GetHashCode();
                }
                if (this.DirectionSignText != null)
                {
                    hashCode = (hashCode * 59) + this.DirectionSignText.GetHashCode();
                }
                if (this.ExitNumber != null)
                {
                    hashCode = (hashCode * 59) + this.ExitNumber.GetHashCode();
                }
                if (this.ExitName != null)
                {
                    hashCode = (hashCode * 59) + this.ExitName.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RoundaboutExit.GetHashCode();
                if (this.CombinedTransportName != null)
                {
                    hashCode = (hashCode * 59) + this.CombinedTransportName.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.CombinedTransportType.GetHashCode();
                if (this.CrossingRoadName != null)
                {
                    hashCode = (hashCode * 59) + this.CrossingRoadName.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // RelativeDirection (int) maximum
            if (this.RelativeDirection > (int)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RelativeDirection, must be a value less than or equal to 180.", new [] { "RelativeDirection" });
            }
            // RelativeDirection (int) minimum
            if (this.RelativeDirection < (int)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RelativeDirection, must be a value greater than or equal to -180.", new [] { "RelativeDirection" });
            }
            // AbsoluteDirection (int) maximum
            if (this.AbsoluteDirection > (int)360)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AbsoluteDirection, must be a value less than or equal to 360.", new [] { "AbsoluteDirection" });
            }
            // AbsoluteDirection (int) minimum
            if (this.AbsoluteDirection < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AbsoluteDirection, must be a value greater than or equal to 0.", new [] { "AbsoluteDirection" });
            }
            // RoundaboutExit (int) minimum
            if (this.RoundaboutExit < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RoundaboutExit, must be a value greater than or equal to 0.", new [] { "RoundaboutExit" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Describes the type of maneuver to execute.     * &#x60;START&#x60; - Departure at an on-road waypoint.     * &#x60;START_LEFT&#x60; - Departure at an off-road waypoint to begin the route heading left.     * &#x60;START_RIGHT&#x60; - Departure at an off-road waypoint to begin the route heading right.     * &#x60;ARRIVE&#x60; - Arrival at an on-road waypoint.     * &#x60;ARRIVE_LEFT&#x60; - Arrival at an off-road waypoint if the waypoint is on the left.     * &#x60;ARRIVE_RIGHT&#x60; - Arrival at an off-road waypoint if the waypoint is on the right.     * &#x60;CONTINUE&#x60; - Follow the current road, usually when the road type changes although the road goes straight.     * &#x60;KEEP_STRAIGHT&#x60; - Stay on the straight lane, usually in fork-shaped intersections with more than two spikes.     * &#x60;KEEP_LEFT&#x60; - Keep left or to take the left lane, usually in Y-shaped intersections.     * &#x60;KEEP_RIGHT&#x60; - Keep right or to take the right lane, usually  in Y-shaped intersections.     * &#x60;TURN_HALF_LEFT&#x60; - Turn half left at a crossing where at least one additional trailing road exists,  usually at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_LEFT&#x60; - Turn left at a crossing where at least one additional trailing road exists, usually  at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_SHARP_LEFT&#x60; - Turn sharp left at a crossing where at least one additional trailing road exists, usually   at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_HALF_RIGHT&#x60; - Turn half right at a crossing where at least one additional trailing road exists, usually   at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_RIGHT&#x60; - Turn right at a crossing where at least one additional trailing road exists, usually  at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_SHARP_RIGHT&#x60; - Turn sharp right at a crossing where at least one additional trailing road exists, usually   at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;MAKE_U_TURN&#x60; - Make a U-turn, either at the same road or at structurally separated roads. The **relativeDirection**   indicates whether to turn left or right.     * &#x60;TAKE_ROUNDABOUT_LEFT&#x60; - Enter a roundabout to the left and leave it at the given **roundaboutExit**.   Only drivable roads of the roundabout are counted.     * &#x60;TAKE_ROUNDABOUT_RIGHT&#x60; - Enter a roundabout to the right and leave it at the given **roundaboutExit**.   Only drivable roads of the roundabout are counted.     * &#x60;TAKE_COMBINED_TRANSPORT&#x60; - Take boat (ferry) or rail (train or rail shuttle) connection.  * &#x60;ENTER&#x60; - Enter a highway/freeway/major road straight.     * &#x60;ENTER_LEFT&#x60; - Enter a highway/freeway/major road to the left.     * &#x60;ENTER_RIGHT&#x60; - Enter a highway/freeway/major road to the right.     * &#x60;EXIT&#x60; - Leave a highway/freeway/major road straight.     * &#x60;EXIT_LEFT&#x60; - Leave a highway/freeway/major road to the left.     * &#x60;EXIT_RIGHT&#x60; - Leave a highway/freeway/major road to the right.     * &#x60;CHANGE&#x60; - Change straight to another highway/freeway at an interchange.     * &#x60;CHANGE_LEFT&#x60; - Change to the left to another highway/freeway at an interchange.     * &#x60;CHANGE_RIGHT&#x60; - Change to the right to another highway/freeway at an interchange.
    /// </summary>
    /// <value>Describes the type of maneuver to execute.     * &#x60;START&#x60; - Departure at an on-road waypoint.     * &#x60;START_LEFT&#x60; - Departure at an off-road waypoint to begin the route heading left.     * &#x60;START_RIGHT&#x60; - Departure at an off-road waypoint to begin the route heading right.     * &#x60;ARRIVE&#x60; - Arrival at an on-road waypoint.     * &#x60;ARRIVE_LEFT&#x60; - Arrival at an off-road waypoint if the waypoint is on the left.     * &#x60;ARRIVE_RIGHT&#x60; - Arrival at an off-road waypoint if the waypoint is on the right.     * &#x60;CONTINUE&#x60; - Follow the current road, usually when the road type changes although the road goes straight.     * &#x60;KEEP_STRAIGHT&#x60; - Stay on the straight lane, usually in fork-shaped intersections with more than two spikes.     * &#x60;KEEP_LEFT&#x60; - Keep left or to take the left lane, usually in Y-shaped intersections.     * &#x60;KEEP_RIGHT&#x60; - Keep right or to take the right lane, usually  in Y-shaped intersections.     * &#x60;TURN_HALF_LEFT&#x60; - Turn half left at a crossing where at least one additional trailing road exists,  usually at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_LEFT&#x60; - Turn left at a crossing where at least one additional trailing road exists, usually  at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_SHARP_LEFT&#x60; - Turn sharp left at a crossing where at least one additional trailing road exists, usually   at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_HALF_RIGHT&#x60; - Turn half right at a crossing where at least one additional trailing road exists, usually   at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_RIGHT&#x60; - Turn right at a crossing where at least one additional trailing road exists, usually  at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;TURN_SHARP_RIGHT&#x60; - Turn sharp right at a crossing where at least one additional trailing road exists, usually   at T- or X-shaped crossings on urban or country roads. Even if the name of the turning road does not change a maneuver will be created.     * &#x60;MAKE_U_TURN&#x60; - Make a U-turn, either at the same road or at structurally separated roads. The **relativeDirection**   indicates whether to turn left or right.     * &#x60;TAKE_ROUNDABOUT_LEFT&#x60; - Enter a roundabout to the left and leave it at the given **roundaboutExit**.   Only drivable roads of the roundabout are counted.     * &#x60;TAKE_ROUNDABOUT_RIGHT&#x60; - Enter a roundabout to the right and leave it at the given **roundaboutExit**.   Only drivable roads of the roundabout are counted.     * &#x60;TAKE_COMBINED_TRANSPORT&#x60; - Take boat (ferry) or rail (train or rail shuttle) connection.  * &#x60;ENTER&#x60; - Enter a highway/freeway/major road straight.     * &#x60;ENTER_LEFT&#x60; - Enter a highway/freeway/major road to the left.     * &#x60;ENTER_RIGHT&#x60; - Enter a highway/freeway/major road to the right.     * &#x60;EXIT&#x60; - Leave a highway/freeway/major road straight.     * &#x60;EXIT_LEFT&#x60; - Leave a highway/freeway/major road to the left.     * &#x60;EXIT_RIGHT&#x60; - Leave a highway/freeway/major road to the right.     * &#x60;CHANGE&#x60; - Change straight to another highway/freeway at an interchange.     * &#x60;CHANGE_LEFT&#x60; - Change to the left to another highway/freeway at an interchange.     * &#x60;CHANGE_RIGHT&#x60; - Change to the right to another highway/freeway at an interchange.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ManeuverType
    {
        /// <summary>
        /// Enum START for value: START
        /// </summary>
        [EnumMember(Value = "START")]
        START = 1,
        /// <summary>
        /// Enum START_LEFT for value: START_LEFT
        /// </summary>
        [EnumMember(Value = "START_LEFT")]
        START_LEFT = 2,
        /// <summary>
        /// Enum START_RIGHT for value: START_RIGHT
        /// </summary>
        [EnumMember(Value = "START_RIGHT")]
        START_RIGHT = 3,
        /// <summary>
        /// Enum ARRIVE for value: ARRIVE
        /// </summary>
        [EnumMember(Value = "ARRIVE")]
        ARRIVE = 4,
        /// <summary>
        /// Enum ARRIVE_LEFT for value: ARRIVE_LEFT
        /// </summary>
        [EnumMember(Value = "ARRIVE_LEFT")]
        ARRIVE_LEFT = 5,
        /// <summary>
        /// Enum ARRIVE_RIGHT for value: ARRIVE_RIGHT
        /// </summary>
        [EnumMember(Value = "ARRIVE_RIGHT")]
        ARRIVE_RIGHT = 6,
        /// <summary>
        /// Enum CONTINUE for value: CONTINUE
        /// </summary>
        [EnumMember(Value = "CONTINUE")]
        CONTINUE = 7,
        /// <summary>
        /// Enum KEEP_STRAIGHT for value: KEEP_STRAIGHT
        /// </summary>
        [EnumMember(Value = "KEEP_STRAIGHT")]
        KEEP_STRAIGHT = 8,
        /// <summary>
        /// Enum KEEP_LEFT for value: KEEP_LEFT
        /// </summary>
        [EnumMember(Value = "KEEP_LEFT")]
        KEEP_LEFT = 9,
        /// <summary>
        /// Enum KEEP_RIGHT for value: KEEP_RIGHT
        /// </summary>
        [EnumMember(Value = "KEEP_RIGHT")]
        KEEP_RIGHT = 10,
        /// <summary>
        /// Enum TURN_HALF_LEFT for value: TURN_HALF_LEFT
        /// </summary>
        [EnumMember(Value = "TURN_HALF_LEFT")]
        TURN_HALF_LEFT = 11,
        /// <summary>
        /// Enum TURN_LEFT for value: TURN_LEFT
        /// </summary>
        [EnumMember(Value = "TURN_LEFT")]
        TURN_LEFT = 12,
        /// <summary>
        /// Enum TURN_SHARP_LEFT for value: TURN_SHARP_LEFT
        /// </summary>
        [EnumMember(Value = "TURN_SHARP_LEFT")]
        TURN_SHARP_LEFT = 13,
        /// <summary>
        /// Enum TURN_HALF_RIGHT for value: TURN_HALF_RIGHT
        /// </summary>
        [EnumMember(Value = "TURN_HALF_RIGHT")]
        TURN_HALF_RIGHT = 14,
        /// <summary>
        /// Enum TURN_RIGHT for value: TURN_RIGHT
        /// </summary>
        [EnumMember(Value = "TURN_RIGHT")]
        TURN_RIGHT = 15,
        /// <summary>
        /// Enum TURN_SHARP_RIGHT for value: TURN_SHARP_RIGHT
        /// </summary>
        [EnumMember(Value = "TURN_SHARP_RIGHT")]
        TURN_SHARP_RIGHT = 16,
        /// <summary>
        /// Enum MAKE_U_TURN for value: MAKE_U_TURN
        /// </summary>
        [EnumMember(Value = "MAKE_U_TURN")]
        MAKE_U_TURN = 17,
        /// <summary>
        /// Enum TAKE_ROUNDABOUT_LEFT for value: TAKE_ROUNDABOUT_LEFT
        /// </summary>
        [EnumMember(Value = "TAKE_ROUNDABOUT_LEFT")]
        TAKE_ROUNDABOUT_LEFT = 18,
        /// <summary>
        /// Enum TAKE_ROUNDABOUT_RIGHT for value: TAKE_ROUNDABOUT_RIGHT
        /// </summary>
        [EnumMember(Value = "TAKE_ROUNDABOUT_RIGHT")]
        TAKE_ROUNDABOUT_RIGHT = 19,
        /// <summary>
        /// Enum TAKE_COMBINED_TRANSPORT for value: TAKE_COMBINED_TRANSPORT
        /// </summary>
        [EnumMember(Value = "TAKE_COMBINED_TRANSPORT")]
        TAKE_COMBINED_TRANSPORT = 20,
        /// <summary>
        /// Enum ENTER for value: ENTER
        /// </summary>
        [EnumMember(Value = "ENTER")]
        ENTER = 21,
        /// <summary>
        /// Enum ENTER_LEFT for value: ENTER_LEFT
        /// </summary>
        [EnumMember(Value = "ENTER_LEFT")]
        ENTER_LEFT = 22,
        /// <summary>
        /// Enum ENTER_RIGHT for value: ENTER_RIGHT
        /// </summary>
        [EnumMember(Value = "ENTER_RIGHT")]
        ENTER_RIGHT = 23,
        /// <summary>
        /// Enum EXIT for value: EXIT
        /// </summary>
        [EnumMember(Value = "EXIT")]
        EXIT = 24,
        /// <summary>
        /// Enum EXIT_LEFT for value: EXIT_LEFT
        /// </summary>
        [EnumMember(Value = "EXIT_LEFT")]
        EXIT_LEFT = 25,
        /// <summary>
        /// Enum EXIT_RIGHT for value: EXIT_RIGHT
        /// </summary>
        [EnumMember(Value = "EXIT_RIGHT")]
        EXIT_RIGHT = 26,
        /// <summary>
        /// Enum CHANGE for value: CHANGE
        /// </summary>
        [EnumMember(Value = "CHANGE")]
        CHANGE = 27,
        /// <summary>
        /// Enum CHANGE_LEFT for value: CHANGE_LEFT
        /// </summary>
        [EnumMember(Value = "CHANGE_LEFT")]
        CHANGE_LEFT = 28,
        /// <summary>
        /// Enum CHANGE_RIGHT for value: CHANGE_RIGHT
        /// </summary>
        [EnumMember(Value = "CHANGE_RIGHT")]
        CHANGE_RIGHT = 29
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// A _manipulate-route waypoint_ will not actually be reached but it influences the route course, so that the route passes an area defined by the given radius. This waypoint will not appear as a waypoint event in the response and may not be used as start and destination.
    /// </summary>
    [DataContract(Name = "ManipulateRouteWaypoint")]
    public partial class ManipulateRouteWaypoint : IEquatable<ManipulateRouteWaypoint>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ManipulateRouteWaypoint" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ManipulateRouteWaypoint() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ManipulateRouteWaypoint" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        /// <param name="radius">The radius [m] at which the waypoint has to be passed. (required).</param>
        public ManipulateRouteWaypoint(double latitude = default(double), double longitude = default(double), int radius = default(int))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
            this.Radius = radius;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// The radius [m] at which the waypoint has to be passed.
        /// </summary>
        /// <value>The radius [m] at which the waypoint has to be passed.</value>
        [DataMember(Name = "radius", IsRequired = true, EmitDefaultValue = true)]
        public int Radius { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ManipulateRouteWaypoint {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("  Radius: ").Append(Radius).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ManipulateRouteWaypoint);
        }
        /// <summary>
        /// Returns true if ManipulateRouteWaypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of ManipulateRouteWaypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ManipulateRouteWaypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                ) && 
                (
                    this.Radius == input.Radius ||
                    this.Radius.Equals(input.Radius)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Radius.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            // Radius (int) minimum
            if (this.Radius < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Radius, must be a value greater than or equal to 1.", new [] { "Radius" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// MonetaryCostOptions
    /// </summary>
    [DataContract(Name = "MonetaryCostOptions")]
    public partial class MonetaryCostOptions : IEquatable<MonetaryCostOptions>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MonetaryCostOptions" /> class.
        /// </summary>
        /// <param name="costPerKilometer">Specifies the cost per kilometer. This value can contain the cost from the energy consumption, but it also possible to define the energy costs using **monetaryCostOptions[costPerKwh]** and **monetaryCostOptions[costPerFuelUnit]**. If it is not specified the default value depends on the used **profile**. The default value of the profile can change at any time..</param>
        /// <param name="workingCostPerHour">Specifies the cost per hour. It is not applied to service, break or rest periods. If it is not specified the default value depends on the used **profile**. The default value of the profile can change at any time..</param>
        /// <param name="costPerKwh">Specifies the cost per kilowatt hour. Only relevant for **vehicle[engineType]** _ELECTRIC_ and _HYBRID_..</param>
        /// <param name="costPerFuelUnit">Specifies the cost per fuel unit (per liter Diesel or per kg CNG). Only used for **vehicle[engineType]** _COMBUSTION_ and _HYBRID_..</param>
        public MonetaryCostOptions(double? costPerKilometer = default(double?), double? workingCostPerHour = default(double?), double? costPerKwh = default(double?), double? costPerFuelUnit = default(double?))
        {
            this.CostPerKilometer = costPerKilometer;
            this.WorkingCostPerHour = workingCostPerHour;
            this.CostPerKwh = costPerKwh;
            this.CostPerFuelUnit = costPerFuelUnit;
        }
        /// <summary>
        /// Specifies the cost per kilometer. This value can contain the cost from the energy consumption, but it also possible to define the energy costs using **monetaryCostOptions[costPerKwh]** and **monetaryCostOptions[costPerFuelUnit]**. If it is not specified the default value depends on the used **profile**. The default value of the profile can change at any time.
        /// </summary>
        /// <value>Specifies the cost per kilometer. This value can contain the cost from the energy consumption, but it also possible to define the energy costs using **monetaryCostOptions[costPerKwh]** and **monetaryCostOptions[costPerFuelUnit]**. If it is not specified the default value depends on the used **profile**. The default value of the profile can change at any time.</value>
        [DataMember(Name = "costPerKilometer", EmitDefaultValue = true)]
        public double? CostPerKilometer { get; set; }
        /// <summary>
        /// Specifies the cost per hour. It is not applied to service, break or rest periods. If it is not specified the default value depends on the used **profile**. The default value of the profile can change at any time.
        /// </summary>
        /// <value>Specifies the cost per hour. It is not applied to service, break or rest periods. If it is not specified the default value depends on the used **profile**. The default value of the profile can change at any time.</value>
        [DataMember(Name = "workingCostPerHour", EmitDefaultValue = true)]
        public double? WorkingCostPerHour { get; set; }
        /// <summary>
        /// Specifies the cost per kilowatt hour. Only relevant for **vehicle[engineType]** _ELECTRIC_ and _HYBRID_.
        /// </summary>
        /// <value>Specifies the cost per kilowatt hour. Only relevant for **vehicle[engineType]** _ELECTRIC_ and _HYBRID_.</value>
        [DataMember(Name = "costPerKwh", EmitDefaultValue = true)]
        public double? CostPerKwh { get; set; }
        /// <summary>
        /// Specifies the cost per fuel unit (per liter Diesel or per kg CNG). Only used for **vehicle[engineType]** _COMBUSTION_ and _HYBRID_.
        /// </summary>
        /// <value>Specifies the cost per fuel unit (per liter Diesel or per kg CNG). Only used for **vehicle[engineType]** _COMBUSTION_ and _HYBRID_.</value>
        [DataMember(Name = "costPerFuelUnit", EmitDefaultValue = true)]
        public double? CostPerFuelUnit { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MonetaryCostOptions {\n");
            sb.Append("  CostPerKilometer: ").Append(CostPerKilometer).Append("\n");
            sb.Append("  WorkingCostPerHour: ").Append(WorkingCostPerHour).Append("\n");
            sb.Append("  CostPerKwh: ").Append(CostPerKwh).Append("\n");
            sb.Append("  CostPerFuelUnit: ").Append(CostPerFuelUnit).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MonetaryCostOptions);
        }
        /// <summary>
        /// Returns true if MonetaryCostOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of MonetaryCostOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MonetaryCostOptions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.CostPerKilometer == input.CostPerKilometer ||
                    (this.CostPerKilometer != null &&
                    this.CostPerKilometer.Equals(input.CostPerKilometer))
                ) && 
                (
                    this.WorkingCostPerHour == input.WorkingCostPerHour ||
                    (this.WorkingCostPerHour != null &&
                    this.WorkingCostPerHour.Equals(input.WorkingCostPerHour))
                ) && 
                (
                    this.CostPerKwh == input.CostPerKwh ||
                    (this.CostPerKwh != null &&
                    this.CostPerKwh.Equals(input.CostPerKwh))
                ) && 
                (
                    this.CostPerFuelUnit == input.CostPerFuelUnit ||
                    (this.CostPerFuelUnit != null &&
                    this.CostPerFuelUnit.Equals(input.CostPerFuelUnit))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CostPerKilometer != null)
                {
                    hashCode = (hashCode * 59) + this.CostPerKilometer.GetHashCode();
                }
                if (this.WorkingCostPerHour != null)
                {
                    hashCode = (hashCode * 59) + this.WorkingCostPerHour.GetHashCode();
                }
                if (this.CostPerKwh != null)
                {
                    hashCode = (hashCode * 59) + this.CostPerKwh.GetHashCode();
                }
                if (this.CostPerFuelUnit != null)
                {
                    hashCode = (hashCode * 59) + this.CostPerFuelUnit.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // CostPerKilometer (double?) minimum
            if (this.CostPerKilometer < (double?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CostPerKilometer, must be a value greater than or equal to 0.", new [] { "CostPerKilometer" });
            }
            // WorkingCostPerHour (double?) minimum
            if (this.WorkingCostPerHour < (double?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for WorkingCostPerHour, must be a value greater than or equal to 0.", new [] { "WorkingCostPerHour" });
            }
            // CostPerKwh (double?) minimum
            if (this.CostPerKwh < (double?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CostPerKwh, must be a value greater than or equal to 0.", new [] { "CostPerKwh" });
            }
            // CostPerFuelUnit (double?) minimum
            if (this.CostPerFuelUnit < (double?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CostPerFuelUnit, must be a value greater than or equal to 0.", new [] { "CostPerFuelUnit" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Provides an overview of the costs of the route.   Requires the result _MONETARY_COSTS_ to be requested.
    /// </summary>
    [DataContract(Name = "MonetaryCosts")]
    public partial class MonetaryCosts : IEquatable<MonetaryCosts>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MonetaryCosts" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected MonetaryCosts() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MonetaryCosts" /> class.
        /// </summary>
        /// <param name="currency">The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). (required).</param>
        /// <param name="totalCost">The total monetary cost of the route. (required).</param>
        /// <param name="distanceCost">The distance cost based on the **monetaryCostOptions[costPerKilometer]** and the driving distance. (required).</param>
        /// <param name="workingTimeCost">The working time cost based on **monetaryCostOptions[costPerWorkingHour]** and the driving time. Break, service and rest times are not considered. (required).</param>
        /// <param name="energyCost">The energy cost based on the vehicle&#39;s consumption and the corresponding cost parameters. (required).</param>
        /// <param name="tollCost">The toll cost based on the route and the vehicle.   Toll prices do not include VAT.  (required).</param>
        public MonetaryCosts(string currency = default(string), double totalCost = default(double), double distanceCost = default(double), double workingTimeCost = default(double), double energyCost = default(double), double tollCost = default(double))
        {
            // to ensure "currency" is required (not null)
            if (currency == null)
            {
                throw new ArgumentNullException("currency is a required property for MonetaryCosts and cannot be null");
            }
            this.Currency = currency;
            this.TotalCost = totalCost;
            this.DistanceCost = distanceCost;
            this.WorkingTimeCost = workingTimeCost;
            this.EnergyCost = energyCost;
            this.TollCost = tollCost;
        }
        /// <summary>
        /// The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
        /// </summary>
        /// <value>The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).</value>
        [DataMember(Name = "currency", IsRequired = true, EmitDefaultValue = true)]
        public string Currency { get; set; }
        /// <summary>
        /// The total monetary cost of the route.
        /// </summary>
        /// <value>The total monetary cost of the route.</value>
        [DataMember(Name = "totalCost", IsRequired = true, EmitDefaultValue = true)]
        public double TotalCost { get; set; }
        /// <summary>
        /// The distance cost based on the **monetaryCostOptions[costPerKilometer]** and the driving distance.
        /// </summary>
        /// <value>The distance cost based on the **monetaryCostOptions[costPerKilometer]** and the driving distance.</value>
        [DataMember(Name = "distanceCost", IsRequired = true, EmitDefaultValue = true)]
        public double DistanceCost { get; set; }
        /// <summary>
        /// The working time cost based on **monetaryCostOptions[costPerWorkingHour]** and the driving time. Break, service and rest times are not considered.
        /// </summary>
        /// <value>The working time cost based on **monetaryCostOptions[costPerWorkingHour]** and the driving time. Break, service and rest times are not considered.</value>
        [DataMember(Name = "workingTimeCost", IsRequired = true, EmitDefaultValue = true)]
        public double WorkingTimeCost { get; set; }
        /// <summary>
        /// The energy cost based on the vehicle&#39;s consumption and the corresponding cost parameters.
        /// </summary>
        /// <value>The energy cost based on the vehicle&#39;s consumption and the corresponding cost parameters.</value>
        [DataMember(Name = "energyCost", IsRequired = true, EmitDefaultValue = true)]
        public double EnergyCost { get; set; }
        /// <summary>
        /// The toll cost based on the route and the vehicle.   Toll prices do not include VAT. 
        /// </summary>
        /// <value>The toll cost based on the route and the vehicle.   Toll prices do not include VAT. </value>
        [DataMember(Name = "tollCost", IsRequired = true, EmitDefaultValue = true)]
        public double TollCost { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MonetaryCosts {\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  TotalCost: ").Append(TotalCost).Append("\n");
            sb.Append("  DistanceCost: ").Append(DistanceCost).Append("\n");
            sb.Append("  WorkingTimeCost: ").Append(WorkingTimeCost).Append("\n");
            sb.Append("  EnergyCost: ").Append(EnergyCost).Append("\n");
            sb.Append("  TollCost: ").Append(TollCost).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MonetaryCosts);
        }
        /// <summary>
        /// Returns true if MonetaryCosts instances are equal
        /// </summary>
        /// <param name="input">Instance of MonetaryCosts to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MonetaryCosts input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                ) && 
                (
                    this.TotalCost == input.TotalCost ||
                    this.TotalCost.Equals(input.TotalCost)
                ) && 
                (
                    this.DistanceCost == input.DistanceCost ||
                    this.DistanceCost.Equals(input.DistanceCost)
                ) && 
                (
                    this.WorkingTimeCost == input.WorkingTimeCost ||
                    this.WorkingTimeCost.Equals(input.WorkingTimeCost)
                ) && 
                (
                    this.EnergyCost == input.EnergyCost ||
                    this.EnergyCost.Equals(input.EnergyCost)
                ) && 
                (
                    this.TollCost == input.TollCost ||
                    this.TollCost.Equals(input.TollCost)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Currency != null)
                {
                    hashCode = (hashCode * 59) + this.Currency.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TotalCost.GetHashCode();
                hashCode = (hashCode * 59) + this.DistanceCost.GetHashCode();
                hashCode = (hashCode * 59) + this.WorkingTimeCost.GetHashCode();
                hashCode = (hashCode * 59) + this.EnergyCost.GetHashCode();
                hashCode = (hashCode * 59) + this.TollCost.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Currency != null) {
                // Currency (string) pattern
                Regex regexCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
                if (!regexCurrency.Match(this.Currency).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Currency, must match a pattern of " + regexCurrency, new [] { "Currency" });
                }
            }
            // TotalCost (double) minimum
            if (this.TotalCost < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TotalCost, must be a value greater than or equal to 0.", new [] { "TotalCost" });
            }
            // DistanceCost (double) minimum
            if (this.DistanceCost < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DistanceCost, must be a value greater than or equal to 0.", new [] { "DistanceCost" });
            }
            // WorkingTimeCost (double) minimum
            if (this.WorkingTimeCost < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for WorkingTimeCost, must be a value greater than or equal to 0.", new [] { "WorkingTimeCost" });
            }
            // EnergyCost (double) minimum
            if (this.EnergyCost < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EnergyCost, must be a value greater than or equal to 0.", new [] { "EnergyCost" });
            }
            // TollCost (double) minimum
            if (this.TollCost < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TollCost, must be a value greater than or equal to 0.", new [] { "TollCost" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// An _off-road waypoint_ will be part of the route. The air-line connection between given and matched coordinates is included in the route polyline, distance and duration. Use this waypoint type to recalculate a route planned by the Route Optimization API.
    /// </summary>
    [DataContract(Name = "OffRoadWaypoint")]
    public partial class OffRoadWaypoint : IEquatable<OffRoadWaypoint>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OffRoadWaypoint" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected OffRoadWaypoint() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OffRoadWaypoint" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        /// <param name="roadAcess">roadAcess.</param>
        /// <param name="matchSideOfStreet">Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint. (default to false).</param>
        /// <param name="serviceTime">The service time [s] that is required at this waypoint, e.g. for pickup or delivery. (default to 0).</param>
        /// <param name="openingIntervals">The opening intervals at this waypoint, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the waypoint is always open. Service can only start within one of the opening intervals. If the vehicle does not arrive at a waypoint within an opening interval, a waiting time will be scheduled.  When using a multi-day **workingHoursPreset** this waiting time will usually be used for daily rests instead, in order to continue the route with a rested driver..</param>
        /// <param name="vehicleParameters">vehicleParameters.</param>
        public OffRoadWaypoint(double latitude = default(double), double longitude = default(double), RoadAccess roadAcess = default(RoadAccess), bool matchSideOfStreet = false, int serviceTime = 0, List<TimeInterval> openingIntervals = default(List<TimeInterval>), VehicleParametersAtWaypoint vehicleParameters = default(VehicleParametersAtWaypoint))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
            this.RoadAcess = roadAcess;
            this.MatchSideOfStreet = matchSideOfStreet;
            this.ServiceTime = serviceTime;
            this.OpeningIntervals = openingIntervals;
            this.VehicleParameters = vehicleParameters;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// Gets or Sets RoadAcess
        /// </summary>
        [DataMember(Name = "roadAcess", EmitDefaultValue = false)]
        public RoadAccess RoadAcess { get; set; }
        /// <summary>
        /// Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.
        /// </summary>
        /// <value>Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.</value>
        [DataMember(Name = "matchSideOfStreet", EmitDefaultValue = true)]
        public bool MatchSideOfStreet { get; set; }
        /// <summary>
        /// The service time [s] that is required at this waypoint, e.g. for pickup or delivery.
        /// </summary>
        /// <value>The service time [s] that is required at this waypoint, e.g. for pickup or delivery.</value>
        [DataMember(Name = "serviceTime", EmitDefaultValue = false)]
        public int ServiceTime { get; set; }
        /// <summary>
        /// The opening intervals at this waypoint, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the waypoint is always open. Service can only start within one of the opening intervals. If the vehicle does not arrive at a waypoint within an opening interval, a waiting time will be scheduled.  When using a multi-day **workingHoursPreset** this waiting time will usually be used for daily rests instead, in order to continue the route with a rested driver.
        /// </summary>
        /// <value>The opening intervals at this waypoint, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the waypoint is always open. Service can only start within one of the opening intervals. If the vehicle does not arrive at a waypoint within an opening interval, a waiting time will be scheduled.  When using a multi-day **workingHoursPreset** this waiting time will usually be used for daily rests instead, in order to continue the route with a rested driver.</value>
        [DataMember(Name = "openingIntervals", EmitDefaultValue = false)]
        public List<TimeInterval> OpeningIntervals { get; set; }
        /// <summary>
        /// Gets or Sets VehicleParameters
        /// </summary>
        [DataMember(Name = "vehicleParameters", EmitDefaultValue = false)]
        public VehicleParametersAtWaypoint VehicleParameters { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class OffRoadWaypoint {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("  RoadAcess: ").Append(RoadAcess).Append("\n");
            sb.Append("  MatchSideOfStreet: ").Append(MatchSideOfStreet).Append("\n");
            sb.Append("  ServiceTime: ").Append(ServiceTime).Append("\n");
            sb.Append("  OpeningIntervals: ").Append(OpeningIntervals).Append("\n");
            sb.Append("  VehicleParameters: ").Append(VehicleParameters).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OffRoadWaypoint);
        }
        /// <summary>
        /// Returns true if OffRoadWaypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of OffRoadWaypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OffRoadWaypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                ) && 
                (
                    this.RoadAcess == input.RoadAcess ||
                    (this.RoadAcess != null &&
                    this.RoadAcess.Equals(input.RoadAcess))
                ) && 
                (
                    this.MatchSideOfStreet == input.MatchSideOfStreet ||
                    this.MatchSideOfStreet.Equals(input.MatchSideOfStreet)
                ) && 
                (
                    this.ServiceTime == input.ServiceTime ||
                    this.ServiceTime.Equals(input.ServiceTime)
                ) && 
                (
                    this.OpeningIntervals == input.OpeningIntervals ||
                    this.OpeningIntervals != null &&
                    input.OpeningIntervals != null &&
                    this.OpeningIntervals.SequenceEqual(input.OpeningIntervals)
                ) && 
                (
                    this.VehicleParameters == input.VehicleParameters ||
                    (this.VehicleParameters != null &&
                    this.VehicleParameters.Equals(input.VehicleParameters))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                if (this.RoadAcess != null)
                {
                    hashCode = (hashCode * 59) + this.RoadAcess.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.MatchSideOfStreet.GetHashCode();
                hashCode = (hashCode * 59) + this.ServiceTime.GetHashCode();
                if (this.OpeningIntervals != null)
                {
                    hashCode = (hashCode * 59) + this.OpeningIntervals.GetHashCode();
                }
                if (this.VehicleParameters != null)
                {
                    hashCode = (hashCode * 59) + this.VehicleParameters.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            // ServiceTime (int) minimum
            if (this.ServiceTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ServiceTime, must be a value greater than or equal to 0.", new [] { "ServiceTime" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// An _on-road waypoint_ will be matched to the nearest possible road. The air-line connection between given and matched coordinates is not included in the route polyline, distance and duration.
    /// </summary>
    [DataContract(Name = "OnRoadWaypoint")]
    public partial class OnRoadWaypoint : IEquatable<OnRoadWaypoint>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OnRoadWaypoint" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected OnRoadWaypoint() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OnRoadWaypoint" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        /// <param name="matchSideOfStreet">Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint. (default to false).</param>
        /// <param name="serviceTime">The service time [s] that is required at this waypoint, e.g. for pickup or delivery. (default to 0).</param>
        /// <param name="openingIntervals">The opening intervals at this waypoint, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the waypoint is always open. Service can only start within one of the opening intervals. If the vehicle does not arrive at a waypoint within an opening interval, a waiting time will be scheduled.  When using a multi-day **workingHoursPreset** this waiting time will usually be used for daily rests instead, in order to continue the route with a rested driver..</param>
        /// <param name="vehicleParameters">vehicleParameters.</param>
        public OnRoadWaypoint(double latitude = default(double), double longitude = default(double), bool matchSideOfStreet = false, int serviceTime = 0, List<TimeInterval> openingIntervals = default(List<TimeInterval>), VehicleParametersAtWaypoint vehicleParameters = default(VehicleParametersAtWaypoint))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
            this.MatchSideOfStreet = matchSideOfStreet;
            this.ServiceTime = serviceTime;
            this.OpeningIntervals = openingIntervals;
            this.VehicleParameters = vehicleParameters;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.
        /// </summary>
        /// <value>Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location represented by this waypoint.</value>
        [DataMember(Name = "matchSideOfStreet", EmitDefaultValue = true)]
        public bool MatchSideOfStreet { get; set; }
        /// <summary>
        /// The service time [s] that is required at this waypoint, e.g. for pickup or delivery.
        /// </summary>
        /// <value>The service time [s] that is required at this waypoint, e.g. for pickup or delivery.</value>
        [DataMember(Name = "serviceTime", EmitDefaultValue = false)]
        public int ServiceTime { get; set; }
        /// <summary>
        /// The opening intervals at this waypoint, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the waypoint is always open. Service can only start within one of the opening intervals. If the vehicle does not arrive at a waypoint within an opening interval, a waiting time will be scheduled.  When using a multi-day **workingHoursPreset** this waiting time will usually be used for daily rests instead, in order to continue the route with a rested driver.
        /// </summary>
        /// <value>The opening intervals at this waypoint, each specified by two points in time - the beginning and the end of the interval. Leaving this parameter empty means that the waypoint is always open. Service can only start within one of the opening intervals. If the vehicle does not arrive at a waypoint within an opening interval, a waiting time will be scheduled.  When using a multi-day **workingHoursPreset** this waiting time will usually be used for daily rests instead, in order to continue the route with a rested driver.</value>
        [DataMember(Name = "openingIntervals", EmitDefaultValue = false)]
        public List<TimeInterval> OpeningIntervals { get; set; }
        /// <summary>
        /// Gets or Sets VehicleParameters
        /// </summary>
        [DataMember(Name = "vehicleParameters", EmitDefaultValue = false)]
        public VehicleParametersAtWaypoint VehicleParameters { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class OnRoadWaypoint {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("  MatchSideOfStreet: ").Append(MatchSideOfStreet).Append("\n");
            sb.Append("  ServiceTime: ").Append(ServiceTime).Append("\n");
            sb.Append("  OpeningIntervals: ").Append(OpeningIntervals).Append("\n");
            sb.Append("  VehicleParameters: ").Append(VehicleParameters).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OnRoadWaypoint);
        }
        /// <summary>
        /// Returns true if OnRoadWaypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of OnRoadWaypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OnRoadWaypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                ) && 
                (
                    this.MatchSideOfStreet == input.MatchSideOfStreet ||
                    this.MatchSideOfStreet.Equals(input.MatchSideOfStreet)
                ) && 
                (
                    this.ServiceTime == input.ServiceTime ||
                    this.ServiceTime.Equals(input.ServiceTime)
                ) && 
                (
                    this.OpeningIntervals == input.OpeningIntervals ||
                    this.OpeningIntervals != null &&
                    input.OpeningIntervals != null &&
                    this.OpeningIntervals.SequenceEqual(input.OpeningIntervals)
                ) && 
                (
                    this.VehicleParameters == input.VehicleParameters ||
                    (this.VehicleParameters != null &&
                    this.VehicleParameters.Equals(input.VehicleParameters))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                hashCode = (hashCode * 59) + this.MatchSideOfStreet.GetHashCode();
                hashCode = (hashCode * 59) + this.ServiceTime.GetHashCode();
                if (this.OpeningIntervals != null)
                {
                    hashCode = (hashCode * 59) + this.OpeningIntervals.GetHashCode();
                }
                if (this.VehicleParameters != null)
                {
                    hashCode = (hashCode * 59) + this.VehicleParameters.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            // ServiceTime (int) minimum
            if (this.ServiceTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ServiceTime, must be a value greater than or equal to 0.", new [] { "ServiceTime" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Options
    /// </summary>
    [DataContract(Name = "Options")]
    public partial class Options : IEquatable<Options>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets TrafficMode
        /// </summary>
        [DataMember(Name = "trafficMode", EmitDefaultValue = false)]
        public TrafficMode? TrafficMode { get; set; }
        /// <summary>
        /// Gets or Sets PolylineFormat
        /// </summary>
        [DataMember(Name = "polylineFormat", EmitDefaultValue = false)]
        public PolylineFormat? PolylineFormat { get; set; }
        /// <summary>
        /// Gets or Sets RoutingMode
        /// </summary>
        [DataMember(Name = "routingMode", EmitDefaultValue = false)]
        public RoutingMode? RoutingMode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Options" /> class.
        /// </summary>
        /// <param name="startTime">Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **arrivalTime**. If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. Responses will contain the offset to UTC specified in the request or that of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time..</param>
        /// <param name="arrivalTime">Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **startTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. Responses will contain the offset to UTC specified in the request or that of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time..</param>
        /// <param name="trafficMode">trafficMode.</param>
        /// <param name="language">The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** &#x60;ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE&#x60; is returned if the language is not supported for maneuvers. (default to &quot;en&quot;).</param>
        /// <param name="polylineFormat">polylineFormat.</param>
        /// <param name="allowedCountries">Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision..</param>
        /// <param name="prohibitedCountries">Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision..</param>
        /// <param name="currency">The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]&#x3D;MONETARY**..</param>
        /// <param name="preferTurnsOnPassengerSide">Specifies that the route is constructed such that turns to the passenger side are preferred.  (default to false).</param>
        /// <param name="avoid">Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * &#x60;TOLL&#x60; - Avoid roads with toll. * &#x60;FERRIES&#x60; - Avoid ferries. Ferries which cannot be avoided can be requested with &#x60;COMBINED_TRANSPORT_EVENTS&#x60; and will appear with the type &#x60;BOAT&#x60;. * &#x60;RAIL_SHUTTLES&#x60; - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with &#x60;COMBINED_TRANSPORT_EVENTS&#x60; and will appear with the type &#x60;RAIL&#x60;.   Cannot be used with **options[routingMode]&#x3D;MONETARY**.  Available values are provided by type &#x60;AvoidFeature&#x60;..</param>
        /// <param name="blockIntersectingRoads">Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. .</param>
        /// <param name="customRoadAttributeScenarios">Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID..</param>
        /// <param name="routingMode">routingMode.</param>
        public Options(DateTime? startTime = default(DateTime?), DateTime? arrivalTime = default(DateTime?), TrafficMode? trafficMode = default(TrafficMode?), string language = @"en", PolylineFormat? polylineFormat = default(PolylineFormat?), string allowedCountries = default(string), string prohibitedCountries = default(string), string currency = default(string), bool preferTurnsOnPassengerSide = false, string avoid = default(string), string blockIntersectingRoads = default(string), string customRoadAttributeScenarios = default(string), RoutingMode? routingMode = default(RoutingMode?))
        {
            this.StartTime = startTime;
            this.ArrivalTime = arrivalTime;
            this.TrafficMode = trafficMode;
            // use default value if no "language" provided
            this.Language = language ?? @"en";
            this.PolylineFormat = polylineFormat;
            this.AllowedCountries = allowedCountries;
            this.ProhibitedCountries = prohibitedCountries;
            this.Currency = currency;
            this.PreferTurnsOnPassengerSide = preferTurnsOnPassengerSide;
            this.Avoid = avoid;
            this.BlockIntersectingRoads = blockIntersectingRoads;
            this.CustomRoadAttributeScenarios = customRoadAttributeScenarios;
            this.RoutingMode = routingMode;
        }
        /// <summary>
        /// Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **arrivalTime**. If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. Responses will contain the offset to UTC specified in the request or that of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **arrivalTime**. If none of them is specified the current time will be used as the start time for **trafficMode** _REALISTIC_. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the start waypoint. Responses will contain the offset to UTC specified in the request or that of the start waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        /// <example>2020-12-04T06:00Z</example>
        [DataMember(Name = "startTime", EmitDefaultValue = true)]
        public DateTime? StartTime { get; set; }
        /// <summary>
        /// Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **startTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. Responses will contain the offset to UTC specified in the request or that of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the arrival time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **startTime** and cannot be used with the **results** _SCHEDULE_REPORT_ and _SCHEDULE_EVENT_ nor when **openingIntervals**, **serviceTime** or **workingHoursPreset** are specified. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the destination waypoint. Responses will contain the offset to UTC specified in the request or that of the destination waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  For best results it should not be more than one month in the past nor more than six months in the future.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        [DataMember(Name = "arrivalTime", EmitDefaultValue = true)]
        public DateTime? ArrivalTime { get; set; }
        /// <summary>
        /// The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** &#x60;ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE&#x60; is returned if the language is not supported for maneuvers.
        /// </summary>
        /// <value>The language of texts such as the descriptions of _MANEUVER_EVENTS_ and _TRAFFIC_EVENTS_. Languages have to be specified according to their [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) code or as a combination of language code and sub-tag according to [BCP47](https://tools.ietf.org/rfc/bcp/bcp47.txt).   The **warningCode** &#x60;ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE&#x60; is returned if the language is not supported for maneuvers.</value>
        [DataMember(Name = "language", EmitDefaultValue = false)]
        public string Language { get; set; }
        /// <summary>
        /// Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "allowedCountries", EmitDefaultValue = true)]
        public string AllowedCountries { get; set; }
        /// <summary>
        /// Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "prohibitedCountries", EmitDefaultValue = true)]
        public string ProhibitedCountries { get; set; }
        /// <summary>
        /// The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]&#x3D;MONETARY**.
        /// </summary>
        /// <value>The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).   If it is not specified, the currency is taken from the **profile**.   It is used for the costs in the monetary cost report if _MONETARY_COSTS_ are requested in the **results** and for  toll price conversion if _TOLL_COSTS_ or _TOLL_SECTIONS_ are requested in the **results**. Furthermore, it is used  when setting **options[routingMode]&#x3D;MONETARY**.</value>
        [DataMember(Name = "currency", EmitDefaultValue = true)]
        public string Currency { get; set; }
        /// <summary>
        /// Specifies that the route is constructed such that turns to the passenger side are preferred. 
        /// </summary>
        /// <value>Specifies that the route is constructed such that turns to the passenger side are preferred. </value>
        /// <example>false</example>
        [DataMember(Name = "preferTurnsOnPassengerSide", EmitDefaultValue = true)]
        public bool PreferTurnsOnPassengerSide { get; set; }
        /// <summary>
        /// Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * &#x60;TOLL&#x60; - Avoid roads with toll. * &#x60;FERRIES&#x60; - Avoid ferries. Ferries which cannot be avoided can be requested with &#x60;COMBINED_TRANSPORT_EVENTS&#x60; and will appear with the type &#x60;BOAT&#x60;. * &#x60;RAIL_SHUTTLES&#x60; - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with &#x60;COMBINED_TRANSPORT_EVENTS&#x60; and will appear with the type &#x60;RAIL&#x60;.   Cannot be used with **options[routingMode]&#x3D;MONETARY**.  Available values are provided by type &#x60;AvoidFeature&#x60;.
        /// </summary>
        /// <value>Comma-separated list of features which should be avoided on the route. Avoided features could be included in a route if there is no possibility to reach the target otherwise. * &#x60;TOLL&#x60; - Avoid roads with toll. * &#x60;FERRIES&#x60; - Avoid ferries. Ferries which cannot be avoided can be requested with &#x60;COMBINED_TRANSPORT_EVENTS&#x60; and will appear with the type &#x60;BOAT&#x60;. * &#x60;RAIL_SHUTTLES&#x60; - Avoid rail shuttles. Rail shuttles which cannot be avoided can be requested with &#x60;COMBINED_TRANSPORT_EVENTS&#x60; and will appear with the type &#x60;RAIL&#x60;.   Cannot be used with **options[routingMode]&#x3D;MONETARY**.  Available values are provided by type &#x60;AvoidFeature&#x60;.</value>
        [DataMember(Name = "avoid", EmitDefaultValue = true)]
        public string Avoid { get; set; }
        /// <summary>
        /// Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. 
        /// </summary>
        /// <value>Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. </value>
        /// <example>49.8,9.9,49.9,10|33.1,-111.1,33.0,-111.2</example>
        [DataMember(Name = "blockIntersectingRoads", EmitDefaultValue = true)]
        public string BlockIntersectingRoads { get; set; }
        /// <summary>
        /// Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID.
        /// </summary>
        /// <value>Comma-separated list of [custom road attribute scenarios](../data-api/concepts/custom-road-attributes) to be considered in the route calculation.  Each scenario can be specified by its name or its ID. A shared scenario can only be specified by its ID.</value>
        [DataMember(Name = "customRoadAttributeScenarios", EmitDefaultValue = true)]
        public string CustomRoadAttributeScenarios { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Options {\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  ArrivalTime: ").Append(ArrivalTime).Append("\n");
            sb.Append("  TrafficMode: ").Append(TrafficMode).Append("\n");
            sb.Append("  Language: ").Append(Language).Append("\n");
            sb.Append("  PolylineFormat: ").Append(PolylineFormat).Append("\n");
            sb.Append("  AllowedCountries: ").Append(AllowedCountries).Append("\n");
            sb.Append("  ProhibitedCountries: ").Append(ProhibitedCountries).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  PreferTurnsOnPassengerSide: ").Append(PreferTurnsOnPassengerSide).Append("\n");
            sb.Append("  Avoid: ").Append(Avoid).Append("\n");
            sb.Append("  BlockIntersectingRoads: ").Append(BlockIntersectingRoads).Append("\n");
            sb.Append("  CustomRoadAttributeScenarios: ").Append(CustomRoadAttributeScenarios).Append("\n");
            sb.Append("  RoutingMode: ").Append(RoutingMode).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Options);
        }
        /// <summary>
        /// Returns true if Options instances are equal
        /// </summary>
        /// <param name="input">Instance of Options to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Options input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.StartTime == input.StartTime ||
                    (this.StartTime != null &&
                    this.StartTime.Equals(input.StartTime))
                ) && 
                (
                    this.ArrivalTime == input.ArrivalTime ||
                    (this.ArrivalTime != null &&
                    this.ArrivalTime.Equals(input.ArrivalTime))
                ) && 
                (
                    this.TrafficMode == input.TrafficMode ||
                    this.TrafficMode.Equals(input.TrafficMode)
                ) && 
                (
                    this.Language == input.Language ||
                    (this.Language != null &&
                    this.Language.Equals(input.Language))
                ) && 
                (
                    this.PolylineFormat == input.PolylineFormat ||
                    this.PolylineFormat.Equals(input.PolylineFormat)
                ) && 
                (
                    this.AllowedCountries == input.AllowedCountries ||
                    (this.AllowedCountries != null &&
                    this.AllowedCountries.Equals(input.AllowedCountries))
                ) && 
                (
                    this.ProhibitedCountries == input.ProhibitedCountries ||
                    (this.ProhibitedCountries != null &&
                    this.ProhibitedCountries.Equals(input.ProhibitedCountries))
                ) && 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                ) && 
                (
                    this.PreferTurnsOnPassengerSide == input.PreferTurnsOnPassengerSide ||
                    this.PreferTurnsOnPassengerSide.Equals(input.PreferTurnsOnPassengerSide)
                ) && 
                (
                    this.Avoid == input.Avoid ||
                    (this.Avoid != null &&
                    this.Avoid.Equals(input.Avoid))
                ) && 
                (
                    this.BlockIntersectingRoads == input.BlockIntersectingRoads ||
                    (this.BlockIntersectingRoads != null &&
                    this.BlockIntersectingRoads.Equals(input.BlockIntersectingRoads))
                ) && 
                (
                    this.CustomRoadAttributeScenarios == input.CustomRoadAttributeScenarios ||
                    (this.CustomRoadAttributeScenarios != null &&
                    this.CustomRoadAttributeScenarios.Equals(input.CustomRoadAttributeScenarios))
                ) && 
                (
                    this.RoutingMode == input.RoutingMode ||
                    this.RoutingMode.Equals(input.RoutingMode)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.StartTime != null)
                {
                    hashCode = (hashCode * 59) + this.StartTime.GetHashCode();
                }
                if (this.ArrivalTime != null)
                {
                    hashCode = (hashCode * 59) + this.ArrivalTime.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TrafficMode.GetHashCode();
                if (this.Language != null)
                {
                    hashCode = (hashCode * 59) + this.Language.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.PolylineFormat.GetHashCode();
                if (this.AllowedCountries != null)
                {
                    hashCode = (hashCode * 59) + this.AllowedCountries.GetHashCode();
                }
                if (this.ProhibitedCountries != null)
                {
                    hashCode = (hashCode * 59) + this.ProhibitedCountries.GetHashCode();
                }
                if (this.Currency != null)
                {
                    hashCode = (hashCode * 59) + this.Currency.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.PreferTurnsOnPassengerSide.GetHashCode();
                if (this.Avoid != null)
                {
                    hashCode = (hashCode * 59) + this.Avoid.GetHashCode();
                }
                if (this.BlockIntersectingRoads != null)
                {
                    hashCode = (hashCode * 59) + this.BlockIntersectingRoads.GetHashCode();
                }
                if (this.CustomRoadAttributeScenarios != null)
                {
                    hashCode = (hashCode * 59) + this.CustomRoadAttributeScenarios.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RoutingMode.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Language != null) {
                // Language (string) pattern
                Regex regexLanguage = new Regex(@"[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*", RegexOptions.CultureInvariant);
                if (!regexLanguage.Match(this.Language).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Language, must match a pattern of " + regexLanguage, new [] { "Language" });
                }
            }
            if (this.Currency != null) {
                // Currency (string) pattern
                Regex regexCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
                if (!regexCurrency.Match(this.Currency).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Currency, must match a pattern of " + regexCurrency, new [] { "Currency" });
                }
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The particle reduction class (Partikelminderungsklasse) according to &#39;Anlage XIV zu &amp;sect; 48 StVZO&#39; (German law).  Supported for **engineType** _COMBUSTION_ and _HYBRID_. Relevant for &#x60;toll&#x60;. 
    /// </summary>
    /// <value>The particle reduction class (Partikelminderungsklasse) according to &#39;Anlage XIV zu &amp;sect; 48 StVZO&#39; (German law).  Supported for **engineType** _COMBUSTION_ and _HYBRID_. Relevant for &#x60;toll&#x60;. </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ParticleReductionClass
    {
        /// <summary>
        /// Enum PMK_0 for value: PMK_0
        /// </summary>
        [EnumMember(Value = "PMK_0")]
        PMK_0 = 1,
        /// <summary>
        /// Enum PMK_1 for value: PMK_1
        /// </summary>
        [EnumMember(Value = "PMK_1")]
        PMK_1 = 2,
        /// <summary>
        /// Enum PMK_2 for value: PMK_2
        /// </summary>
        [EnumMember(Value = "PMK_2")]
        PMK_2 = 3,
        /// <summary>
        /// Enum PMK_3 for value: PMK_3
        /// </summary>
        [EnumMember(Value = "PMK_3")]
        PMK_3 = 4,
        /// <summary>
        /// Enum PMK_4 for value: PMK_4
        /// </summary>
        [EnumMember(Value = "PMK_4")]
        PMK_4 = 5,
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 6
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// A payment method for toll costs.    * &#x60;ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION&#x60; - Pay with an electronic toll collection system for which a subscription is required.    * &#x60;ELECTRONIC_TOLL_COLLECTION&#x60; - Pay with some electronic toll collection system for which no prior subscription is required.    * &#x60;CASH&#x60; - Pay with cash at a toll booth.    * &#x60;CREDIT_CARD&#x60; - Pay with credit card at a toll booth.
    /// </summary>
    /// <value>A payment method for toll costs.    * &#x60;ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION&#x60; - Pay with an electronic toll collection system for which a subscription is required.    * &#x60;ELECTRONIC_TOLL_COLLECTION&#x60; - Pay with some electronic toll collection system for which no prior subscription is required.    * &#x60;CASH&#x60; - Pay with cash at a toll booth.    * &#x60;CREDIT_CARD&#x60; - Pay with credit card at a toll booth.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum PaymentMethod
    {
        /// <summary>
        /// Enum ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION for value: ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION
        /// </summary>
        [EnumMember(Value = "ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION")]
        ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION = 1,
        /// <summary>
        /// Enum ELECTRONIC_TOLL_COLLECTION for value: ELECTRONIC_TOLL_COLLECTION
        /// </summary>
        [EnumMember(Value = "ELECTRONIC_TOLL_COLLECTION")]
        ELECTRONIC_TOLL_COLLECTION = 2,
        /// <summary>
        /// Enum CASH for value: CASH
        /// </summary>
        [EnumMember(Value = "CASH")]
        CASH = 3,
        /// <summary>
        /// Enum CREDIT_CARD for value: CREDIT_CARD
        /// </summary>
        [EnumMember(Value = "CREDIT_CARD")]
        CREDIT_CARD = 4
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines the format for polylines in the response.    * &#x60;GEO_JSON&#x60; - Polylines are returned in the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).    * &#x60;GOOGLE_ENCODED_POLYLINE&#x60; - Polylines are returned in [Google&#39;s Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm) format.  
    /// </summary>
    /// <value>Defines the format for polylines in the response.    * &#x60;GEO_JSON&#x60; - Polylines are returned in the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).    * &#x60;GOOGLE_ENCODED_POLYLINE&#x60; - Polylines are returned in [Google&#39;s Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm) format.  </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum PolylineFormat
    {
        /// <summary>
        /// Enum GEO_JSON for value: GEO_JSON
        /// </summary>
        [EnumMember(Value = "GEO_JSON")]
        GEO_JSON = 1,
        /// <summary>
        /// Enum GOOGLE_ENCODED_POLYLINE for value: GOOGLE_ENCODED_POLYLINE
        /// </summary>
        [EnumMember(Value = "GOOGLE_ENCODED_POLYLINE")]
        GOOGLE_ENCODED_POLYLINE = 2
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The vehicle position if it is at a waypoint. This parameter is mutually exclusive with **position**.
    /// </summary>
    [DataContract(Name = "PositionAtWaypoint")]
    public partial class PositionAtWaypoint : IEquatable<PositionAtWaypoint>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PositionAtWaypoint" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PositionAtWaypoint() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PositionAtWaypoint" /> class.
        /// </summary>
        /// <param name="name">The name of the waypoint. (required).</param>
        /// <param name="performedServiceTime">The service time [s] which has already been performed. (default to 0).</param>
        public PositionAtWaypoint(string name = default(string), int performedServiceTime = 0)
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for PositionAtWaypoint and cannot be null");
            }
            this.Name = name;
            this.PerformedServiceTime = performedServiceTime;
        }
        /// <summary>
        /// The name of the waypoint.
        /// </summary>
        /// <value>The name of the waypoint.</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }
        /// <summary>
        /// The service time [s] which has already been performed.
        /// </summary>
        /// <value>The service time [s] which has already been performed.</value>
        [DataMember(Name = "performedServiceTime", EmitDefaultValue = false)]
        public int PerformedServiceTime { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PositionAtWaypoint {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  PerformedServiceTime: ").Append(PerformedServiceTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PositionAtWaypoint);
        }
        /// <summary>
        /// Returns true if PositionAtWaypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of PositionAtWaypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PositionAtWaypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.PerformedServiceTime == input.PerformedServiceTime ||
                    this.PerformedServiceTime.Equals(input.PerformedServiceTime)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.PerformedServiceTime.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // PerformedServiceTime (int) minimum
            if (this.PerformedServiceTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PerformedServiceTime, must be a value greater than or equal to 0.", new [] { "PerformedServiceTime" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The position of the vehicle if the vehicle position is not at a waypoint but somewhere on the route. This parameter is mutually exclusive with **waypoint**.
    /// </summary>
    [DataContract(Name = "PositionOnRoute")]
    public partial class PositionOnRoute : IEquatable<PositionOnRoute>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PositionOnRoute" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PositionOnRoute() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PositionOnRoute" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        /// <param name="nextWaypointName">The name of the next waypoint on the route. (required).</param>
        /// <param name="heading">The current heading of the vehicle [deg]. It denotes the driving direction, North represents 0 degrees, East represents 90 degrees, South represents 180 degrees, West represents 270 degrees.  If specified and if the heading of the vehicle is not in the direction of the route near the given **position**, it is assumed that the vehicle has left the route so that a new route will be calculated. This new route will then be  calculated from the road closest to the position matching the vehicle heading. For more information see this [concept](./concepts/estimated-time-arrival)..</param>
        /// <param name="headingTolerance">Denotes the tolerance between **heading** and the direction of a road, i.e. roads with a direction of **heading****headingTolerance** are taken into account. Applies only if **heading** is specified. (default to 45).</param>
        public PositionOnRoute(double? latitude = default(double?), double? longitude = default(double?), string nextWaypointName = default(string), int? heading = default(int?), int headingTolerance = 45)
        {
            // to ensure "latitude" is required (not null)
            if (latitude == null)
            {
                throw new ArgumentNullException("latitude is a required property for PositionOnRoute and cannot be null");
            }
            this.Latitude = latitude;
            // to ensure "longitude" is required (not null)
            if (longitude == null)
            {
                throw new ArgumentNullException("longitude is a required property for PositionOnRoute and cannot be null");
            }
            this.Longitude = longitude;
            // to ensure "nextWaypointName" is required (not null)
            if (nextWaypointName == null)
            {
                throw new ArgumentNullException("nextWaypointName is a required property for PositionOnRoute and cannot be null");
            }
            this.NextWaypointName = nextWaypointName;
            this.Heading = heading;
            this.HeadingTolerance = headingTolerance;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double? Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double? Longitude { get; set; }
        /// <summary>
        /// The name of the next waypoint on the route.
        /// </summary>
        /// <value>The name of the next waypoint on the route.</value>
        [DataMember(Name = "nextWaypointName", IsRequired = true, EmitDefaultValue = true)]
        public string NextWaypointName { get; set; }
        /// <summary>
        /// The current heading of the vehicle [deg]. It denotes the driving direction, North represents 0 degrees, East represents 90 degrees, South represents 180 degrees, West represents 270 degrees.  If specified and if the heading of the vehicle is not in the direction of the route near the given **position**, it is assumed that the vehicle has left the route so that a new route will be calculated. This new route will then be  calculated from the road closest to the position matching the vehicle heading. For more information see this [concept](./concepts/estimated-time-arrival).
        /// </summary>
        /// <value>The current heading of the vehicle [deg]. It denotes the driving direction, North represents 0 degrees, East represents 90 degrees, South represents 180 degrees, West represents 270 degrees.  If specified and if the heading of the vehicle is not in the direction of the route near the given **position**, it is assumed that the vehicle has left the route so that a new route will be calculated. This new route will then be  calculated from the road closest to the position matching the vehicle heading. For more information see this [concept](./concepts/estimated-time-arrival).</value>
        [DataMember(Name = "heading", EmitDefaultValue = true)]
        public int? Heading { get; set; }
        /// <summary>
        /// Denotes the tolerance between **heading** and the direction of a road, i.e. roads with a direction of **heading****headingTolerance** are taken into account. Applies only if **heading** is specified.
        /// </summary>
        /// <value>Denotes the tolerance between **heading** and the direction of a road, i.e. roads with a direction of **heading****headingTolerance** are taken into account. Applies only if **heading** is specified.</value>
        [DataMember(Name = "headingTolerance", EmitDefaultValue = false)]
        public int HeadingTolerance { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PositionOnRoute {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("  NextWaypointName: ").Append(NextWaypointName).Append("\n");
            sb.Append("  Heading: ").Append(Heading).Append("\n");
            sb.Append("  HeadingTolerance: ").Append(HeadingTolerance).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PositionOnRoute);
        }
        /// <summary>
        /// Returns true if PositionOnRoute instances are equal
        /// </summary>
        /// <param name="input">Instance of PositionOnRoute to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PositionOnRoute input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    (this.Latitude != null &&
                    this.Latitude.Equals(input.Latitude))
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    (this.Longitude != null &&
                    this.Longitude.Equals(input.Longitude))
                ) && 
                (
                    this.NextWaypointName == input.NextWaypointName ||
                    (this.NextWaypointName != null &&
                    this.NextWaypointName.Equals(input.NextWaypointName))
                ) && 
                (
                    this.Heading == input.Heading ||
                    (this.Heading != null &&
                    this.Heading.Equals(input.Heading))
                ) && 
                (
                    this.HeadingTolerance == input.HeadingTolerance ||
                    this.HeadingTolerance.Equals(input.HeadingTolerance)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Latitude != null)
                {
                    hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                }
                if (this.Longitude != null)
                {
                    hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                }
                if (this.NextWaypointName != null)
                {
                    hashCode = (hashCode * 59) + this.NextWaypointName.GetHashCode();
                }
                if (this.Heading != null)
                {
                    hashCode = (hashCode * 59) + this.Heading.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.HeadingTolerance.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double?) maximum
            if (this.Latitude > (double?)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double?) minimum
            if (this.Latitude < (double?)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double?) maximum
            if (this.Longitude > (double?)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double?) minimum
            if (this.Longitude < (double?)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            // Heading (int?) maximum
            if (this.Heading > (int?)360)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Heading, must be a value less than or equal to 360.", new [] { "Heading" });
            }
            // Heading (int?) minimum
            if (this.Heading < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Heading, must be a value greater than or equal to 0.", new [] { "Heading" });
            }
            // HeadingTolerance (int) maximum
            if (this.HeadingTolerance > (int)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for HeadingTolerance, must be a value less than or equal to 180.", new [] { "HeadingTolerance" });
            }
            // HeadingTolerance (int) minimum
            if (this.HeadingTolerance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for HeadingTolerance, must be a value greater than or equal to 0.", new [] { "HeadingTolerance" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The result of the reachable areas calculation.
    /// </summary>
    [DataContract(Name = "ReachableAreas")]
    public partial class ReachableAreas : IEquatable<ReachableAreas>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreas" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReachableAreas() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreas" /> class.
        /// </summary>
        /// <param name="polygons">The list of polygons calculated for the specified horizons in GeoJson format. For each horizon there is a separate polygon at the same index. (required).</param>
        /// <param name="warnings">A list of warnings concerning the validity of the result..</param>
        public ReachableAreas(List<string> polygons = default(List<string>), List<Warning> warnings = default(List<Warning>))
        {
            // to ensure "polygons" is required (not null)
            if (polygons == null)
            {
                throw new ArgumentNullException("polygons is a required property for ReachableAreas and cannot be null");
            }
            this.Polygons = polygons;
            this.Warnings = warnings;
        }
        /// <summary>
        /// The list of polygons calculated for the specified horizons in GeoJson format. For each horizon there is a separate polygon at the same index.
        /// </summary>
        /// <value>The list of polygons calculated for the specified horizons in GeoJson format. For each horizon there is a separate polygon at the same index.</value>
        [DataMember(Name = "polygons", IsRequired = true, EmitDefaultValue = true)]
        public List<string> Polygons { get; set; }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableAreas {\n");
            sb.Append("  Polygons: ").Append(Polygons).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableAreas);
        }
        /// <summary>
        /// Returns true if ReachableAreas instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableAreas to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableAreas input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Polygons == input.Polygons ||
                    this.Polygons != null &&
                    input.Polygons != null &&
                    this.Polygons.SequenceEqual(input.Polygons)
                ) && 
                (
                    this.Warnings == input.Warnings ||
                    this.Warnings != null &&
                    input.Warnings != null &&
                    this.Warnings.SequenceEqual(input.Warnings)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Polygons != null)
                {
                    hashCode = (hashCode * 59) + this.Polygons.GetHashCode();
                }
                if (this.Warnings != null)
                {
                    hashCode = (hashCode * 59) + this.Warnings.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ReachableAreasId
    /// </summary>
    [DataContract(Name = "ReachableAreasId")]
    public partial class ReachableAreasId : IEquatable<ReachableAreasId>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasId" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReachableAreasId() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasId" /> class.
        /// </summary>
        /// <param name="id">The ID of the calculated reachable areas. (required).</param>
        public ReachableAreasId(Guid id = default(Guid))
        {
            this.Id = id;
        }
        /// <summary>
        /// The ID of the calculated reachable areas.
        /// </summary>
        /// <value>The ID of the calculated reachable areas.</value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = true)]
        public Guid Id { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableAreasId {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableAreasId);
        }
        /// <summary>
        /// Returns true if ReachableAreasId instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableAreasId to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableAreasId input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                {
                    hashCode = (hashCode * 59) + this.Id.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ReachableAreasResponse
    /// </summary>
    [DataContract(Name = "ReachableAreasResponse")]
    public partial class ReachableAreasResponse : IEquatable<ReachableAreasResponse>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Status
        /// </summary>
        [DataMember(Name = "status", EmitDefaultValue = false)]
        public CalculationStatus? Status { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableAreasResponse" /> class.
        /// </summary>
        /// <param name="status">status.</param>
        /// <param name="reachableAreas">reachableAreas.</param>
        /// <param name="error">error.</param>
        public ReachableAreasResponse(CalculationStatus? status = default(CalculationStatus?), ReachableAreas reachableAreas = default(ReachableAreas), ErrorResponse error = default(ErrorResponse))
        {
            this.Status = status;
            this.ReachableAreas = reachableAreas;
            this.Error = error;
        }
        /// <summary>
        /// Gets or Sets ReachableAreas
        /// </summary>
        [DataMember(Name = "reachableAreas", EmitDefaultValue = false)]
        public ReachableAreas ReachableAreas { get; set; }
        /// <summary>
        /// Gets or Sets Error
        /// </summary>
        [DataMember(Name = "error", EmitDefaultValue = false)]
        public ErrorResponse Error { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableAreasResponse {\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  ReachableAreas: ").Append(ReachableAreas).Append("\n");
            sb.Append("  Error: ").Append(Error).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableAreasResponse);
        }
        /// <summary>
        /// Returns true if ReachableAreasResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableAreasResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableAreasResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Status == input.Status ||
                    this.Status.Equals(input.Status)
                ) && 
                (
                    this.ReachableAreas == input.ReachableAreas ||
                    (this.ReachableAreas != null &&
                    this.ReachableAreas.Equals(input.ReachableAreas))
                ) && 
                (
                    this.Error == input.Error ||
                    (this.Error != null &&
                    this.Error.Equals(input.Error))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Status.GetHashCode();
                if (this.ReachableAreas != null)
                {
                    hashCode = (hashCode * 59) + this.ReachableAreas.GetHashCode();
                }
                if (this.Error != null)
                {
                    hashCode = (hashCode * 59) + this.Error.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Contains the distance and travel time from the input waypoint or route to a reached location or vice versa (depending on the request drivingDirection).
    /// </summary>
    [DataContract(Name = "ReachableLocation")]
    public partial class ReachableLocation : IEquatable<ReachableLocation>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocation" /> class.
        /// </summary>
        /// <param name="distance">The distance from the input waypoint to this location or vice versa..</param>
        /// <param name="travelTime">The travel time from the input waypoint to this location or vice versa..</param>
        /// <param name="index">The index of the reached input location..</param>
        public ReachableLocation(int distance = default(int), int travelTime = default(int), int index = default(int))
        {
            this.Distance = distance;
            this.TravelTime = travelTime;
            this.Index = index;
        }
        /// <summary>
        /// The distance from the input waypoint to this location or vice versa.
        /// </summary>
        /// <value>The distance from the input waypoint to this location or vice versa.</value>
        [DataMember(Name = "distance", EmitDefaultValue = false)]
        public int Distance { get; set; }
        /// <summary>
        /// The travel time from the input waypoint to this location or vice versa.
        /// </summary>
        /// <value>The travel time from the input waypoint to this location or vice versa.</value>
        [DataMember(Name = "travelTime", EmitDefaultValue = false)]
        public int TravelTime { get; set; }
        /// <summary>
        /// The index of the reached input location.
        /// </summary>
        /// <value>The index of the reached input location.</value>
        [DataMember(Name = "index", EmitDefaultValue = false)]
        public int Index { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableLocation {\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TravelTime: ").Append(TravelTime).Append("\n");
            sb.Append("  Index: ").Append(Index).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableLocation);
        }
        /// <summary>
        /// Returns true if ReachableLocation instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableLocation to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableLocation input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Distance == input.Distance ||
                    this.Distance.Equals(input.Distance)
                ) && 
                (
                    this.TravelTime == input.TravelTime ||
                    this.TravelTime.Equals(input.TravelTime)
                ) && 
                (
                    this.Index == input.Index ||
                    this.Index.Equals(input.Index)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                hashCode = (hashCode * 59) + this.TravelTime.GetHashCode();
                hashCode = (hashCode * 59) + this.Index.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The results of a reachable locations calculation.
    /// </summary>
    [DataContract(Name = "ReachableLocations")]
    public partial class ReachableLocations : IEquatable<ReachableLocations>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocations" /> class.
        /// </summary>
        /// <param name="reachable">Reachable locations ordered by distance or travel time (depending on the request &#x60;horizonType&#x60;)..</param>
        /// <param name="unreachable">Indexes of the unreachable locations as given in the request locations..</param>
        /// <param name="warnings">A list of warnings concerning the validity of the result..</param>
        public ReachableLocations(List<ReachableLocation> reachable = default(List<ReachableLocation>), List<int> unreachable = default(List<int>), List<Warning> warnings = default(List<Warning>))
        {
            this.Reachable = reachable;
            this.Unreachable = unreachable;
            this.Warnings = warnings;
        }
        /// <summary>
        /// Reachable locations ordered by distance or travel time (depending on the request &#x60;horizonType&#x60;).
        /// </summary>
        /// <value>Reachable locations ordered by distance or travel time (depending on the request &#x60;horizonType&#x60;).</value>
        [DataMember(Name = "reachable", EmitDefaultValue = false)]
        public List<ReachableLocation> Reachable { get; set; }
        /// <summary>
        /// Indexes of the unreachable locations as given in the request locations.
        /// </summary>
        /// <value>Indexes of the unreachable locations as given in the request locations.</value>
        [DataMember(Name = "unreachable", EmitDefaultValue = false)]
        public List<int> Unreachable { get; set; }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableLocations {\n");
            sb.Append("  Reachable: ").Append(Reachable).Append("\n");
            sb.Append("  Unreachable: ").Append(Unreachable).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableLocations);
        }
        /// <summary>
        /// Returns true if ReachableLocations instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableLocations to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableLocations input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Reachable == input.Reachable ||
                    this.Reachable != null &&
                    input.Reachable != null &&
                    this.Reachable.SequenceEqual(input.Reachable)
                ) && 
                (
                    this.Unreachable == input.Unreachable ||
                    this.Unreachable != null &&
                    input.Unreachable != null &&
                    this.Unreachable.SequenceEqual(input.Unreachable)
                ) && 
                (
                    this.Warnings == input.Warnings ||
                    this.Warnings != null &&
                    input.Warnings != null &&
                    this.Warnings.SequenceEqual(input.Warnings)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Reachable != null)
                {
                    hashCode = (hashCode * 59) + this.Reachable.GetHashCode();
                }
                if (this.Unreachable != null)
                {
                    hashCode = (hashCode * 59) + this.Unreachable.GetHashCode();
                }
                if (this.Warnings != null)
                {
                    hashCode = (hashCode * 59) + this.Warnings.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ReachableLocationsId
    /// </summary>
    [DataContract(Name = "ReachableLocationsId")]
    public partial class ReachableLocationsId : IEquatable<ReachableLocationsId>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsId" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReachableLocationsId() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsId" /> class.
        /// </summary>
        /// <param name="id">The ID of the calculated reachable locations. (required).</param>
        public ReachableLocationsId(Guid id = default(Guid))
        {
            this.Id = id;
        }
        /// <summary>
        /// The ID of the calculated reachable locations.
        /// </summary>
        /// <value>The ID of the calculated reachable locations.</value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = true)]
        public Guid Id { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableLocationsId {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableLocationsId);
        }
        /// <summary>
        /// Returns true if ReachableLocationsId instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableLocationsId to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableLocationsId input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                {
                    hashCode = (hashCode * 59) + this.Id.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ReachableLocationsResponse
    /// </summary>
    [DataContract(Name = "ReachableLocationsResponse")]
    public partial class ReachableLocationsResponse : IEquatable<ReachableLocationsResponse>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Status
        /// </summary>
        [DataMember(Name = "status", EmitDefaultValue = false)]
        public CalculationStatus? Status { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableLocationsResponse" /> class.
        /// </summary>
        /// <param name="status">status.</param>
        /// <param name="reachableLocations">reachableLocations.</param>
        /// <param name="error">error.</param>
        public ReachableLocationsResponse(CalculationStatus? status = default(CalculationStatus?), ReachableLocations reachableLocations = default(ReachableLocations), ErrorResponse error = default(ErrorResponse))
        {
            this.Status = status;
            this.ReachableLocations = reachableLocations;
            this.Error = error;
        }
        /// <summary>
        /// Gets or Sets ReachableLocations
        /// </summary>
        [DataMember(Name = "reachableLocations", EmitDefaultValue = false)]
        public ReachableLocations ReachableLocations { get; set; }
        /// <summary>
        /// Gets or Sets Error
        /// </summary>
        [DataMember(Name = "error", EmitDefaultValue = false)]
        public ErrorResponse Error { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableLocationsResponse {\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  ReachableLocations: ").Append(ReachableLocations).Append("\n");
            sb.Append("  Error: ").Append(Error).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableLocationsResponse);
        }
        /// <summary>
        /// Returns true if ReachableLocationsResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableLocationsResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableLocationsResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Status == input.Status ||
                    this.Status.Equals(input.Status)
                ) && 
                (
                    this.ReachableLocations == input.ReachableLocations ||
                    (this.ReachableLocations != null &&
                    this.ReachableLocations.Equals(input.ReachableLocations))
                ) && 
                (
                    this.Error == input.Error ||
                    (this.Error != null &&
                    this.Error.Equals(input.Error))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Status.GetHashCode();
                if (this.ReachableLocations != null)
                {
                    hashCode = (hashCode * 59) + this.ReachableLocations.GetHashCode();
                }
                if (this.Error != null)
                {
                    hashCode = (hashCode * 59) + this.Error.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// ReachableOptions
    /// </summary>
    [DataContract(Name = "ReachableOptions")]
    public partial class ReachableOptions : IEquatable<ReachableOptions>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets DrivingDirection
        /// </summary>
        [DataMember(Name = "drivingDirection", EmitDefaultValue = false)]
        public DrivingDirection? DrivingDirection { get; set; }
        /// <summary>
        /// Gets or Sets TrafficMode
        /// </summary>
        [DataMember(Name = "trafficMode", EmitDefaultValue = false)]
        public ReachableTrafficMode? TrafficMode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReachableOptions" /> class.
        /// </summary>
        /// <param name="drivingDirection">drivingDirection.</param>
        /// <param name="referenceTime">Defines the start time for **drivingDirection** _OUTBOUND_ or the arrival time for **drivingDirection** _INBOUND_ formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the waypoint. Responses will contain the offset to UTC specified in the request or that of the waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. For best results it should not be more than one month in the past nor more than six months in the future. See [here](./concepts/date-and-time) for more information on the relevance of date and time..</param>
        /// <param name="trafficMode">trafficMode.</param>
        /// <param name="allowedCountries">Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision..</param>
        /// <param name="prohibitedCountries">Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision..</param>
        /// <param name="blockIntersectingRoads">Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. .</param>
        public ReachableOptions(DrivingDirection? drivingDirection = default(DrivingDirection?), DateTime? referenceTime = default(DateTime?), ReachableTrafficMode? trafficMode = default(ReachableTrafficMode?), string allowedCountries = default(string), string prohibitedCountries = default(string), string blockIntersectingRoads = default(string))
        {
            this.DrivingDirection = drivingDirection;
            this.ReferenceTime = referenceTime;
            this.TrafficMode = trafficMode;
            this.AllowedCountries = allowedCountries;
            this.ProhibitedCountries = prohibitedCountries;
            this.BlockIntersectingRoads = blockIntersectingRoads;
        }
        /// <summary>
        /// Defines the start time for **drivingDirection** _OUTBOUND_ or the arrival time for **drivingDirection** _INBOUND_ formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the waypoint. Responses will contain the offset to UTC specified in the request or that of the waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. For best results it should not be more than one month in the past nor more than six months in the future. See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the start time for **drivingDirection** _OUTBOUND_ or the arrival time for **drivingDirection** _INBOUND_ formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If none of them is specified the current time will be used. If the date-time string does not include an explicit offset to UTC, the time will be interpreted as the local time of the waypoint. Responses will contain the offset to UTC specified in the request or that of the waypoint. The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. For best results it should not be more than one month in the past nor more than six months in the future. See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        /// <example>2020-12-04T06:00Z</example>
        [DataMember(Name = "referenceTime", EmitDefaultValue = true)]
        public DateTime? ReferenceTime { get; set; }
        /// <summary>
        /// Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Comma-separated list of countries the route is allowed to pass. By default, all countries are allowed. If this parameter is present, only these countries are allowed to be passed, i.e. drive only in these countries. This parameter is mutually exclusive with **prohibitedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "allowedCountries", EmitDefaultValue = true)]
        public string AllowedCountries { get; set; }
        /// <summary>
        /// Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Comma-separated list of countries the route must not pass. By default, all countries are allowed. If this parameter is present, all but the given countries are allowed to be passed, i.e. do not drive in these countries. This parameter is mutually exclusive with **allowedCountries**. Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "prohibitedCountries", EmitDefaultValue = true)]
        public string ProhibitedCountries { get; set; }
        /// <summary>
        /// Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. 
        /// </summary>
        /// <value>Pipe-separated list of polylines.   Roads and combined transports that intersect the given polylines will be considered as blocked. Each list element is a polyline. Each point is a coordinate of latitude and longitude. Coordinates and points are separated by a comma. Format: &#x60;&lt;poly1_lat1&gt;,&lt;poly1_lon1&gt;,...,&lt;poly1_latN&gt;,&lt;poly1_lonN&gt;|&lt;poly2_lat1&gt;,&lt;poly2_lon1&gt;,...,&lt;poly2_latN&gt;,&lt;poly2_lonN&gt;|...&#x60;   Notes: * Be aware of the URL length restrictions. * If there is no other route connecting two waypoints the will be reported as violated and correspondingly violation events with type **BLOCKED_ROAD_BY_INTERSECTION** will be reported if violation events are requested. * Requests will be rejected if at least one provided polyline   * does not consist of an even number of coordinates,   * consists of less than two points,   * contains invalid coordinates or   * intersects more than 5000 road segments. </value>
        /// <example>49.8,9.9,49.9,10|33.1,-111.1,33.0,-111.2</example>
        [DataMember(Name = "blockIntersectingRoads", EmitDefaultValue = true)]
        public string BlockIntersectingRoads { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReachableOptions {\n");
            sb.Append("  DrivingDirection: ").Append(DrivingDirection).Append("\n");
            sb.Append("  ReferenceTime: ").Append(ReferenceTime).Append("\n");
            sb.Append("  TrafficMode: ").Append(TrafficMode).Append("\n");
            sb.Append("  AllowedCountries: ").Append(AllowedCountries).Append("\n");
            sb.Append("  ProhibitedCountries: ").Append(ProhibitedCountries).Append("\n");
            sb.Append("  BlockIntersectingRoads: ").Append(BlockIntersectingRoads).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReachableOptions);
        }
        /// <summary>
        /// Returns true if ReachableOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of ReachableOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReachableOptions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.DrivingDirection == input.DrivingDirection ||
                    this.DrivingDirection.Equals(input.DrivingDirection)
                ) && 
                (
                    this.ReferenceTime == input.ReferenceTime ||
                    (this.ReferenceTime != null &&
                    this.ReferenceTime.Equals(input.ReferenceTime))
                ) && 
                (
                    this.TrafficMode == input.TrafficMode ||
                    this.TrafficMode.Equals(input.TrafficMode)
                ) && 
                (
                    this.AllowedCountries == input.AllowedCountries ||
                    (this.AllowedCountries != null &&
                    this.AllowedCountries.Equals(input.AllowedCountries))
                ) && 
                (
                    this.ProhibitedCountries == input.ProhibitedCountries ||
                    (this.ProhibitedCountries != null &&
                    this.ProhibitedCountries.Equals(input.ProhibitedCountries))
                ) && 
                (
                    this.BlockIntersectingRoads == input.BlockIntersectingRoads ||
                    (this.BlockIntersectingRoads != null &&
                    this.BlockIntersectingRoads.Equals(input.BlockIntersectingRoads))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.DrivingDirection.GetHashCode();
                if (this.ReferenceTime != null)
                {
                    hashCode = (hashCode * 59) + this.ReferenceTime.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TrafficMode.GetHashCode();
                if (this.AllowedCountries != null)
                {
                    hashCode = (hashCode * 59) + this.AllowedCountries.GetHashCode();
                }
                if (this.ProhibitedCountries != null)
                {
                    hashCode = (hashCode * 59) + this.ProhibitedCountries.GetHashCode();
                }
                if (this.BlockIntersectingRoads != null)
                {
                    hashCode = (hashCode * 59) + this.BlockIntersectingRoads.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines how to consider traffic in a reachable areas or a reachable locations calculation.  * &#x60;REALISTIC&#x60; - Uses the most realistic **travelTime** and **distance** for the selected vehicle and the  given **referenceTime** (or the current time if none **referenceTime** is specified).  Takes into account the live traffic situation such as traffic jams or road works  as well as the typical traffic situation at the time of day and the day of week of travel such as the rush-hour  on Monday morning or light traffic on Saturday evening.  * &#x60;AVERAGE&#x60; - Uses the average **travelTime** and **distance** for the selected vehicle.  If **referenceTime** is specified, the typical traffic situation for that time of day and day of week will be considered such as the rush-hour  on Monday morning or light traffic on Saturday evening.  If no **referenceTime** is specified the typical traffic situation will not be considered, and **travelTime** and **distance** are an average independent of when to travel.  See [here](./concepts/traffic-modes) for more information. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.
    /// </summary>
    /// <value>Defines how to consider traffic in a reachable areas or a reachable locations calculation.  * &#x60;REALISTIC&#x60; - Uses the most realistic **travelTime** and **distance** for the selected vehicle and the  given **referenceTime** (or the current time if none **referenceTime** is specified).  Takes into account the live traffic situation such as traffic jams or road works  as well as the typical traffic situation at the time of day and the day of week of travel such as the rush-hour  on Monday morning or light traffic on Saturday evening.  * &#x60;AVERAGE&#x60; - Uses the average **travelTime** and **distance** for the selected vehicle.  If **referenceTime** is specified, the typical traffic situation for that time of day and day of week will be considered such as the rush-hour  on Monday morning or light traffic on Saturday evening.  If no **referenceTime** is specified the typical traffic situation will not be considered, and **travelTime** and **distance** are an average independent of when to travel.  See [here](./concepts/traffic-modes) for more information. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ReachableTrafficMode
    {
        /// <summary>
        /// Enum REALISTIC for value: REALISTIC
        /// </summary>
        [EnumMember(Value = "REALISTIC")]
        REALISTIC = 1,
        /// <summary>
        /// Enum AVERAGE for value: AVERAGE
        /// </summary>
        [EnumMember(Value = "AVERAGE")]
        AVERAGE = 2
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The ETA and the remaining distance and travel time to that waypoint.
    /// </summary>
    [DataContract(Name = "RemainingWaypoint")]
    public partial class RemainingWaypoint : IEquatable<RemainingWaypoint>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RemainingWaypoint" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RemainingWaypoint() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RemainingWaypoint" /> class.
        /// </summary>
        /// <param name="name">The name of the waypoint. (required).</param>
        /// <param name="estimatedTimeOfArrival">The estimated time of arrival at the waypoint formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). (required).</param>
        /// <param name="distance">The distance from the current position to the waypoint [m]. (required).</param>
        /// <param name="travelTime">The travel time from the current position to the waypoint [s]. (required).</param>
        /// <param name="trafficDelay">The delay due to live traffic from the current position to the waypoint [s]. (required).</param>
        /// <param name="waitingTime">The waiting time from the current position to the waypoint [s]. (required).</param>
        /// <param name="scheduleViolations">Contains the list of violated schedule restrictions at this waypoint and up to this waypoint. (required).</param>
        public RemainingWaypoint(string name = default(string), DateTime estimatedTimeOfArrival = default(DateTime), int distance = default(int), int travelTime = default(int), int trafficDelay = default(int), int waitingTime = default(int), List<ScheduleViolationType> scheduleViolations = default(List<ScheduleViolationType>))
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for RemainingWaypoint and cannot be null");
            }
            this.Name = name;
            this.EstimatedTimeOfArrival = estimatedTimeOfArrival;
            this.Distance = distance;
            this.TravelTime = travelTime;
            this.TrafficDelay = trafficDelay;
            this.WaitingTime = waitingTime;
            // to ensure "scheduleViolations" is required (not null)
            if (scheduleViolations == null)
            {
                throw new ArgumentNullException("scheduleViolations is a required property for RemainingWaypoint and cannot be null");
            }
            this.ScheduleViolations = scheduleViolations;
        }
        /// <summary>
        /// The name of the waypoint.
        /// </summary>
        /// <value>The name of the waypoint.</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }
        /// <summary>
        /// The estimated time of arrival at the waypoint formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
        /// </summary>
        /// <value>The estimated time of arrival at the waypoint formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).</value>
        [DataMember(Name = "estimatedTimeOfArrival", IsRequired = true, EmitDefaultValue = true)]
        public DateTime EstimatedTimeOfArrival { get; set; }
        /// <summary>
        /// The distance from the current position to the waypoint [m].
        /// </summary>
        /// <value>The distance from the current position to the waypoint [m].</value>
        [DataMember(Name = "distance", IsRequired = true, EmitDefaultValue = true)]
        public int Distance { get; set; }
        /// <summary>
        /// The travel time from the current position to the waypoint [s].
        /// </summary>
        /// <value>The travel time from the current position to the waypoint [s].</value>
        [DataMember(Name = "travelTime", IsRequired = true, EmitDefaultValue = true)]
        public int TravelTime { get; set; }
        /// <summary>
        /// The delay due to live traffic from the current position to the waypoint [s].
        /// </summary>
        /// <value>The delay due to live traffic from the current position to the waypoint [s].</value>
        [DataMember(Name = "trafficDelay", IsRequired = true, EmitDefaultValue = true)]
        public int TrafficDelay { get; set; }
        /// <summary>
        /// The waiting time from the current position to the waypoint [s].
        /// </summary>
        /// <value>The waiting time from the current position to the waypoint [s].</value>
        [DataMember(Name = "waitingTime", IsRequired = true, EmitDefaultValue = true)]
        public int WaitingTime { get; set; }
        /// <summary>
        /// Contains the list of violated schedule restrictions at this waypoint and up to this waypoint.
        /// </summary>
        /// <value>Contains the list of violated schedule restrictions at this waypoint and up to this waypoint.</value>
        [DataMember(Name = "scheduleViolations", IsRequired = true, EmitDefaultValue = true)]
        public List<ScheduleViolationType> ScheduleViolations { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RemainingWaypoint {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  EstimatedTimeOfArrival: ").Append(EstimatedTimeOfArrival).Append("\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TravelTime: ").Append(TravelTime).Append("\n");
            sb.Append("  TrafficDelay: ").Append(TrafficDelay).Append("\n");
            sb.Append("  WaitingTime: ").Append(WaitingTime).Append("\n");
            sb.Append("  ScheduleViolations: ").Append(ScheduleViolations).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RemainingWaypoint);
        }
        /// <summary>
        /// Returns true if RemainingWaypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of RemainingWaypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RemainingWaypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.EstimatedTimeOfArrival == input.EstimatedTimeOfArrival ||
                    (this.EstimatedTimeOfArrival != null &&
                    this.EstimatedTimeOfArrival.Equals(input.EstimatedTimeOfArrival))
                ) && 
                (
                    this.Distance == input.Distance ||
                    this.Distance.Equals(input.Distance)
                ) && 
                (
                    this.TravelTime == input.TravelTime ||
                    this.TravelTime.Equals(input.TravelTime)
                ) && 
                (
                    this.TrafficDelay == input.TrafficDelay ||
                    this.TrafficDelay.Equals(input.TrafficDelay)
                ) && 
                (
                    this.WaitingTime == input.WaitingTime ||
                    this.WaitingTime.Equals(input.WaitingTime)
                ) && 
                (
                    this.ScheduleViolations == input.ScheduleViolations ||
                    this.ScheduleViolations != null &&
                    input.ScheduleViolations != null &&
                    this.ScheduleViolations.SequenceEqual(input.ScheduleViolations)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.EstimatedTimeOfArrival != null)
                {
                    hashCode = (hashCode * 59) + this.EstimatedTimeOfArrival.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                hashCode = (hashCode * 59) + this.TravelTime.GetHashCode();
                hashCode = (hashCode * 59) + this.TrafficDelay.GetHashCode();
                hashCode = (hashCode * 59) + this.WaitingTime.GetHashCode();
                if (this.ScheduleViolations != null)
                {
                    hashCode = (hashCode * 59) + this.ScheduleViolations.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Distance (int) minimum
            if (this.Distance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Distance, must be a value greater than or equal to 0.", new [] { "Distance" });
            }
            // TravelTime (int) minimum
            if (this.TravelTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TravelTime, must be a value greater than or equal to 0.", new [] { "TravelTime" });
            }
            // TrafficDelay (int) minimum
            if (this.TrafficDelay < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TrafficDelay, must be a value greater than or equal to 0.", new [] { "TrafficDelay" });
            }
            // WaitingTime (int) minimum
            if (this.WaitingTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for WaitingTime, must be a value greater than or equal to 0.", new [] { "WaitingTime" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines Results
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum Results
    {
        /// <summary>
        /// Enum ROUTE_ID for value: ROUTE_ID
        /// </summary>
        [EnumMember(Value = "ROUTE_ID")]
        ROUTE_ID = 1,
        /// <summary>
        /// Enum LEGS for value: LEGS
        /// </summary>
        [EnumMember(Value = "LEGS")]
        LEGS = 2,
        /// <summary>
        /// Enum LEGS_POLYLINE for value: LEGS_POLYLINE
        /// </summary>
        [EnumMember(Value = "LEGS_POLYLINE")]
        LEGS_POLYLINE = 3,
        /// <summary>
        /// Enum TOLL_COSTS for value: TOLL_COSTS
        /// </summary>
        [EnumMember(Value = "TOLL_COSTS")]
        TOLL_COSTS = 4,
        /// <summary>
        /// Enum TOLL_SECTIONS for value: TOLL_SECTIONS
        /// </summary>
        [EnumMember(Value = "TOLL_SECTIONS")]
        TOLL_SECTIONS = 5,
        /// <summary>
        /// Enum TOLL_SYSTEMS for value: TOLL_SYSTEMS
        /// </summary>
        [EnumMember(Value = "TOLL_SYSTEMS")]
        TOLL_SYSTEMS = 6,
        /// <summary>
        /// Enum TOLL_EVENTS for value: TOLL_EVENTS
        /// </summary>
        [EnumMember(Value = "TOLL_EVENTS")]
        TOLL_EVENTS = 7,
        /// <summary>
        /// Enum POLYLINE for value: POLYLINE
        /// </summary>
        [EnumMember(Value = "POLYLINE")]
        POLYLINE = 8,
        /// <summary>
        /// Enum MANEUVER_EVENTS for value: MANEUVER_EVENTS
        /// </summary>
        [EnumMember(Value = "MANEUVER_EVENTS")]
        MANEUVER_EVENTS = 9,
        /// <summary>
        /// Enum BORDER_EVENTS for value: BORDER_EVENTS
        /// </summary>
        [EnumMember(Value = "BORDER_EVENTS")]
        BORDER_EVENTS = 10,
        /// <summary>
        /// Enum VIOLATION_EVENTS for value: VIOLATION_EVENTS
        /// </summary>
        [EnumMember(Value = "VIOLATION_EVENTS")]
        VIOLATION_EVENTS = 11,
        /// <summary>
        /// Enum VIOLATION_EVENTS_POLYLINE for value: VIOLATION_EVENTS_POLYLINE
        /// </summary>
        [EnumMember(Value = "VIOLATION_EVENTS_POLYLINE")]
        VIOLATION_EVENTS_POLYLINE = 12,
        /// <summary>
        /// Enum WAYPOINT_EVENTS for value: WAYPOINT_EVENTS
        /// </summary>
        [EnumMember(Value = "WAYPOINT_EVENTS")]
        WAYPOINT_EVENTS = 13,
        /// <summary>
        /// Enum UTC_OFFSET_CHANGE_EVENTS for value: UTC_OFFSET_CHANGE_EVENTS
        /// </summary>
        [EnumMember(Value = "UTC_OFFSET_CHANGE_EVENTS")]
        UTC_OFFSET_CHANGE_EVENTS = 14,
        /// <summary>
        /// Enum COMBINED_TRANSPORT_EVENTS for value: COMBINED_TRANSPORT_EVENTS
        /// </summary>
        [EnumMember(Value = "COMBINED_TRANSPORT_EVENTS")]
        COMBINED_TRANSPORT_EVENTS = 15,
        /// <summary>
        /// Enum TRAFFIC_EVENTS for value: TRAFFIC_EVENTS
        /// </summary>
        [EnumMember(Value = "TRAFFIC_EVENTS")]
        TRAFFIC_EVENTS = 16,
        /// <summary>
        /// Enum TRAFFIC_EVENTS_POLYLINE for value: TRAFFIC_EVENTS_POLYLINE
        /// </summary>
        [EnumMember(Value = "TRAFFIC_EVENTS_POLYLINE")]
        TRAFFIC_EVENTS_POLYLINE = 17,
        /// <summary>
        /// Enum SCHEDULE_EVENTS for value: SCHEDULE_EVENTS
        /// </summary>
        [EnumMember(Value = "SCHEDULE_EVENTS")]
        SCHEDULE_EVENTS = 18,
        /// <summary>
        /// Enum EMISSIONS_EN16258_2012 for value: EMISSIONS_EN16258_2012
        /// </summary>
        [EnumMember(Value = "EMISSIONS_EN16258_2012")]
        EMISSIONS_EN16258_2012 = 19,
        /// <summary>
        /// Enum EMISSIONS_EN16258_2012_HBEFA for value: EMISSIONS_EN16258_2012_HBEFA
        /// </summary>
        [EnumMember(Value = "EMISSIONS_EN16258_2012_HBEFA")]
        EMISSIONS_EN16258_2012_HBEFA = 20,
        /// <summary>
        /// Enum EMISSIONS_ISO14083_2022 for value: EMISSIONS_ISO14083_2022
        /// </summary>
        [EnumMember(Value = "EMISSIONS_ISO14083_2022")]
        EMISSIONS_ISO14083_2022 = 21,
        /// <summary>
        /// Enum EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION for value: EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION
        /// </summary>
        [EnumMember(Value = "EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION")]
        EMISSIONS_ISO14083_2022_DEFAULT_CONSUMPTION = 22,
        /// <summary>
        /// Enum EMISSIONS_ISO14083_2023 for value: EMISSIONS_ISO14083_2023
        /// </summary>
        [EnumMember(Value = "EMISSIONS_ISO14083_2023")]
        EMISSIONS_ISO14083_2023 = 23,
        /// <summary>
        /// Enum EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION for value: EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION
        /// </summary>
        [EnumMember(Value = "EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION")]
        EMISSIONS_ISO14083_2023_DEFAULT_CONSUMPTION = 24,
        /// <summary>
        /// Enum EMISSIONS_FRENCH_CO2E_DECREE_2017_639 for value: EMISSIONS_FRENCH_CO2E_DECREE_2017_639
        /// </summary>
        [EnumMember(Value = "EMISSIONS_FRENCH_CO2E_DECREE_2017_639")]
        EMISSIONS_FRENCH_CO2E_DECREE_2017_639 = 25,
        /// <summary>
        /// Enum ALTERNATIVE_ROUTES for value: ALTERNATIVE_ROUTES
        /// </summary>
        [EnumMember(Value = "ALTERNATIVE_ROUTES")]
        ALTERNATIVE_ROUTES = 26,
        /// <summary>
        /// Enum SCHEDULE_REPORT for value: SCHEDULE_REPORT
        /// </summary>
        [EnumMember(Value = "SCHEDULE_REPORT")]
        SCHEDULE_REPORT = 27,
        /// <summary>
        /// Enum GUIDED_NAVIGATION for value: GUIDED_NAVIGATION
        /// </summary>
        [EnumMember(Value = "GUIDED_NAVIGATION")]
        GUIDED_NAVIGATION = 28,
        /// <summary>
        /// Enum MONETARY_COSTS for value: MONETARY_COSTS
        /// </summary>
        [EnumMember(Value = "MONETARY_COSTS")]
        MONETARY_COSTS = 29
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Use these coordinates for matching to the nearest road. This is useful if the waypoint should not be matched to the nearest possible road but to some road further away, e.g. garage exit at a different road.
    /// </summary>
    [DataContract(Name = "RoadAccess")]
    public partial class RoadAccess : IEquatable<RoadAccess>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadAccess" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RoadAccess() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadAccess" /> class.
        /// </summary>
        /// <param name="latitude">The latitude value in degrees (WGS84/EPSG:4326) from south to north. (required).</param>
        /// <param name="longitude">The longitude value in degrees (WGS84/EPSG:4326) from west to east. (required).</param>
        public RoadAccess(double latitude = default(double), double longitude = default(double))
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
        }
        /// <summary>
        /// The latitude value in degrees (WGS84/EPSG:4326) from south to north.
        /// </summary>
        /// <value>The latitude value in degrees (WGS84/EPSG:4326) from south to north.</value>
        /// <example>49.480301</example>
        [DataMember(Name = "latitude", IsRequired = true, EmitDefaultValue = true)]
        public double Latitude { get; set; }
        /// <summary>
        /// The longitude value in degrees (WGS84/EPSG:4326) from west to east.
        /// </summary>
        /// <value>The longitude value in degrees (WGS84/EPSG:4326) from west to east.</value>
        /// <example>6.110667</example>
        [DataMember(Name = "longitude", IsRequired = true, EmitDefaultValue = true)]
        public double Longitude { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RoadAccess {\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RoadAccess);
        }
        /// <summary>
        /// Returns true if RoadAccess instances are equal
        /// </summary>
        /// <param name="input">Instance of RoadAccess to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RoadAccess input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Latitude == input.Latitude ||
                    this.Latitude.Equals(input.Latitude)
                ) && 
                (
                    this.Longitude == input.Longitude ||
                    this.Longitude.Equals(input.Longitude)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Latitude.GetHashCode();
                hashCode = (hashCode * 59) + this.Longitude.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Latitude (double) maximum
            if (this.Latitude > (double)90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value less than or equal to 90.", new [] { "Latitude" });
            }
            // Latitude (double) minimum
            if (this.Latitude < (double)-90)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Latitude, must be a value greater than or equal to -90.", new [] { "Latitude" });
            }
            // Longitude (double) maximum
            if (this.Longitude > (double)180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value less than or equal to 180.", new [] { "Longitude" });
            }
            // Longitude (double) minimum
            if (this.Longitude < (double)-180)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Longitude, must be a value greater than or equal to -180.", new [] { "Longitude" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Name and number of the road ahead.
    /// </summary>
    [DataContract(Name = "RoadAhead")]
    public partial class RoadAhead : IEquatable<RoadAhead>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadAhead" /> class.
        /// </summary>
        /// <param name="name">The name of the road. It does not depend on the selected language, instead it is presented as it can be found on local signs..</param>
        /// <param name="number">The number of the road which may consist of several numbers separated by \&quot;/\&quot;..</param>
        public RoadAhead(string name = default(string), string number = default(string))
        {
            this.Name = name;
            this.Number = number;
        }
        /// <summary>
        /// The name of the road. It does not depend on the selected language, instead it is presented as it can be found on local signs.
        /// </summary>
        /// <value>The name of the road. It does not depend on the selected language, instead it is presented as it can be found on local signs.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }
        /// <summary>
        /// The number of the road which may consist of several numbers separated by \&quot;/\&quot;.
        /// </summary>
        /// <value>The number of the road which may consist of several numbers separated by \&quot;/\&quot;.</value>
        [DataMember(Name = "number", EmitDefaultValue = false)]
        public string Number { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RoadAhead {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Number: ").Append(Number).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RoadAhead);
        }
        /// <summary>
        /// Returns true if RoadAhead instances are equal
        /// </summary>
        /// <param name="input">Instance of RoadAhead to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RoadAhead input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Number == input.Number ||
                    (this.Number != null &&
                    this.Number.Equals(input.Number))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.Number != null)
                {
                    hashCode = (hashCode * 59) + this.Number.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// RouteRequest
    /// </summary>
    [DataContract(Name = "RouteRequest")]
    public partial class RouteRequest : IEquatable<RouteRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteRequest" /> class.
        /// </summary>
        /// <param name="waypoints">The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.  Each waypoint must either have latitude and longitude or one of the representations combinedTransport, address or place..</param>
        /// <param name="routeId">Instead of the list of waypoints, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information..</param>
        /// <param name="driver">driver.</param>
        public RouteRequest(List<Waypoint> waypoints = default(List<Waypoint>), Guid routeId = default(Guid), DriverBody driver = default(DriverBody))
        {
            this.Waypoints = waypoints;
            this.RouteId = routeId;
            this.Driver = driver;
        }
        /// <summary>
        /// The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.  Each waypoint must either have latitude and longitude or one of the representations combinedTransport, address or place.
        /// </summary>
        /// <value>The list of waypoints the route will be calculated for. At least two waypoints are necessary, a maximum number may apply according to your subscription. The first waypoint is the start and the last is the destination of the route. Additional intermediate waypoints are possible.  Each waypoint must either have latitude and longitude or one of the representations combinedTransport, address or place.</value>
        [DataMember(Name = "waypoints", EmitDefaultValue = false)]
        public List<Waypoint> Waypoints { get; set; }
        /// <summary>
        /// Instead of the list of waypoints, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information.
        /// </summary>
        /// <value>Instead of the list of waypoints, a **routeId** from a previously calculated route or a matched track can be entered. See [here](./concepts/waypoints) for more information.</value>
        [DataMember(Name = "routeId", EmitDefaultValue = false)]
        public Guid RouteId { get; set; }
        /// <summary>
        /// Gets or Sets Driver
        /// </summary>
        [DataMember(Name = "driver", EmitDefaultValue = false)]
        public DriverBody Driver { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RouteRequest {\n");
            sb.Append("  Waypoints: ").Append(Waypoints).Append("\n");
            sb.Append("  RouteId: ").Append(RouteId).Append("\n");
            sb.Append("  Driver: ").Append(Driver).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RouteRequest);
        }
        /// <summary>
        /// Returns true if RouteRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of RouteRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RouteRequest input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Waypoints == input.Waypoints ||
                    this.Waypoints != null &&
                    input.Waypoints != null &&
                    this.Waypoints.SequenceEqual(input.Waypoints)
                ) && 
                (
                    this.RouteId == input.RouteId ||
                    (this.RouteId != null &&
                    this.RouteId.Equals(input.RouteId))
                ) && 
                (
                    this.Driver == input.Driver ||
                    (this.Driver != null &&
                    this.Driver.Equals(input.Driver))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Waypoints != null)
                {
                    hashCode = (hashCode * 59) + this.Waypoints.GetHashCode();
                }
                if (this.RouteId != null)
                {
                    hashCode = (hashCode * 59) + this.RouteId.GetHashCode();
                }
                if (this.Driver != null)
                {
                    hashCode = (hashCode * 59) + this.Driver.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// RouteResponse
    /// </summary>
    [DataContract(Name = "RouteResponse")]
    public partial class RouteResponse : IEquatable<RouteResponse>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteResponse" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RouteResponse() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteResponse" /> class.
        /// </summary>
        /// <param name="distance">The distance of the route [m]. (required).</param>
        /// <param name="travelTime">The travel time for the route [s]. (required).</param>
        /// <param name="trafficDelay">The total delay due to live traffic on the route [s].  This value contains the sum of all traffic events on the route and will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information..</param>
        /// <param name="violated">When there is no valid route for the given vehicle between two waypoints, but the resulting route can be calculated by ignoring a vehicle parameter, the route is marked as violated. When requesting _VIOLATION_EVENTS_ there is a corresponding violation event containing the position, time and the vehicle property in question. (required).</param>
        /// <param name="routeId">The ID of the calculated route..</param>
        /// <param name="legs">The legs of the route..</param>
        /// <param name="toll">toll.</param>
        /// <param name="polyline">The polyline of the route in the format specified by **options[polylineFormat]**..</param>
        /// <param name="events">Detailed information on maneuvers, border crossings and other events along the route in chronological order..</param>
        /// <param name="emissions">emissions.</param>
        /// <param name="alternativeRoutes">Detailed information on alternative routes. Requires _ALTERNATIVE_ROUTES_ to be requested. The array may be empty when no alternative routes are found..</param>
        /// <param name="scheduleReport">scheduleReport.</param>
        /// <param name="guidedNavigation">A base64 encoded representation of the route that can be used for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator). The base64 binary has to be decoded and saved as a text file with the extension .bcr. Requires _GUIDED_NAVIGATION_ to be requested..</param>
        /// <param name="monetaryCosts">monetaryCosts.</param>
        /// <param name="warnings">A list of warnings concerning the validity of the result..</param>
        public RouteResponse(int distance = default(int), int travelTime = default(int), int trafficDelay = default(int), bool violated = default(bool), Guid routeId = default(Guid), List<Leg> legs = default(List<Leg>), Toll toll = default(Toll), string polyline = default(string), List<Event> events = default(List<Event>), Emissions emissions = default(Emissions), List<AlternativeRoute> alternativeRoutes = default(List<AlternativeRoute>), ScheduleReport scheduleReport = default(ScheduleReport), string guidedNavigation = default(string), MonetaryCosts monetaryCosts = default(MonetaryCosts), List<Warning> warnings = default(List<Warning>))
        {
            this.Distance = distance;
            this.TravelTime = travelTime;
            this.Violated = violated;
            this.TrafficDelay = trafficDelay;
            this.RouteId = routeId;
            this.Legs = legs;
            this.Toll = toll;
            this.Polyline = polyline;
            this.Events = events;
            this.Emissions = emissions;
            this.AlternativeRoutes = alternativeRoutes;
            this.ScheduleReport = scheduleReport;
            this.GuidedNavigation = guidedNavigation;
            this.MonetaryCosts = monetaryCosts;
            this.Warnings = warnings;
        }
        /// <summary>
        /// The distance of the route [m].
        /// </summary>
        /// <value>The distance of the route [m].</value>
        /// <example>1422</example>
        [DataMember(Name = "distance", IsRequired = true, EmitDefaultValue = true)]
        public int Distance { get; set; }
        /// <summary>
        /// The travel time for the route [s].
        /// </summary>
        /// <value>The travel time for the route [s].</value>
        /// <example>56</example>
        [DataMember(Name = "travelTime", IsRequired = true, EmitDefaultValue = true)]
        public int TravelTime { get; set; }
        /// <summary>
        /// The total delay due to live traffic on the route [s].  This value contains the sum of all traffic events on the route and will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information.
        /// </summary>
        /// <value>The total delay due to live traffic on the route [s].  This value contains the sum of all traffic events on the route and will be non-zero only if **options[trafficMode]&#x3D;REALISTIC**. See [here](./concepts/traffic-modes) for more information.</value>
        /// <example>0</example>
        [DataMember(Name = "trafficDelay", EmitDefaultValue = false)]
        public int TrafficDelay { get; set; }
        /// <summary>
        /// When there is no valid route for the given vehicle between two waypoints, but the resulting route can be calculated by ignoring a vehicle parameter, the route is marked as violated. When requesting _VIOLATION_EVENTS_ there is a corresponding violation event containing the position, time and the vehicle property in question.
        /// </summary>
        /// <value>When there is no valid route for the given vehicle between two waypoints, but the resulting route can be calculated by ignoring a vehicle parameter, the route is marked as violated. When requesting _VIOLATION_EVENTS_ there is a corresponding violation event containing the position, time and the vehicle property in question.</value>
        /// <example>false</example>
        [DataMember(Name = "violated", IsRequired = true, EmitDefaultValue = true)]
        public bool Violated { get; set; }
        /// <summary>
        /// The ID of the calculated route.
        /// </summary>
        /// <value>The ID of the calculated route.</value>
        [DataMember(Name = "routeId", EmitDefaultValue = false)]
        public Guid RouteId { get; set; }
        /// <summary>
        /// The legs of the route.
        /// </summary>
        /// <value>The legs of the route.</value>
        [DataMember(Name = "legs", EmitDefaultValue = false)]
        public List<Leg> Legs { get; set; }
        /// <summary>
        /// Gets or Sets Toll
        /// </summary>
        [DataMember(Name = "toll", EmitDefaultValue = false)]
        public Toll Toll { get; set; }
        /// <summary>
        /// The polyline of the route in the format specified by **options[polylineFormat]**.
        /// </summary>
        /// <value>The polyline of the route in the format specified by **options[polylineFormat]**.</value>
        [DataMember(Name = "polyline", EmitDefaultValue = false)]
        public string Polyline { get; set; }
        /// <summary>
        /// Detailed information on maneuvers, border crossings and other events along the route in chronological order.
        /// </summary>
        /// <value>Detailed information on maneuvers, border crossings and other events along the route in chronological order.</value>
        [DataMember(Name = "events", EmitDefaultValue = false)]
        public List<Event> Events { get; set; }
        /// <summary>
        /// Gets or Sets Emissions
        /// </summary>
        [DataMember(Name = "emissions", EmitDefaultValue = false)]
        public Emissions Emissions { get; set; }
        /// <summary>
        /// Detailed information on alternative routes. Requires _ALTERNATIVE_ROUTES_ to be requested. The array may be empty when no alternative routes are found.
        /// </summary>
        /// <value>Detailed information on alternative routes. Requires _ALTERNATIVE_ROUTES_ to be requested. The array may be empty when no alternative routes are found.</value>
        [DataMember(Name = "alternativeRoutes", EmitDefaultValue = false)]
        public List<AlternativeRoute> AlternativeRoutes { get; set; }
        /// <summary>
        /// Gets or Sets ScheduleReport
        /// </summary>
        [DataMember(Name = "scheduleReport", EmitDefaultValue = false)]
        public ScheduleReport ScheduleReport { get; set; }
        /// <summary>
        /// A base64 encoded representation of the route that can be used for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator). The base64 binary has to be decoded and saved as a text file with the extension .bcr. Requires _GUIDED_NAVIGATION_ to be requested.
        /// </summary>
        /// <value>A base64 encoded representation of the route that can be used for the [PTV Navigator](https://www.myptv.com/en/logistics-software/ptv-navigator). The base64 binary has to be decoded and saved as a text file with the extension .bcr. Requires _GUIDED_NAVIGATION_ to be requested.</value>
        [DataMember(Name = "guidedNavigation", EmitDefaultValue = false)]
        public string GuidedNavigation { get; set; }
        /// <summary>
        /// Gets or Sets MonetaryCosts
        /// </summary>
        [DataMember(Name = "monetaryCosts", EmitDefaultValue = false)]
        public MonetaryCosts MonetaryCosts { get; set; }
        /// <summary>
        /// A list of warnings concerning the validity of the result.
        /// </summary>
        /// <value>A list of warnings concerning the validity of the result.</value>
        [DataMember(Name = "warnings", EmitDefaultValue = false)]
        public List<Warning> Warnings { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RouteResponse {\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TravelTime: ").Append(TravelTime).Append("\n");
            sb.Append("  TrafficDelay: ").Append(TrafficDelay).Append("\n");
            sb.Append("  Violated: ").Append(Violated).Append("\n");
            sb.Append("  RouteId: ").Append(RouteId).Append("\n");
            sb.Append("  Legs: ").Append(Legs).Append("\n");
            sb.Append("  Toll: ").Append(Toll).Append("\n");
            sb.Append("  Polyline: ").Append(Polyline).Append("\n");
            sb.Append("  Events: ").Append(Events).Append("\n");
            sb.Append("  Emissions: ").Append(Emissions).Append("\n");
            sb.Append("  AlternativeRoutes: ").Append(AlternativeRoutes).Append("\n");
            sb.Append("  ScheduleReport: ").Append(ScheduleReport).Append("\n");
            sb.Append("  GuidedNavigation: ").Append(GuidedNavigation).Append("\n");
            sb.Append("  MonetaryCosts: ").Append(MonetaryCosts).Append("\n");
            sb.Append("  Warnings: ").Append(Warnings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RouteResponse);
        }
        /// <summary>
        /// Returns true if RouteResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of RouteResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RouteResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Distance == input.Distance ||
                    this.Distance.Equals(input.Distance)
                ) && 
                (
                    this.TravelTime == input.TravelTime ||
                    this.TravelTime.Equals(input.TravelTime)
                ) && 
                (
                    this.TrafficDelay == input.TrafficDelay ||
                    this.TrafficDelay.Equals(input.TrafficDelay)
                ) && 
                (
                    this.Violated == input.Violated ||
                    this.Violated.Equals(input.Violated)
                ) && 
                (
                    this.RouteId == input.RouteId ||
                    (this.RouteId != null &&
                    this.RouteId.Equals(input.RouteId))
                ) && 
                (
                    this.Legs == input.Legs ||
                    this.Legs != null &&
                    input.Legs != null &&
                    this.Legs.SequenceEqual(input.Legs)
                ) && 
                (
                    this.Toll == input.Toll ||
                    (this.Toll != null &&
                    this.Toll.Equals(input.Toll))
                ) && 
                (
                    this.Polyline == input.Polyline ||
                    (this.Polyline != null &&
                    this.Polyline.Equals(input.Polyline))
                ) && 
                (
                    this.Events == input.Events ||
                    this.Events != null &&
                    input.Events != null &&
                    this.Events.SequenceEqual(input.Events)
                ) && 
                (
                    this.Emissions == input.Emissions ||
                    (this.Emissions != null &&
                    this.Emissions.Equals(input.Emissions))
                ) && 
                (
                    this.AlternativeRoutes == input.AlternativeRoutes ||
                    this.AlternativeRoutes != null &&
                    input.AlternativeRoutes != null &&
                    this.AlternativeRoutes.SequenceEqual(input.AlternativeRoutes)
                ) && 
                (
                    this.ScheduleReport == input.ScheduleReport ||
                    (this.ScheduleReport != null &&
                    this.ScheduleReport.Equals(input.ScheduleReport))
                ) && 
                (
                    this.GuidedNavigation == input.GuidedNavigation ||
                    (this.GuidedNavigation != null &&
                    this.GuidedNavigation.Equals(input.GuidedNavigation))
                ) && 
                (
                    this.MonetaryCosts == input.MonetaryCosts ||
                    (this.MonetaryCosts != null &&
                    this.MonetaryCosts.Equals(input.MonetaryCosts))
                ) && 
                (
                    this.Warnings == input.Warnings ||
                    this.Warnings != null &&
                    input.Warnings != null &&
                    this.Warnings.SequenceEqual(input.Warnings)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                hashCode = (hashCode * 59) + this.TravelTime.GetHashCode();
                hashCode = (hashCode * 59) + this.TrafficDelay.GetHashCode();
                hashCode = (hashCode * 59) + this.Violated.GetHashCode();
                if (this.RouteId != null)
                {
                    hashCode = (hashCode * 59) + this.RouteId.GetHashCode();
                }
                if (this.Legs != null)
                {
                    hashCode = (hashCode * 59) + this.Legs.GetHashCode();
                }
                if (this.Toll != null)
                {
                    hashCode = (hashCode * 59) + this.Toll.GetHashCode();
                }
                if (this.Polyline != null)
                {
                    hashCode = (hashCode * 59) + this.Polyline.GetHashCode();
                }
                if (this.Events != null)
                {
                    hashCode = (hashCode * 59) + this.Events.GetHashCode();
                }
                if (this.Emissions != null)
                {
                    hashCode = (hashCode * 59) + this.Emissions.GetHashCode();
                }
                if (this.AlternativeRoutes != null)
                {
                    hashCode = (hashCode * 59) + this.AlternativeRoutes.GetHashCode();
                }
                if (this.ScheduleReport != null)
                {
                    hashCode = (hashCode * 59) + this.ScheduleReport.GetHashCode();
                }
                if (this.GuidedNavigation != null)
                {
                    hashCode = (hashCode * 59) + this.GuidedNavigation.GetHashCode();
                }
                if (this.MonetaryCosts != null)
                {
                    hashCode = (hashCode * 59) + this.MonetaryCosts.GetHashCode();
                }
                if (this.Warnings != null)
                {
                    hashCode = (hashCode * 59) + this.Warnings.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Distance (int) minimum
            if (this.Distance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Distance, must be a value greater than or equal to 0.", new [] { "Distance" });
            }
            // TravelTime (int) minimum
            if (this.TravelTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TravelTime, must be a value greater than or equal to 0.", new [] { "TravelTime" });
            }
            // TrafficDelay (int) minimum
            if (this.TrafficDelay < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TrafficDelay, must be a value greater than or equal to 0.", new [] { "TrafficDelay" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Specifies which objective function should be used for the route calculation.   * _FAST_ is the default which returns a route considering a tradeoff between distance an travel time. All vehicle-specific restrictions are properly considered and violated only, if no other route can be found. * _SHORT_ returns a route which is probably shorter but accepting longer travel times. The resulting route is still sensible and can be driven with the given vehicle, but it may disregard restrictions like driving through residential areas. * _MONETARY_ assigns monetary costs to each road segment according the provided cost parameters and the vehicles properties like its consumption. Furthermore, toll costs are integrated as well. See [here](./concepts/monetary-costs) for more information.
    /// </summary>
    /// <value>Specifies which objective function should be used for the route calculation.   * _FAST_ is the default which returns a route considering a tradeoff between distance an travel time. All vehicle-specific restrictions are properly considered and violated only, if no other route can be found. * _SHORT_ returns a route which is probably shorter but accepting longer travel times. The resulting route is still sensible and can be driven with the given vehicle, but it may disregard restrictions like driving through residential areas. * _MONETARY_ assigns monetary costs to each road segment according the provided cost parameters and the vehicles properties like its consumption. Furthermore, toll costs are integrated as well. See [here](./concepts/monetary-costs) for more information.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum RoutingMode
    {
        /// <summary>
        /// Enum FAST for value: FAST
        /// </summary>
        [EnumMember(Value = "FAST")]
        FAST = 1,
        /// <summary>
        /// Enum SHORT for value: SHORT
        /// </summary>
        [EnumMember(Value = "SHORT")]
        SHORT = 2,
        /// <summary>
        /// Enum MONETARY for value: MONETARY
        /// </summary>
        [EnumMember(Value = "MONETARY")]
        MONETARY = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when the driver has to take a break or a rest, perform service or wait for a waypoint to open. Requires _SCHEDULE_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "ScheduleEvent")]
    public partial class ScheduleEvent : IEquatable<ScheduleEvent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ScheduleEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ScheduleEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ScheduleEvent" /> class.
        /// </summary>
        /// <param name="duration">The duration [s]. (required).</param>
        /// <param name="scheduleTypes">Tells what happens at this position of the route.  (required).</param>
        public ScheduleEvent(int duration = default(int), List<ScheduleType> scheduleTypes = default(List<ScheduleType>))
        {
            this.Duration = duration;
            // to ensure "scheduleTypes" is required (not null)
            if (scheduleTypes == null)
            {
                throw new ArgumentNullException("scheduleTypes is a required property for ScheduleEvent and cannot be null");
            }
            this.ScheduleTypes = scheduleTypes;
        }
        /// <summary>
        /// The duration [s].
        /// </summary>
        /// <value>The duration [s].</value>
        [DataMember(Name = "duration", IsRequired = true, EmitDefaultValue = true)]
        public int Duration { get; set; }
        /// <summary>
        /// Tells what happens at this position of the route. 
        /// </summary>
        /// <value>Tells what happens at this position of the route. </value>
        [DataMember(Name = "scheduleTypes", IsRequired = true, EmitDefaultValue = true)]
        public List<ScheduleType> ScheduleTypes { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ScheduleEvent {\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  ScheduleTypes: ").Append(ScheduleTypes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ScheduleEvent);
        }
        /// <summary>
        /// Returns true if ScheduleEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of ScheduleEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ScheduleEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Duration == input.Duration ||
                    this.Duration.Equals(input.Duration)
                ) && 
                (
                    this.ScheduleTypes == input.ScheduleTypes ||
                    this.ScheduleTypes != null &&
                    input.ScheduleTypes != null &&
                    this.ScheduleTypes.SequenceEqual(input.ScheduleTypes)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Duration.GetHashCode();
                if (this.ScheduleTypes != null)
                {
                    hashCode = (hashCode * 59) + this.ScheduleTypes.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Duration (int) minimum
            if (this.Duration < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Duration, must be a value greater than or equal to 0.", new [] { "Duration" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Provides an overview of the times of the schedule of this route including break and rest times. Requires _SCHELDULE_REPORT_ to be requested.
    /// </summary>
    [DataContract(Name = "ScheduleReport")]
    public partial class ScheduleReport : IEquatable<ScheduleReport>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ScheduleReport" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ScheduleReport() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ScheduleReport" /> class.
        /// </summary>
        /// <param name="startTime">The start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Only present with **options[trafficMode]** _REALISTIC_ or when **options[startTime]** is specified..</param>
        /// <param name="endTime">The end time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Only present with **options[trafficMode]** _REALISTIC_ or when **options[startTime]** is specified..</param>
        /// <param name="drivingTime">The total driving time of the route [s]. (required).</param>
        /// <param name="serviceTime">The total service time of the route [s]. (required).</param>
        /// <param name="waitingTime">The total waiting time of the route [s]. (required).</param>
        /// <param name="breakTime">The total break time of the route [s]. (required).</param>
        /// <param name="restTime">The total rest time of the route [s]. (required).</param>
        public ScheduleReport(DateTime startTime = default(DateTime), DateTime endTime = default(DateTime), int drivingTime = default(int), int serviceTime = default(int), int waitingTime = default(int), int breakTime = default(int), int restTime = default(int))
        {
            this.DrivingTime = drivingTime;
            this.ServiceTime = serviceTime;
            this.WaitingTime = waitingTime;
            this.BreakTime = breakTime;
            this.RestTime = restTime;
            this.StartTime = startTime;
            this.EndTime = endTime;
        }
        /// <summary>
        /// The start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Only present with **options[trafficMode]** _REALISTIC_ or when **options[startTime]** is specified.
        /// </summary>
        /// <value>The start time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Only present with **options[trafficMode]** _REALISTIC_ or when **options[startTime]** is specified.</value>
        [DataMember(Name = "startTime", EmitDefaultValue = false)]
        public DateTime StartTime { get; set; }
        /// <summary>
        /// The end time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Only present with **options[trafficMode]** _REALISTIC_ or when **options[startTime]** is specified.
        /// </summary>
        /// <value>The end time of the route formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). Only present with **options[trafficMode]** _REALISTIC_ or when **options[startTime]** is specified.</value>
        [DataMember(Name = "endTime", EmitDefaultValue = false)]
        public DateTime EndTime { get; set; }
        /// <summary>
        /// The total driving time of the route [s].
        /// </summary>
        /// <value>The total driving time of the route [s].</value>
        [DataMember(Name = "drivingTime", IsRequired = true, EmitDefaultValue = true)]
        public int DrivingTime { get; set; }
        /// <summary>
        /// The total service time of the route [s].
        /// </summary>
        /// <value>The total service time of the route [s].</value>
        [DataMember(Name = "serviceTime", IsRequired = true, EmitDefaultValue = true)]
        public int ServiceTime { get; set; }
        /// <summary>
        /// The total waiting time of the route [s].
        /// </summary>
        /// <value>The total waiting time of the route [s].</value>
        [DataMember(Name = "waitingTime", IsRequired = true, EmitDefaultValue = true)]
        public int WaitingTime { get; set; }
        /// <summary>
        /// The total break time of the route [s].
        /// </summary>
        /// <value>The total break time of the route [s].</value>
        [DataMember(Name = "breakTime", IsRequired = true, EmitDefaultValue = true)]
        public int BreakTime { get; set; }
        /// <summary>
        /// The total rest time of the route [s].
        /// </summary>
        /// <value>The total rest time of the route [s].</value>
        [DataMember(Name = "restTime", IsRequired = true, EmitDefaultValue = true)]
        public int RestTime { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ScheduleReport {\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  EndTime: ").Append(EndTime).Append("\n");
            sb.Append("  DrivingTime: ").Append(DrivingTime).Append("\n");
            sb.Append("  ServiceTime: ").Append(ServiceTime).Append("\n");
            sb.Append("  WaitingTime: ").Append(WaitingTime).Append("\n");
            sb.Append("  BreakTime: ").Append(BreakTime).Append("\n");
            sb.Append("  RestTime: ").Append(RestTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ScheduleReport);
        }
        /// <summary>
        /// Returns true if ScheduleReport instances are equal
        /// </summary>
        /// <param name="input">Instance of ScheduleReport to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ScheduleReport input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.StartTime == input.StartTime ||
                    (this.StartTime != null &&
                    this.StartTime.Equals(input.StartTime))
                ) && 
                (
                    this.EndTime == input.EndTime ||
                    (this.EndTime != null &&
                    this.EndTime.Equals(input.EndTime))
                ) && 
                (
                    this.DrivingTime == input.DrivingTime ||
                    this.DrivingTime.Equals(input.DrivingTime)
                ) && 
                (
                    this.ServiceTime == input.ServiceTime ||
                    this.ServiceTime.Equals(input.ServiceTime)
                ) && 
                (
                    this.WaitingTime == input.WaitingTime ||
                    this.WaitingTime.Equals(input.WaitingTime)
                ) && 
                (
                    this.BreakTime == input.BreakTime ||
                    this.BreakTime.Equals(input.BreakTime)
                ) && 
                (
                    this.RestTime == input.RestTime ||
                    this.RestTime.Equals(input.RestTime)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.StartTime != null)
                {
                    hashCode = (hashCode * 59) + this.StartTime.GetHashCode();
                }
                if (this.EndTime != null)
                {
                    hashCode = (hashCode * 59) + this.EndTime.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.DrivingTime.GetHashCode();
                hashCode = (hashCode * 59) + this.ServiceTime.GetHashCode();
                hashCode = (hashCode * 59) + this.WaitingTime.GetHashCode();
                hashCode = (hashCode * 59) + this.BreakTime.GetHashCode();
                hashCode = (hashCode * 59) + this.RestTime.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // DrivingTime (int) minimum
            if (this.DrivingTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DrivingTime, must be a value greater than or equal to 0.", new [] { "DrivingTime" });
            }
            // ServiceTime (int) minimum
            if (this.ServiceTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ServiceTime, must be a value greater than or equal to 0.", new [] { "ServiceTime" });
            }
            // WaitingTime (int) minimum
            if (this.WaitingTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for WaitingTime, must be a value greater than or equal to 0.", new [] { "WaitingTime" });
            }
            // BreakTime (int) minimum
            if (this.BreakTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for BreakTime, must be a value greater than or equal to 0.", new [] { "BreakTime" });
            }
            // RestTime (int) minimum
            if (this.RestTime < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RestTime, must be a value greater than or equal to 0.", new [] { "RestTime" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines ScheduleType
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ScheduleType
    {
        /// <summary>
        /// Enum BREAK for value: BREAK
        /// </summary>
        [EnumMember(Value = "BREAK")]
        BREAK = 1,
        /// <summary>
        /// Enum DAILY_REST for value: DAILY_REST
        /// </summary>
        [EnumMember(Value = "DAILY_REST")]
        DAILY_REST = 2,
        /// <summary>
        /// Enum WAITING for value: WAITING
        /// </summary>
        [EnumMember(Value = "WAITING")]
        WAITING = 3,
        /// <summary>
        /// Enum SERVICE for value: SERVICE
        /// </summary>
        [EnumMember(Value = "SERVICE")]
        SERVICE = 4
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines ScheduleViolationType
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ScheduleViolationType
    {
        /// <summary>
        /// Enum OPENING_INTERVAL for value: OPENING_INTERVAL
        /// </summary>
        [EnumMember(Value = "OPENING_INTERVAL")]
        OPENING_INTERVAL = 1,
        /// <summary>
        /// Enum MAXIMUM_TRAVEL_TIME for value: MAXIMUM_TRAVEL_TIME
        /// </summary>
        [EnumMember(Value = "MAXIMUM_TRAVEL_TIME")]
        MAXIMUM_TRAVEL_TIME = 2,
        /// <summary>
        /// Enum MAXIMUM_DRIVING_TIME for value: MAXIMUM_DRIVING_TIME
        /// </summary>
        [EnumMember(Value = "MAXIMUM_DRIVING_TIME")]
        MAXIMUM_DRIVING_TIME = 3
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// A time interval specified by two points in time - the beginning and the end of the interval.
    /// </summary>
    [DataContract(Name = "TimeInterval")]
    public partial class TimeInterval : IEquatable<TimeInterval>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeInterval" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TimeInterval() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeInterval" /> class.
        /// </summary>
        /// <param name="start">The beginning of the time interval formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. (required).</param>
        /// <param name="end">The end of the time interval formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00. (required).</param>
        public TimeInterval(DateTime start = default(DateTime), DateTime end = default(DateTime))
        {
            this.Start = start;
            this.End = end;
        }
        /// <summary>
        /// The beginning of the time interval formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.
        /// </summary>
        /// <value>The beginning of the time interval formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.</value>
        /// <example>2020-12-07T00:00Z</example>
        [DataMember(Name = "start", IsRequired = true, EmitDefaultValue = true)]
        public DateTime Start { get; set; }
        /// <summary>
        /// The end of the time interval formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.
        /// </summary>
        /// <value>The end of the time interval formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.</value>
        /// <example>2020-12-07T01:00Z</example>
        [DataMember(Name = "end", IsRequired = true, EmitDefaultValue = true)]
        public DateTime End { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TimeInterval {\n");
            sb.Append("  Start: ").Append(Start).Append("\n");
            sb.Append("  End: ").Append(End).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TimeInterval);
        }
        /// <summary>
        /// Returns true if TimeInterval instances are equal
        /// </summary>
        /// <param name="input">Instance of TimeInterval to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TimeInterval input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Start == input.Start ||
                    (this.Start != null &&
                    this.Start.Equals(input.Start))
                ) && 
                (
                    this.End == input.End ||
                    (this.End != null &&
                    this.End.Equals(input.End))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Start != null)
                {
                    hashCode = (hashCode * 59) + this.Start.GetHashCode();
                }
                if (this.End != null)
                {
                    hashCode = (hashCode * 59) + this.End.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Detailed information on the toll costs, providers and tariff information.   Toll prices do not include VAT. 
    /// </summary>
    [DataContract(Name = "Toll")]
    public partial class Toll : IEquatable<Toll>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Toll" /> class.
        /// </summary>
        /// <param name="costs">costs.</param>
        /// <param name="sections">The list of toll sections defined by the toll operators..</param>
        /// <param name="systems">The list of toll systems defined by the toll operators..</param>
        /// <param name="currencies">currencies.</param>
        public Toll(TollCosts costs = default(TollCosts), List<TollSection> sections = default(List<TollSection>), List<TollSystem> systems = default(List<TollSystem>), Currencies currencies = default(Currencies))
        {
            this.Costs = costs;
            this.Sections = sections;
            this.Systems = systems;
            this.Currencies = currencies;
        }
        /// <summary>
        /// Gets or Sets Costs
        /// </summary>
        [DataMember(Name = "costs", EmitDefaultValue = false)]
        public TollCosts Costs { get; set; }
        /// <summary>
        /// The list of toll sections defined by the toll operators.
        /// </summary>
        /// <value>The list of toll sections defined by the toll operators.</value>
        [DataMember(Name = "sections", EmitDefaultValue = false)]
        public List<TollSection> Sections { get; set; }
        /// <summary>
        /// The list of toll systems defined by the toll operators.
        /// </summary>
        /// <value>The list of toll systems defined by the toll operators.</value>
        [DataMember(Name = "systems", EmitDefaultValue = false)]
        public List<TollSystem> Systems { get; set; }
        /// <summary>
        /// Gets or Sets Currencies
        /// </summary>
        [DataMember(Name = "currencies", EmitDefaultValue = false)]
        public Currencies Currencies { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Toll {\n");
            sb.Append("  Costs: ").Append(Costs).Append("\n");
            sb.Append("  Sections: ").Append(Sections).Append("\n");
            sb.Append("  Systems: ").Append(Systems).Append("\n");
            sb.Append("  Currencies: ").Append(Currencies).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Toll);
        }
        /// <summary>
        /// Returns true if Toll instances are equal
        /// </summary>
        /// <param name="input">Instance of Toll to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Toll input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Costs == input.Costs ||
                    (this.Costs != null &&
                    this.Costs.Equals(input.Costs))
                ) && 
                (
                    this.Sections == input.Sections ||
                    this.Sections != null &&
                    input.Sections != null &&
                    this.Sections.SequenceEqual(input.Sections)
                ) && 
                (
                    this.Systems == input.Systems ||
                    this.Systems != null &&
                    input.Systems != null &&
                    this.Systems.SequenceEqual(input.Systems)
                ) && 
                (
                    this.Currencies == input.Currencies ||
                    (this.Currencies != null &&
                    this.Currencies.Equals(input.Currencies))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Costs != null)
                {
                    hashCode = (hashCode * 59) + this.Costs.GetHashCode();
                }
                if (this.Sections != null)
                {
                    hashCode = (hashCode * 59) + this.Sections.GetHashCode();
                }
                if (this.Systems != null)
                {
                    hashCode = (hashCode * 59) + this.Systems.GetHashCode();
                }
                if (this.Currencies != null)
                {
                    hashCode = (hashCode * 59) + this.Currencies.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The toll prices payable for this route or leg aggregated by currency.
    /// </summary>
    [DataContract(Name = "TollCosts")]
    public partial class TollCosts : IEquatable<TollCosts>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TollCosts" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollCosts() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollCosts" /> class.
        /// </summary>
        /// <param name="prices">The toll prices payable in the given currencies. The price may be 0 if no toll applies for a currency in a country passed by the route. (required).</param>
        /// <param name="convertedPrice">convertedPrice.</param>
        /// <param name="countries">The toll prices by country or subdivision. The price may be 0 if no toll applies in a country passed by the route. (required).</param>
        public TollCosts(List<TollPrice> prices = default(List<TollPrice>), TollPrice convertedPrice = default(TollPrice), List<TollCostsByCountry> countries = default(List<TollCostsByCountry>))
        {
            // to ensure "prices" is required (not null)
            if (prices == null)
            {
                throw new ArgumentNullException("prices is a required property for TollCosts and cannot be null");
            }
            this.Prices = prices;
            // to ensure "countries" is required (not null)
            if (countries == null)
            {
                throw new ArgumentNullException("countries is a required property for TollCosts and cannot be null");
            }
            this.Countries = countries;
            this.ConvertedPrice = convertedPrice;
        }
        /// <summary>
        /// The toll prices payable in the given currencies. The price may be 0 if no toll applies for a currency in a country passed by the route.
        /// </summary>
        /// <value>The toll prices payable in the given currencies. The price may be 0 if no toll applies for a currency in a country passed by the route.</value>
        [DataMember(Name = "prices", IsRequired = true, EmitDefaultValue = true)]
        public List<TollPrice> Prices { get; set; }
        /// <summary>
        /// Gets or Sets ConvertedPrice
        /// </summary>
        [DataMember(Name = "convertedPrice", EmitDefaultValue = false)]
        public TollPrice ConvertedPrice { get; set; }
        /// <summary>
        /// The toll prices by country or subdivision. The price may be 0 if no toll applies in a country passed by the route.
        /// </summary>
        /// <value>The toll prices by country or subdivision. The price may be 0 if no toll applies in a country passed by the route.</value>
        [DataMember(Name = "countries", IsRequired = true, EmitDefaultValue = true)]
        public List<TollCostsByCountry> Countries { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollCosts {\n");
            sb.Append("  Prices: ").Append(Prices).Append("\n");
            sb.Append("  ConvertedPrice: ").Append(ConvertedPrice).Append("\n");
            sb.Append("  Countries: ").Append(Countries).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollCosts);
        }
        /// <summary>
        /// Returns true if TollCosts instances are equal
        /// </summary>
        /// <param name="input">Instance of TollCosts to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollCosts input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Prices == input.Prices ||
                    this.Prices != null &&
                    input.Prices != null &&
                    this.Prices.SequenceEqual(input.Prices)
                ) && 
                (
                    this.ConvertedPrice == input.ConvertedPrice ||
                    (this.ConvertedPrice != null &&
                    this.ConvertedPrice.Equals(input.ConvertedPrice))
                ) && 
                (
                    this.Countries == input.Countries ||
                    this.Countries != null &&
                    input.Countries != null &&
                    this.Countries.SequenceEqual(input.Countries)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Prices != null)
                {
                    hashCode = (hashCode * 59) + this.Prices.GetHashCode();
                }
                if (this.ConvertedPrice != null)
                {
                    hashCode = (hashCode * 59) + this.ConvertedPrice.GetHashCode();
                }
                if (this.Countries != null)
                {
                    hashCode = (hashCode * 59) + this.Countries.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// TollCostsByCountry
    /// </summary>
    [DataContract(Name = "TollCostsByCountry")]
    public partial class TollCostsByCountry : IEquatable<TollCostsByCountry>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TollCostsByCountry" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollCostsByCountry() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollCostsByCountry" /> class.
        /// </summary>
        /// <param name="countryCode">Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. (required).</param>
        /// <param name="price">price (required).</param>
        /// <param name="convertedPrice">convertedPrice.</param>
        public TollCostsByCountry(string countryCode = default(string), TollPrice price = default(TollPrice), TollPrice convertedPrice = default(TollPrice))
        {
            // to ensure "countryCode" is required (not null)
            if (countryCode == null)
            {
                throw new ArgumentNullException("countryCode is a required property for TollCostsByCountry and cannot be null");
            }
            this.CountryCode = countryCode;
            // to ensure "price" is required (not null)
            if (price == null)
            {
                throw new ArgumentNullException("price is a required property for TollCostsByCountry and cannot be null");
            }
            this.Price = price;
            this.ConvertedPrice = convertedPrice;
        }
        /// <summary>
        /// Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "countryCode", IsRequired = true, EmitDefaultValue = true)]
        public string CountryCode { get; set; }
        /// <summary>
        /// Gets or Sets Price
        /// </summary>
        [DataMember(Name = "price", IsRequired = true, EmitDefaultValue = true)]
        public TollPrice Price { get; set; }
        /// <summary>
        /// Gets or Sets ConvertedPrice
        /// </summary>
        [DataMember(Name = "convertedPrice", EmitDefaultValue = false)]
        public TollPrice ConvertedPrice { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollCostsByCountry {\n");
            sb.Append("  CountryCode: ").Append(CountryCode).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  ConvertedPrice: ").Append(ConvertedPrice).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollCostsByCountry);
        }
        /// <summary>
        /// Returns true if TollCostsByCountry instances are equal
        /// </summary>
        /// <param name="input">Instance of TollCostsByCountry to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollCostsByCountry input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.CountryCode == input.CountryCode ||
                    (this.CountryCode != null &&
                    this.CountryCode.Equals(input.CountryCode))
                ) && 
                (
                    this.Price == input.Price ||
                    (this.Price != null &&
                    this.Price.Equals(input.Price))
                ) && 
                (
                    this.ConvertedPrice == input.ConvertedPrice ||
                    (this.ConvertedPrice != null &&
                    this.ConvertedPrice.Equals(input.ConvertedPrice))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CountryCode != null)
                {
                    hashCode = (hashCode * 59) + this.CountryCode.GetHashCode();
                }
                if (this.Price != null)
                {
                    hashCode = (hashCode * 59) + this.Price.GetHashCode();
                }
                if (this.ConvertedPrice != null)
                {
                    hashCode = (hashCode * 59) + this.ConvertedPrice.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when a road subject to toll is entered or exited. Requires _TOLL_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "TollEvent")]
    public partial class TollEvent : IEquatable<TollEvent>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets AccessType
        /// </summary>
        [DataMember(Name = "accessType", IsRequired = true, EmitDefaultValue = true)]
        public AccessType AccessType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollEvent" /> class.
        /// </summary>
        /// <param name="sectionIndex">The index of the corresponding toll section.  The section indexes of a pair of ENTER and EXIT events define the range of sections between the two events..</param>
        /// <param name="displayName">The display name of the toll event. Only present if a name is available. For example, this name can be a toll location name defined by the toll operator. In some cases the display names of the toll event and the toll section can differ..</param>
        /// <param name="accessType">accessType (required).</param>
        /// <param name="relatedEventIndex">For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise..</param>
        public TollEvent(int sectionIndex = default(int), string displayName = default(string), AccessType accessType = default(AccessType), int relatedEventIndex = default(int))
        {
            this.AccessType = accessType;
            this.SectionIndex = sectionIndex;
            this.DisplayName = displayName;
            this.RelatedEventIndex = relatedEventIndex;
        }
        /// <summary>
        /// The index of the corresponding toll section.  The section indexes of a pair of ENTER and EXIT events define the range of sections between the two events.
        /// </summary>
        /// <value>The index of the corresponding toll section.  The section indexes of a pair of ENTER and EXIT events define the range of sections between the two events.</value>
        [DataMember(Name = "sectionIndex", EmitDefaultValue = false)]
        public int SectionIndex { get; set; }
        /// <summary>
        /// The display name of the toll event. Only present if a name is available. For example, this name can be a toll location name defined by the toll operator. In some cases the display names of the toll event and the toll section can differ.
        /// </summary>
        /// <value>The display name of the toll event. Only present if a name is available. For example, this name can be a toll location name defined by the toll operator. In some cases the display names of the toll event and the toll section can differ.</value>
        [DataMember(Name = "displayName", EmitDefaultValue = false)]
        public string DisplayName { get; set; }
        /// <summary>
        /// For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.
        /// </summary>
        /// <value>For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.</value>
        [DataMember(Name = "relatedEventIndex", EmitDefaultValue = false)]
        public int RelatedEventIndex { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollEvent {\n");
            sb.Append("  SectionIndex: ").Append(SectionIndex).Append("\n");
            sb.Append("  DisplayName: ").Append(DisplayName).Append("\n");
            sb.Append("  AccessType: ").Append(AccessType).Append("\n");
            sb.Append("  RelatedEventIndex: ").Append(RelatedEventIndex).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollEvent);
        }
        /// <summary>
        /// Returns true if TollEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of TollEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.SectionIndex == input.SectionIndex ||
                    this.SectionIndex.Equals(input.SectionIndex)
                ) && 
                (
                    this.DisplayName == input.DisplayName ||
                    (this.DisplayName != null &&
                    this.DisplayName.Equals(input.DisplayName))
                ) && 
                (
                    this.AccessType == input.AccessType ||
                    this.AccessType.Equals(input.AccessType)
                ) && 
                (
                    this.RelatedEventIndex == input.RelatedEventIndex ||
                    this.RelatedEventIndex.Equals(input.RelatedEventIndex)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.SectionIndex.GetHashCode();
                if (this.DisplayName != null)
                {
                    hashCode = (hashCode * 59) + this.DisplayName.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AccessType.GetHashCode();
                hashCode = (hashCode * 59) + this.RelatedEventIndex.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // SectionIndex (int) minimum
            if (this.SectionIndex < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for SectionIndex, must be a value greater than or equal to 0.", new [] { "SectionIndex" });
            }
            // RelatedEventIndex (int) minimum
            if (this.RelatedEventIndex < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RelatedEventIndex, must be a value greater than or equal to 0.", new [] { "RelatedEventIndex" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The toll price payable in this country.
    /// </summary>
    [DataContract(Name = "TollPrice")]
    public partial class TollPrice : IEquatable<TollPrice>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TollPrice" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollPrice() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollPrice" /> class.
        /// </summary>
        /// <param name="price">The toll price in the specified currency. (required).</param>
        /// <param name="currency">The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). (required).</param>
        public TollPrice(double price = default(double), string currency = default(string))
        {
            this.Price = price;
            // to ensure "currency" is required (not null)
            if (currency == null)
            {
                throw new ArgumentNullException("currency is a required property for TollPrice and cannot be null");
            }
            this.Currency = currency;
        }
        /// <summary>
        /// The toll price in the specified currency.
        /// </summary>
        /// <value>The toll price in the specified currency.</value>
        /// <example>12.91</example>
        [DataMember(Name = "price", IsRequired = true, EmitDefaultValue = true)]
        public double Price { get; set; }
        /// <summary>
        /// The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
        /// </summary>
        /// <value>The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).</value>
        /// <example>EUR</example>
        [DataMember(Name = "currency", IsRequired = true, EmitDefaultValue = true)]
        public string Currency { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollPrice {\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollPrice);
        }
        /// <summary>
        /// Returns true if TollPrice instances are equal
        /// </summary>
        /// <param name="input">Instance of TollPrice to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollPrice input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Price == input.Price ||
                    this.Price.Equals(input.Price)
                ) && 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Price.GetHashCode();
                if (this.Currency != null)
                {
                    hashCode = (hashCode * 59) + this.Currency.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Price (double) minimum
            if (this.Price < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Price, must be a value greater than or equal to 0.", new [] { "Price" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The reason why toll is charged.    * &#x60;GENERAL&#x60; - A general toll road where no special toll applies.    * &#x60;CITY&#x60; - An urban area or city is subject to toll.    * &#x60;BRIDGE&#x60; - A bridge is subject to toll.    * &#x60;TUNNEL&#x60; - A tunnel is subject to toll.    * &#x60;FERRY&#x60; - A ferry is subject to toll.    * &#x60;MOUNTAIN_PASS&#x60; - A mountain pass is subject to toll.  
    /// </summary>
    /// <value>The reason why toll is charged.    * &#x60;GENERAL&#x60; - A general toll road where no special toll applies.    * &#x60;CITY&#x60; - An urban area or city is subject to toll.    * &#x60;BRIDGE&#x60; - A bridge is subject to toll.    * &#x60;TUNNEL&#x60; - A tunnel is subject to toll.    * &#x60;FERRY&#x60; - A ferry is subject to toll.    * &#x60;MOUNTAIN_PASS&#x60; - A mountain pass is subject to toll.  </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum TollRoadType
    {
        /// <summary>
        /// Enum GENERAL for value: GENERAL
        /// </summary>
        [EnumMember(Value = "GENERAL")]
        GENERAL = 1,
        /// <summary>
        /// Enum CITY for value: CITY
        /// </summary>
        [EnumMember(Value = "CITY")]
        CITY = 2,
        /// <summary>
        /// Enum BRIDGE for value: BRIDGE
        /// </summary>
        [EnumMember(Value = "BRIDGE")]
        BRIDGE = 3,
        /// <summary>
        /// Enum TUNNEL for value: TUNNEL
        /// </summary>
        [EnumMember(Value = "TUNNEL")]
        TUNNEL = 4,
        /// <summary>
        /// Enum FERRY for value: FERRY
        /// </summary>
        [EnumMember(Value = "FERRY")]
        FERRY = 5,
        /// <summary>
        /// Enum MOUNTAIN_PASS for value: MOUNTAIN_PASS
        /// </summary>
        [EnumMember(Value = "MOUNTAIN_PASS")]
        MOUNTAIN_PASS = 6
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// TollSection
    /// </summary>
    [DataContract(Name = "TollSection")]
    public partial class TollSection : IEquatable<TollSection>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets TollRoadType
        /// </summary>
        [DataMember(Name = "tollRoadType", IsRequired = true, EmitDefaultValue = true)]
        public TollRoadType TollRoadType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollSection" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollSection() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollSection" /> class.
        /// </summary>
        /// <param name="costs">The toll costs payable for this section. If different prices according to the payment method exist, this list contains one item for each price. The first item contains the price used to calculate the total toll costs for the route. Further items are alternative costs for the section with different payment methods or different subscriptions. (required).</param>
        /// <param name="tollRoadType">tollRoadType (required).</param>
        /// <param name="tollSystemIndex">The index in the list of toll systems this toll section belongs to..</param>
        /// <param name="countryCode">Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision. (required).</param>
        /// <param name="displayName">A name that describes this toll section. It can relate to the names of the road intersections, to the area in general or to the type of toll..</param>
        /// <param name="officialDistance">The official distance defined by the toll operator [m].  It may be different from the travel distance. Only present if the toll operator provides an official distance..</param>
        /// <param name="calculatedDistance">The calculated distance of the toll section on the current route.  It may be different from the official distance..</param>
        public TollSection(List<TollSectionCost> costs = default(List<TollSectionCost>), TollRoadType tollRoadType = default(TollRoadType), int tollSystemIndex = default(int), string countryCode = default(string), string displayName = default(string), int officialDistance = default(int), int calculatedDistance = default(int))
        {
            // to ensure "costs" is required (not null)
            if (costs == null)
            {
                throw new ArgumentNullException("costs is a required property for TollSection and cannot be null");
            }
            this.Costs = costs;
            this.TollRoadType = tollRoadType;
            // to ensure "countryCode" is required (not null)
            if (countryCode == null)
            {
                throw new ArgumentNullException("countryCode is a required property for TollSection and cannot be null");
            }
            this.CountryCode = countryCode;
            this.TollSystemIndex = tollSystemIndex;
            this.DisplayName = displayName;
            this.OfficialDistance = officialDistance;
            this.CalculatedDistance = calculatedDistance;
        }
        /// <summary>
        /// The toll costs payable for this section. If different prices according to the payment method exist, this list contains one item for each price. The first item contains the price used to calculate the total toll costs for the route. Further items are alternative costs for the section with different payment methods or different subscriptions.
        /// </summary>
        /// <value>The toll costs payable for this section. If different prices according to the payment method exist, this list contains one item for each price. The first item contains the price used to calculate the total toll costs for the route. Further items are alternative costs for the section with different payment methods or different subscriptions.</value>
        [DataMember(Name = "costs", IsRequired = true, EmitDefaultValue = true)]
        public List<TollSectionCost> Costs { get; set; }
        /// <summary>
        /// The index in the list of toll systems this toll section belongs to.
        /// </summary>
        /// <value>The index in the list of toll systems this toll section belongs to.</value>
        [DataMember(Name = "tollSystemIndex", EmitDefaultValue = false)]
        public int TollSystemIndex { get; set; }
        /// <summary>
        /// Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.
        /// </summary>
        /// <value>Countries are represented according to their [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) if referring to a subdivision.</value>
        [DataMember(Name = "countryCode", IsRequired = true, EmitDefaultValue = true)]
        public string CountryCode { get; set; }
        /// <summary>
        /// A name that describes this toll section. It can relate to the names of the road intersections, to the area in general or to the type of toll.
        /// </summary>
        /// <value>A name that describes this toll section. It can relate to the names of the road intersections, to the area in general or to the type of toll.</value>
        [DataMember(Name = "displayName", EmitDefaultValue = false)]
        public string DisplayName { get; set; }
        /// <summary>
        /// The official distance defined by the toll operator [m].  It may be different from the travel distance. Only present if the toll operator provides an official distance.
        /// </summary>
        /// <value>The official distance defined by the toll operator [m].  It may be different from the travel distance. Only present if the toll operator provides an official distance.</value>
        /// <example>142</example>
        [DataMember(Name = "officialDistance", EmitDefaultValue = false)]
        public int OfficialDistance { get; set; }
        /// <summary>
        /// The calculated distance of the toll section on the current route.  It may be different from the official distance.
        /// </summary>
        /// <value>The calculated distance of the toll section on the current route.  It may be different from the official distance.</value>
        /// <example>141</example>
        [DataMember(Name = "calculatedDistance", EmitDefaultValue = false)]
        public int CalculatedDistance { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollSection {\n");
            sb.Append("  Costs: ").Append(Costs).Append("\n");
            sb.Append("  TollRoadType: ").Append(TollRoadType).Append("\n");
            sb.Append("  TollSystemIndex: ").Append(TollSystemIndex).Append("\n");
            sb.Append("  CountryCode: ").Append(CountryCode).Append("\n");
            sb.Append("  DisplayName: ").Append(DisplayName).Append("\n");
            sb.Append("  OfficialDistance: ").Append(OfficialDistance).Append("\n");
            sb.Append("  CalculatedDistance: ").Append(CalculatedDistance).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollSection);
        }
        /// <summary>
        /// Returns true if TollSection instances are equal
        /// </summary>
        /// <param name="input">Instance of TollSection to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollSection input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Costs == input.Costs ||
                    this.Costs != null &&
                    input.Costs != null &&
                    this.Costs.SequenceEqual(input.Costs)
                ) && 
                (
                    this.TollRoadType == input.TollRoadType ||
                    this.TollRoadType.Equals(input.TollRoadType)
                ) && 
                (
                    this.TollSystemIndex == input.TollSystemIndex ||
                    this.TollSystemIndex.Equals(input.TollSystemIndex)
                ) && 
                (
                    this.CountryCode == input.CountryCode ||
                    (this.CountryCode != null &&
                    this.CountryCode.Equals(input.CountryCode))
                ) && 
                (
                    this.DisplayName == input.DisplayName ||
                    (this.DisplayName != null &&
                    this.DisplayName.Equals(input.DisplayName))
                ) && 
                (
                    this.OfficialDistance == input.OfficialDistance ||
                    this.OfficialDistance.Equals(input.OfficialDistance)
                ) && 
                (
                    this.CalculatedDistance == input.CalculatedDistance ||
                    this.CalculatedDistance.Equals(input.CalculatedDistance)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Costs != null)
                {
                    hashCode = (hashCode * 59) + this.Costs.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TollRoadType.GetHashCode();
                hashCode = (hashCode * 59) + this.TollSystemIndex.GetHashCode();
                if (this.CountryCode != null)
                {
                    hashCode = (hashCode * 59) + this.CountryCode.GetHashCode();
                }
                if (this.DisplayName != null)
                {
                    hashCode = (hashCode * 59) + this.DisplayName.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.OfficialDistance.GetHashCode();
                hashCode = (hashCode * 59) + this.CalculatedDistance.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // TollSystemIndex (int) minimum
            if (this.TollSystemIndex < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TollSystemIndex, must be a value greater than or equal to 0.", new [] { "TollSystemIndex" });
            }
            // OfficialDistance (int) minimum
            if (this.OfficialDistance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for OfficialDistance, must be a value greater than or equal to 0.", new [] { "OfficialDistance" });
            }
            // CalculatedDistance (int) minimum
            if (this.CalculatedDistance < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculatedDistance, must be a value greater than or equal to 0.", new [] { "CalculatedDistance" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// TollSectionCost
    /// </summary>
    [DataContract(Name = "TollSectionCost")]
    public partial class TollSectionCost : IEquatable<TollSectionCost>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TollSectionCost" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollSectionCost() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollSectionCost" /> class.
        /// </summary>
        /// <param name="price">The price in the specified currency. (required).</param>
        /// <param name="currency">The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). (required).</param>
        /// <param name="paymentMethods">The payment methods for toll costs.    * &#x60;ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION&#x60; - Electronic toll collection system with a subscription required.    * &#x60;ELECTRONIC_TOLL_COLLECTION&#x60; - Electronic toll collection system with no subscription required.    * &#x60;CASH&#x60; - Cash payment at a toll booth.    * &#x60;CREDIT_CARD&#x60; - Credit card payment at a toll booth..</param>
        /// <param name="etcSubscriptions">The required electronic toll collection subscriptions for the payment method ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION..</param>
        /// <param name="convertedPrice">convertedPrice.</param>
        public TollSectionCost(double price = default(double), string currency = default(string), List<PaymentMethod> paymentMethods = default(List<PaymentMethod>), List<string> etcSubscriptions = default(List<string>), TollPrice convertedPrice = default(TollPrice))
        {
            this.Price = price;
            // to ensure "currency" is required (not null)
            if (currency == null)
            {
                throw new ArgumentNullException("currency is a required property for TollSectionCost and cannot be null");
            }
            this.Currency = currency;
            this.PaymentMethods = paymentMethods;
            this.EtcSubscriptions = etcSubscriptions;
            this.ConvertedPrice = convertedPrice;
        }
        /// <summary>
        /// The price in the specified currency.
        /// </summary>
        /// <value>The price in the specified currency.</value>
        [DataMember(Name = "price", IsRequired = true, EmitDefaultValue = true)]
        public double Price { get; set; }
        /// <summary>
        /// The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
        /// </summary>
        /// <value>The currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).</value>
        [DataMember(Name = "currency", IsRequired = true, EmitDefaultValue = true)]
        public string Currency { get; set; }
        /// <summary>
        /// The payment methods for toll costs.    * &#x60;ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION&#x60; - Electronic toll collection system with a subscription required.    * &#x60;ELECTRONIC_TOLL_COLLECTION&#x60; - Electronic toll collection system with no subscription required.    * &#x60;CASH&#x60; - Cash payment at a toll booth.    * &#x60;CREDIT_CARD&#x60; - Credit card payment at a toll booth.
        /// </summary>
        /// <value>The payment methods for toll costs.    * &#x60;ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION&#x60; - Electronic toll collection system with a subscription required.    * &#x60;ELECTRONIC_TOLL_COLLECTION&#x60; - Electronic toll collection system with no subscription required.    * &#x60;CASH&#x60; - Cash payment at a toll booth.    * &#x60;CREDIT_CARD&#x60; - Credit card payment at a toll booth.</value>
        [DataMember(Name = "paymentMethods", EmitDefaultValue = false)]
        public List<PaymentMethod> PaymentMethods { get; set; }
        /// <summary>
        /// The required electronic toll collection subscriptions for the payment method ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION.
        /// </summary>
        /// <value>The required electronic toll collection subscriptions for the payment method ELECTRONIC_TOLL_COLLECTION_SUBSCRIPTION.</value>
        [DataMember(Name = "etcSubscriptions", EmitDefaultValue = false)]
        public List<string> EtcSubscriptions { get; set; }
        /// <summary>
        /// Gets or Sets ConvertedPrice
        /// </summary>
        [DataMember(Name = "convertedPrice", EmitDefaultValue = false)]
        public TollPrice ConvertedPrice { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollSectionCost {\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  PaymentMethods: ").Append(PaymentMethods).Append("\n");
            sb.Append("  EtcSubscriptions: ").Append(EtcSubscriptions).Append("\n");
            sb.Append("  ConvertedPrice: ").Append(ConvertedPrice).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollSectionCost);
        }
        /// <summary>
        /// Returns true if TollSectionCost instances are equal
        /// </summary>
        /// <param name="input">Instance of TollSectionCost to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollSectionCost input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Price == input.Price ||
                    this.Price.Equals(input.Price)
                ) && 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                ) && 
                (
                    this.PaymentMethods == input.PaymentMethods ||
                    this.PaymentMethods != null &&
                    input.PaymentMethods != null &&
                    this.PaymentMethods.SequenceEqual(input.PaymentMethods)
                ) && 
                (
                    this.EtcSubscriptions == input.EtcSubscriptions ||
                    this.EtcSubscriptions != null &&
                    input.EtcSubscriptions != null &&
                    this.EtcSubscriptions.SequenceEqual(input.EtcSubscriptions)
                ) && 
                (
                    this.ConvertedPrice == input.ConvertedPrice ||
                    (this.ConvertedPrice != null &&
                    this.ConvertedPrice.Equals(input.ConvertedPrice))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Price.GetHashCode();
                if (this.Currency != null)
                {
                    hashCode = (hashCode * 59) + this.Currency.GetHashCode();
                }
                if (this.PaymentMethods != null)
                {
                    hashCode = (hashCode * 59) + this.PaymentMethods.GetHashCode();
                }
                if (this.EtcSubscriptions != null)
                {
                    hashCode = (hashCode * 59) + this.EtcSubscriptions.GetHashCode();
                }
                if (this.ConvertedPrice != null)
                {
                    hashCode = (hashCode * 59) + this.ConvertedPrice.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Price (double) minimum
            if (this.Price < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Price, must be a value greater than or equal to 0.", new [] { "Price" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// TollSystem
    /// </summary>
    [DataContract(Name = "TollSystem")]
    public partial class TollSystem : IEquatable<TollSystem>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TollSystem" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TollSystem() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TollSystem" /> class.
        /// </summary>
        /// <param name="name">The name of the toll system. (required).</param>
        /// <param name="operatorName">The name of the toll operator..</param>
        /// <param name="tariffVersion">The tariff version that has been used..</param>
        /// <param name="tariffVersionValidFrom">The starting date of the tariff version validity formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339)..</param>
        public TollSystem(string name = default(string), string operatorName = default(string), string tariffVersion = default(string), DateTime tariffVersionValidFrom = default(DateTime))
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for TollSystem and cannot be null");
            }
            this.Name = name;
            this.OperatorName = operatorName;
            this.TariffVersion = tariffVersion;
            this.TariffVersionValidFrom = tariffVersionValidFrom;
        }
        /// <summary>
        /// The name of the toll system.
        /// </summary>
        /// <value>The name of the toll system.</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }
        /// <summary>
        /// The name of the toll operator.
        /// </summary>
        /// <value>The name of the toll operator.</value>
        [DataMember(Name = "operatorName", EmitDefaultValue = false)]
        public string OperatorName { get; set; }
        /// <summary>
        /// The tariff version that has been used.
        /// </summary>
        /// <value>The tariff version that has been used.</value>
        [DataMember(Name = "tariffVersion", EmitDefaultValue = false)]
        public string TariffVersion { get; set; }
        /// <summary>
        /// The starting date of the tariff version validity formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
        /// </summary>
        /// <value>The starting date of the tariff version validity formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).</value>
        [DataMember(Name = "tariffVersionValidFrom", EmitDefaultValue = false)]
        public DateTime TariffVersionValidFrom { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TollSystem {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  OperatorName: ").Append(OperatorName).Append("\n");
            sb.Append("  TariffVersion: ").Append(TariffVersion).Append("\n");
            sb.Append("  TariffVersionValidFrom: ").Append(TariffVersionValidFrom).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TollSystem);
        }
        /// <summary>
        /// Returns true if TollSystem instances are equal
        /// </summary>
        /// <param name="input">Instance of TollSystem to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TollSystem input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.OperatorName == input.OperatorName ||
                    (this.OperatorName != null &&
                    this.OperatorName.Equals(input.OperatorName))
                ) && 
                (
                    this.TariffVersion == input.TariffVersion ||
                    (this.TariffVersion != null &&
                    this.TariffVersion.Equals(input.TariffVersion))
                ) && 
                (
                    this.TariffVersionValidFrom == input.TariffVersionValidFrom ||
                    (this.TariffVersionValidFrom != null &&
                    this.TariffVersionValidFrom.Equals(input.TariffVersionValidFrom))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.OperatorName != null)
                {
                    hashCode = (hashCode * 59) + this.OperatorName.GetHashCode();
                }
                if (this.TariffVersion != null)
                {
                    hashCode = (hashCode * 59) + this.TariffVersion.GetHashCode();
                }
                if (this.TariffVersionValidFrom != null)
                {
                    hashCode = (hashCode * 59) + this.TariffVersionValidFrom.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when the route passes a road for which live traffic data contain an incident such as a traffic jam. Requires _TRAFFIC_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "TrafficEvent")]
    public partial class TrafficEvent : IEquatable<TrafficEvent>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets AccessType
        /// </summary>
        [DataMember(Name = "accessType", IsRequired = true, EmitDefaultValue = true)]
        public AccessType AccessType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TrafficEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TrafficEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TrafficEvent" /> class.
        /// </summary>
        /// <param name="delay">The delay due to this incident [s]. (required).</param>
        /// <param name="description">The description of the incident in the language specified by the parameter **options[language]**. .</param>
        /// <param name="language">The language of the description, if the given language is not supported for this incident. Not present otherwise..</param>
        /// <param name="accessType">accessType (required).</param>
        /// <param name="relatedEventIndex">For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise..</param>
        /// <param name="polyline">The polyline of the traffic event in the format specified by **options[polylineFormat]**. Only present for **accessType** _ENTER_. Requires _TRAFFIC_EVENTS_POLYLINE_ to be requested..</param>
        public TrafficEvent(int delay = default(int), string description = default(string), string language = default(string), AccessType accessType = default(AccessType), int relatedEventIndex = default(int), string polyline = default(string))
        {
            this.Delay = delay;
            this.AccessType = accessType;
            this.Description = description;
            this.Language = language;
            this.RelatedEventIndex = relatedEventIndex;
            this.Polyline = polyline;
        }
        /// <summary>
        /// The delay due to this incident [s].
        /// </summary>
        /// <value>The delay due to this incident [s].</value>
        [DataMember(Name = "delay", IsRequired = true, EmitDefaultValue = true)]
        public int Delay { get; set; }
        /// <summary>
        /// The description of the incident in the language specified by the parameter **options[language]**. 
        /// </summary>
        /// <value>The description of the incident in the language specified by the parameter **options[language]**. </value>
        [DataMember(Name = "description", EmitDefaultValue = false)]
        public string Description { get; set; }
        /// <summary>
        /// The language of the description, if the given language is not supported for this incident. Not present otherwise.
        /// </summary>
        /// <value>The language of the description, if the given language is not supported for this incident. Not present otherwise.</value>
        [DataMember(Name = "language", EmitDefaultValue = false)]
        public string Language { get; set; }
        /// <summary>
        /// For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.
        /// </summary>
        /// <value>For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.</value>
        [DataMember(Name = "relatedEventIndex", EmitDefaultValue = false)]
        public int RelatedEventIndex { get; set; }
        /// <summary>
        /// The polyline of the traffic event in the format specified by **options[polylineFormat]**. Only present for **accessType** _ENTER_. Requires _TRAFFIC_EVENTS_POLYLINE_ to be requested.
        /// </summary>
        /// <value>The polyline of the traffic event in the format specified by **options[polylineFormat]**. Only present for **accessType** _ENTER_. Requires _TRAFFIC_EVENTS_POLYLINE_ to be requested.</value>
        [DataMember(Name = "polyline", EmitDefaultValue = false)]
        public string Polyline { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TrafficEvent {\n");
            sb.Append("  Delay: ").Append(Delay).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Language: ").Append(Language).Append("\n");
            sb.Append("  AccessType: ").Append(AccessType).Append("\n");
            sb.Append("  RelatedEventIndex: ").Append(RelatedEventIndex).Append("\n");
            sb.Append("  Polyline: ").Append(Polyline).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TrafficEvent);
        }
        /// <summary>
        /// Returns true if TrafficEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of TrafficEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TrafficEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Delay == input.Delay ||
                    this.Delay.Equals(input.Delay)
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.Language == input.Language ||
                    (this.Language != null &&
                    this.Language.Equals(input.Language))
                ) && 
                (
                    this.AccessType == input.AccessType ||
                    this.AccessType.Equals(input.AccessType)
                ) && 
                (
                    this.RelatedEventIndex == input.RelatedEventIndex ||
                    this.RelatedEventIndex.Equals(input.RelatedEventIndex)
                ) && 
                (
                    this.Polyline == input.Polyline ||
                    (this.Polyline != null &&
                    this.Polyline.Equals(input.Polyline))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Delay.GetHashCode();
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.Language != null)
                {
                    hashCode = (hashCode * 59) + this.Language.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AccessType.GetHashCode();
                hashCode = (hashCode * 59) + this.RelatedEventIndex.GetHashCode();
                if (this.Polyline != null)
                {
                    hashCode = (hashCode * 59) + this.Polyline.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Language != null) {
                // Language (string) pattern
                Regex regexLanguage = new Regex(@"[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*", RegexOptions.CultureInvariant);
                if (!regexLanguage.Match(this.Language).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Language, must match a pattern of " + regexLanguage, new [] { "Language" });
                }
            }
            // RelatedEventIndex (int) minimum
            if (this.RelatedEventIndex < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RelatedEventIndex, must be a value greater than or equal to 0.", new [] { "RelatedEventIndex" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines how to consider traffic in a route calculation.  * &#x60;REALISTIC&#x60; - Returns the most realistic **travelTime** and **distance** for the selected vehicle and the  given **startTime** or **arrivalTime** (or the current time if none of them is specified).  Takes into account the live traffic situation such as traffic jams or road works  as well as the typical traffic situation at the time of day and the day of week of travel such as the rush-hour  on Monday morning or light traffic on Saturday evening.  * &#x60;AVERAGE&#x60; - Returns the average **travelTime** and **distance** for the selected vehicle.  If **startTime** or **arrivalTime** is specified, the typical traffic situation for that time of day and day of week will be considered such as the rush-hour  on Monday morning or light traffic on Saturday evening. Toll will be calculated according to that date and time.  If none of them is specified the typical traffic situation will not be considered, and **travelTime** and **distance** are an average independent of when to travel.  Toll will be calculated for an arbitrary Monday at noon.  See [here](./concepts/traffic-modes) for more information. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.
    /// </summary>
    /// <value>Defines how to consider traffic in a route calculation.  * &#x60;REALISTIC&#x60; - Returns the most realistic **travelTime** and **distance** for the selected vehicle and the  given **startTime** or **arrivalTime** (or the current time if none of them is specified).  Takes into account the live traffic situation such as traffic jams or road works  as well as the typical traffic situation at the time of day and the day of week of travel such as the rush-hour  on Monday morning or light traffic on Saturday evening.  * &#x60;AVERAGE&#x60; - Returns the average **travelTime** and **distance** for the selected vehicle.  If **startTime** or **arrivalTime** is specified, the typical traffic situation for that time of day and day of week will be considered such as the rush-hour  on Monday morning or light traffic on Saturday evening. Toll will be calculated according to that date and time.  If none of them is specified the typical traffic situation will not be considered, and **travelTime** and **distance** are an average independent of when to travel.  Toll will be calculated for an arbitrary Monday at noon.  See [here](./concepts/traffic-modes) for more information. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum TrafficMode
    {
        /// <summary>
        /// Enum REALISTIC for value: REALISTIC
        /// </summary>
        [EnumMember(Value = "REALISTIC")]
        REALISTIC = 1,
        /// <summary>
        /// Enum AVERAGE for value: AVERAGE
        /// </summary>
        [EnumMember(Value = "AVERAGE")]
        AVERAGE = 2
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines TruckRoutes
    /// </summary>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum TruckRoutes
    {
        /// <summary>
        /// Enum DE_LKWUEBERLSTVAUSNV for value: DE_LKWUEBERLSTVAUSNV
        /// </summary>
        [EnumMember(Value = "DE_LKWUEBERLSTVAUSNV")]
        DE_LKWUEBERLSTVAUSNV = 1,
        /// <summary>
        /// Enum NL_LZV for value: NL_LZV
        /// </summary>
        [EnumMember(Value = "NL_LZV")]
        NL_LZV = 2,
        /// <summary>
        /// Enum NZ_HPMV for value: NZ_HPMV
        /// </summary>
        [EnumMember(Value = "NZ_HPMV")]
        NZ_HPMV = 3,
        /// <summary>
        /// Enum SE_BK_1 for value: SE_BK_1
        /// </summary>
        [EnumMember(Value = "SE_BK_1")]
        SE_BK_1 = 4,
        /// <summary>
        /// Enum SE_BK_2 for value: SE_BK_2
        /// </summary>
        [EnumMember(Value = "SE_BK_2")]
        SE_BK_2 = 5,
        /// <summary>
        /// Enum SE_BK_3 for value: SE_BK_3
        /// </summary>
        [EnumMember(Value = "SE_BK_3")]
        SE_BK_3 = 6,
        /// <summary>
        /// Enum SE_BK_4 for value: SE_BK_4
        /// </summary>
        [EnumMember(Value = "SE_BK_4")]
        SE_BK_4 = 7,
        /// <summary>
        /// Enum US_STAA for value: US_STAA
        /// </summary>
        [EnumMember(Value = "US_STAA")]
        US_STAA = 8,
        /// <summary>
        /// Enum US_TD for value: US_TD
        /// </summary>
        [EnumMember(Value = "US_TD")]
        US_TD = 9,
        /// <summary>
        /// Enum AU_B_DOUBLE for value: AU_B_DOUBLE
        /// </summary>
        [EnumMember(Value = "AU_B_DOUBLE")]
        AU_B_DOUBLE = 10,
        /// <summary>
        /// Enum AU_B_DOUBLE_HML for value: AU_B_DOUBLE_HML
        /// </summary>
        [EnumMember(Value = "AU_B_DOUBLE_HML")]
        AU_B_DOUBLE_HML = 11,
        /// <summary>
        /// Enum AU_B_TRIPLE for value: AU_B_TRIPLE
        /// </summary>
        [EnumMember(Value = "AU_B_TRIPLE")]
        AU_B_TRIPLE = 12,
        /// <summary>
        /// Enum AU_B_TRIPLE_HML for value: AU_B_TRIPLE_HML
        /// </summary>
        [EnumMember(Value = "AU_B_TRIPLE_HML")]
        AU_B_TRIPLE_HML = 13,
        /// <summary>
        /// Enum AU_AB_TRIPLE for value: AU_AB_TRIPLE
        /// </summary>
        [EnumMember(Value = "AU_AB_TRIPLE")]
        AU_AB_TRIPLE = 14,
        /// <summary>
        /// Enum AU_AB_TRIPLE_HML for value: AU_AB_TRIPLE_HML
        /// </summary>
        [EnumMember(Value = "AU_AB_TRIPLE_HML")]
        AU_AB_TRIPLE_HML = 15,
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 16
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The tunnel restriction code according to ADR (European Agreement Concerning the International Carriage of Dangerous Goods by Road) depending on the load of the vehicle.  Relevant for &#x60;routing&#x60;. 
    /// </summary>
    /// <value>The tunnel restriction code according to ADR (European Agreement Concerning the International Carriage of Dangerous Goods by Road) depending on the load of the vehicle.  Relevant for &#x60;routing&#x60;. </value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum TunnelRestrictionCode
    {
        /// <summary>
        /// Enum NONE for value: NONE
        /// </summary>
        [EnumMember(Value = "NONE")]
        NONE = 1,
        /// <summary>
        /// Enum B for value: B
        /// </summary>
        [EnumMember(Value = "B")]
        B = 2,
        /// <summary>
        /// Enum C for value: C
        /// </summary>
        [EnumMember(Value = "C")]
        C = 3,
        /// <summary>
        /// Enum D for value: D
        /// </summary>
        [EnumMember(Value = "D")]
        D = 4,
        /// <summary>
        /// Enum E for value: E
        /// </summary>
        [EnumMember(Value = "E")]
        E = 5
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when the offset to UTC changes, mostly when traveling into a different time zone. Requires _UTC_OFFSET_CHANGE_EVENTS_ to be requested.    Changing the UTC offset does not necessarily mean to change the time zone. Vice-versa changing the time zone does not necessarily mean to change the UTC offset. There are some special cases to consider.  *  The UTC offset may change even within a time zone when the route takes place exactly when the daylight-saving time changes.  *  The UTC offset may not change when changing the time zone. In Canada, for example, there are regions which do not use DST   so that the neighboring time zone has the same UTC offset in summer.
    /// </summary>
    [DataContract(Name = "UTCOffsetChangeEvent")]
    public partial class UTCOffsetChangeEvent : IEquatable<UTCOffsetChangeEvent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UTCOffsetChangeEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected UTCOffsetChangeEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UTCOffsetChangeEvent" /> class.
        /// </summary>
        /// <param name="utcOffset">The new UTC offset [min]. (required).</param>
        public UTCOffsetChangeEvent(int utcOffset = default(int))
        {
            this.UtcOffset = utcOffset;
        }
        /// <summary>
        /// The new UTC offset [min].
        /// </summary>
        /// <value>The new UTC offset [min].</value>
        [DataMember(Name = "utcOffset", IsRequired = true, EmitDefaultValue = true)]
        public int UtcOffset { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class UTCOffsetChangeEvent {\n");
            sb.Append("  UtcOffset: ").Append(UtcOffset).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as UTCOffsetChangeEvent);
        }
        /// <summary>
        /// Returns true if UTCOffsetChangeEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of UTCOffsetChangeEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(UTCOffsetChangeEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.UtcOffset == input.UtcOffset ||
                    this.UtcOffset.Equals(input.UtcOffset)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.UtcOffset.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // UtcOffset (int) maximum
            if (this.UtcOffset > (int)840)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UtcOffset, must be a value less than or equal to 840.", new [] { "UtcOffset" });
            }
            // UtcOffset (int) minimum
            if (this.UtcOffset < (int)-720)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UtcOffset, must be a value greater than or equal to -720.", new [] { "UtcOffset" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Vehicle
    /// </summary>
    [DataContract(Name = "Vehicle")]
    public partial class Vehicle : IEquatable<Vehicle>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets EngineType
        /// </summary>
        [DataMember(Name = "engineType", EmitDefaultValue = true)]
        public EngineType? EngineType { get; set; }
        /// <summary>
        /// Gets or Sets FuelType
        /// </summary>
        [DataMember(Name = "fuelType", EmitDefaultValue = true)]
        public FuelType? FuelType { get; set; }
        /// <summary>
        /// Gets or Sets ElectricityType
        /// </summary>
        [DataMember(Name = "electricityType", EmitDefaultValue = true)]
        public ElectricityType? ElectricityType { get; set; }
        /// <summary>
        /// Gets or Sets EmissionStandard
        /// </summary>
        [DataMember(Name = "emissionStandard", EmitDefaultValue = true)]
        public EmissionStandard? EmissionStandard { get; set; }
        /// <summary>
        /// Gets or Sets ParticleReductionClass
        /// </summary>
        [DataMember(Name = "particleReductionClass", EmitDefaultValue = true)]
        public ParticleReductionClass? ParticleReductionClass { get; set; }
        /// <summary>
        /// Gets or Sets TunnelRestrictionCode
        /// </summary>
        [DataMember(Name = "tunnelRestrictionCode", EmitDefaultValue = true)]
        public TunnelRestrictionCode? TunnelRestrictionCode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Vehicle" /> class.
        /// </summary>
        /// <param name="engineType">engineType.</param>
        /// <param name="fuelType">fuelType.</param>
        /// <param name="electricityType">electricityType.</param>
        /// <param name="averageFuelConsumption">The average fuel consumption of the vehicle. Depending on the **fuelType** [l/100km] for liquid fuel types or [kg/100km] for gaseous fuel types.  Supported for **engineType** _COMBUSTION_  or _HYBRID_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="averageElectricityConsumption">The average power consumption of the vehicle [kWh/100km].  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="bioFuelRatio">The ratio of biofuel to conventional fuel [%], i.e. 10 for E10 with 10% biofuel.  Supported for **engineType** _COMBUSTION_ or _HYBRID_ and only for the fuel types _GASOLINE_, _DIESEL_, _CNG_GASOLINE_ and _LNG_GASOLINE_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="hybridRatio">Electric energy usage ratio from the total amount of energy consumed by the vehicle.  Supported for **engineType** _HYBRID_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="dualFuelRatio">Ratio of CNG or LPG usage from the total amount of fuel consumption.  Supported for **engineType** _COMBUSTION_ with **fuelType**  _CNG_GASOLINE_ or _LPG_GASOLINE_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="cylinderCapacity">The cylinder capacity of the vehicle [cm&amp;#x00B3;]. This value is present for compatibility reasons and does not influence any of the results.  Supported for **engineType** _COMBUSTION_ or _HYBRID_. .</param>
        /// <param name="emissionStandard">emissionStandard.</param>
        /// <param name="co2EmissionClass">The CO&amp;#8322; emission class valid in the European Union. See also the  [Directive 1999/62/EC](https://eur-lex.europa.eu/eli/dir/1999/62) of the European Parliament and of the  Council on the charging of heavy goods vehicles for the use of certain infrastructures, article 7ga.  Relevant for &#x60;toll&#x60;. .</param>
        /// <param name="lowEmissionZoneTypes">Comma-separated list of the low-emission zone types of the vehicle. For now, types are available only for Germany, so using more than one value is not meaningful.  Available values are provided by type &#x60;LowEmissionZoneTypes&#x60;: \&quot;DE_GREEN\&quot; \&quot;DE_YELLOW\&quot; \&quot;DE_RED\&quot; \&quot;DE_NONE\&quot;   Relevant for &#x60;routing&#x60;. .</param>
        /// <param name="particleReductionClass">particleReductionClass.</param>
        /// <param name="emptyWeight">The empty weight of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. .</param>
        /// <param name="loadWeight">The weight of the vehicle&#39;s load [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. .</param>
        /// <param name="totalPermittedWeight">The total permitted weight of the vehicle and load [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;, &#x60;emissions&#x60;. .</param>
        /// <param name="axleWeight">The maximum distributed weight that may be supported by an axle of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="numberOfAxles">The total number of axles of the vehicle including the trailers.  Relevant for &#x60;toll&#x60;. .</param>
        /// <param name="numberOfTires">The total number of tires of the vehicle including the trailers.  Relevant for &#x60;toll&#x60;. .</param>
        /// <param name="height">The height of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="heightAboveFrontAxle">The height above the front axle [cm].  Relevant for &#x60;toll&#x60;. .</param>
        /// <param name="length">The length of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="width">The width of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="hazardousMaterials">Comma-separated list of hazardous materials the vehicle has loaded. If _NONE_ is specified along with other hazardous materials it is ignored. Depending on the load the route will avoid roads prohibited for and/or prefer roads prescribed for specific hazardous materials.  Available values are provided by type &#x60;HazardousMaterials&#x60;: \&quot;HAZARDOUS_TO_WATER\&quot; \&quot;EXPLOSIVE\&quot; \&quot;FLAMMABLE\&quot; \&quot;RADIOACTIVE\&quot; \&quot;INHALATION_HAZARD\&quot; \&quot;MEDICAL_WASTE\&quot; \&quot;OTHER\&quot; \&quot;NONE\&quot;  Relevant for &#x60;routing&#x60;. .</param>
        /// <param name="tunnelRestrictionCode">tunnelRestrictionCode.</param>
        /// <param name="truckRoutes">Comma-separated list of truck routes the vehicle has to follow. This parameter will be ignored for non-truck profiles such as EUR_CAR, EUR_VAN, USA_1_PICKUP or AUS_LCV_LIGHT_COMMERCIAL.  * &#x60;DE_LKWUEBERLSTVAUSNV&#x60;  Preferred routes for long trucks in Germany, also known as Lang-LKW.  * &#x60;NL_LZV&#x60;  Preferred routes for long trucks in the Netherlands, also known as LZV (Langere en Zwaardere Vrachtautocombinatie).  * &#x60;NZ_HPMV&#x60;  The network for High Productivity Motor Vehicles (HPMV) carrying the maximum loads available under a permit (New Zeland Transport Agency).  * &#x60;SE_BK_1&#x60;  Public roads and bridges that support up to 64 t total permitted weight (Swedish Transport Administration).  * &#x60;SE_BK_2&#x60;  Public roads and bridges that support up to 51.4 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_3&#x60;  Public roads and bridges that support up to 37.5 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_4&#x60;  Public roads and bridges that support up to 74 t total permitted weight (draft summer 2018, Swedish Transport Administration).  * &#x60;US_STAA&#x60;  Routes that belong to the highway network as defined by the Surface Transportation Assistance Act in the US.  * &#x60;US_TD&#x60;  Part of a state-designated highway network for trucks in the US.  * &#x60;AU_B_DOUBLE&#x60;  B-Double routes as defined in Australia.  * &#x60;AU_B_DOUBLE_HML&#x60;  Routes for B-Double vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_B_TRIPLE&#x60;  B-Triple routes as defined in Australia.  * &#x60;AU_B_TRIPLE_HML&#x60;  Routes for B-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE&#x60;  Routes for AB-Triple vehicle combinations operating (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE_HML&#x60;  Routes for AB-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;NONE&#x60;  Overrides the profile settings to specify not to follow any truck routes.   If _NONE_ is specified along with other truck routes it is ignored.  Available values are provided by type &#x60;TruckRoutes&#x60;.  Relevant for &#x60;routing&#x60;. Cannot be used with **options[routingMode]&#x3D;MONETARY**. .</param>
        /// <param name="commercial">Specifies if the vehicle usage is commercial.  Relevant for &#x60;toll&#x60;. .</param>
        /// <param name="etcSubscriptions">A comma separated list of ETC Subscriptions. See [here](./concepts/electronic-toll-collection) for more information on available subscriptions.  Available values are provided by type &#x60;EtcSubscriptionTypes&#x60;: \&quot;AT_GOBOX\&quot; \&quot;BE_TELETOL\&quot; \&quot;BE_VIAPASS\&quot; \&quot;CH_LSVA\&quot; \&quot;DE_QUICKBOX\&quot; \&quot;DE_TOLLCOLLECT\&quot; \&quot;DE_WARNOWTUNNEL_RFID\&quot; \&quot;DK_BROPAS_BUSINESS\&quot; \&quot;IT_TELEPASS\&quot; \&quot;NL_TELECARD\&quot; \&quot;NL_TTAG\&quot; \&quot;NO_AUTOPASS\&quot; \&quot;PT_VIA_VERDE\&quot; \&quot;US_APASS\&quot; \&quot;US_BREEZEBY\&quot; \&quot;US_DOWNBEACH_EXPRESSPASS\&quot; \&quot;US_EPASS\&quot; \&quot;US_EXPRESSACCOUNT\&quot; \&quot;US_EXPRESSCARD\&quot; \&quot;US_EXPRESSPASS\&quot; \&quot;US_EXPRESSTOLL\&quot; \&quot;US_EZPASS\&quot; \&quot;US_EZTAG\&quot; \&quot;US_FASTRAK\&quot; \&quot;US_GEAUXPASS\&quot; \&quot;US_GOODTOGO\&quot; \&quot;US_GOPASS\&quot; \&quot;US_IPASS\&quot; \&quot;US_KTAG\&quot; \&quot;US_LEEWAY\&quot; \&quot;US_MACKINACBRIDGE_MACPASS\&quot; \&quot;US_MARYLAND_EZPASS\&quot; \&quot;US_MASSACHUSETTS_EZPASS\&quot; \&quot;US_NC_QUICKPASS\&quot; \&quot;US_NEWHAMPSHIRE_EZPASS\&quot; \&quot;US_NEWJERSEY_EZPASS\&quot; \&quot;US_NEWYORK_EZPASS\&quot; \&quot;US_NEXPRESS\&quot; \&quot;US_OHIO_EZPASS\&quot; \&quot;US_PALPASS\&quot; \&quot;US_PIKEPASS\&quot; \&quot;US_RIVERLINK\&quot; \&quot;US_RIVERLINK_NOTRANSPONDER\&quot; \&quot;US_SEAWAYTRANSITCARD\&quot; \&quot;US_SUNPASS\&quot; \&quot;US_TOLLTAG\&quot; \&quot;US_TXTAG\&quot; \&quot;US_VIRGINIA_EZPASS\&quot; \&quot;US_WESTVIRGINIA_EZPASS\&quot; \&quot;US_PEACHPASS\&quot; \&quot;US_NEXUS\&quot; \&quot;US_DELAWARE_EZPASS\&quot; \&quot;US_GROSSEILETOLLBRIDGE_PASSTAG\&quot; \&quot;US_EZPASS_PAYBYPLATE\&quot;  Relevant for &#x60;toll&#x60;. .</param>
        public Vehicle(EngineType? engineType = default(EngineType?), FuelType? fuelType = default(FuelType?), ElectricityType? electricityType = default(ElectricityType?), double? averageFuelConsumption = default(double?), double? averageElectricityConsumption = default(double?), int? bioFuelRatio = default(int?), int? hybridRatio = default(int?), int? dualFuelRatio = default(int?), int? cylinderCapacity = default(int?), EmissionStandard? emissionStandard = default(EmissionStandard?), int? co2EmissionClass = default(int?), string lowEmissionZoneTypes = default(string), ParticleReductionClass? particleReductionClass = default(ParticleReductionClass?), int? emptyWeight = default(int?), int? loadWeight = default(int?), int? totalPermittedWeight = default(int?), int? axleWeight = default(int?), int? numberOfAxles = default(int?), int? numberOfTires = default(int?), int? height = default(int?), int? heightAboveFrontAxle = default(int?), int? length = default(int?), int? width = default(int?), string hazardousMaterials = default(string), TunnelRestrictionCode? tunnelRestrictionCode = default(TunnelRestrictionCode?), string truckRoutes = default(string), bool? commercial = default(bool?), string etcSubscriptions = default(string))
        {
            this.EngineType = engineType;
            this.FuelType = fuelType;
            this.ElectricityType = electricityType;
            this.AverageFuelConsumption = averageFuelConsumption;
            this.AverageElectricityConsumption = averageElectricityConsumption;
            this.BioFuelRatio = bioFuelRatio;
            this.HybridRatio = hybridRatio;
            this.DualFuelRatio = dualFuelRatio;
            this.CylinderCapacity = cylinderCapacity;
            this.EmissionStandard = emissionStandard;
            this.Co2EmissionClass = co2EmissionClass;
            this.LowEmissionZoneTypes = lowEmissionZoneTypes;
            this.ParticleReductionClass = particleReductionClass;
            this.EmptyWeight = emptyWeight;
            this.LoadWeight = loadWeight;
            this.TotalPermittedWeight = totalPermittedWeight;
            this.AxleWeight = axleWeight;
            this.NumberOfAxles = numberOfAxles;
            this.NumberOfTires = numberOfTires;
            this.Height = height;
            this.HeightAboveFrontAxle = heightAboveFrontAxle;
            this.Length = length;
            this.Width = width;
            this.HazardousMaterials = hazardousMaterials;
            this.TunnelRestrictionCode = tunnelRestrictionCode;
            this.TruckRoutes = truckRoutes;
            this.Commercial = commercial;
            this.EtcSubscriptions = etcSubscriptions;
        }
        /// <summary>
        /// The average fuel consumption of the vehicle. Depending on the **fuelType** [l/100km] for liquid fuel types or [kg/100km] for gaseous fuel types.  Supported for **engineType** _COMBUSTION_  or _HYBRID_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The average fuel consumption of the vehicle. Depending on the **fuelType** [l/100km] for liquid fuel types or [kg/100km] for gaseous fuel types.  Supported for **engineType** _COMBUSTION_  or _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>35</example>
        [DataMember(Name = "averageFuelConsumption", EmitDefaultValue = true)]
        public double? AverageFuelConsumption { get; set; }
        /// <summary>
        /// The average power consumption of the vehicle [kWh/100km].  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The average power consumption of the vehicle [kWh/100km].  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>115</example>
        [DataMember(Name = "averageElectricityConsumption", EmitDefaultValue = true)]
        public double? AverageElectricityConsumption { get; set; }
        /// <summary>
        /// The ratio of biofuel to conventional fuel [%], i.e. 10 for E10 with 10% biofuel.  Supported for **engineType** _COMBUSTION_ or _HYBRID_ and only for the fuel types _GASOLINE_, _DIESEL_, _CNG_GASOLINE_ and _LNG_GASOLINE_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The ratio of biofuel to conventional fuel [%], i.e. 10 for E10 with 10% biofuel.  Supported for **engineType** _COMBUSTION_ or _HYBRID_ and only for the fuel types _GASOLINE_, _DIESEL_, _CNG_GASOLINE_ and _LNG_GASOLINE_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>0</example>
        [DataMember(Name = "bioFuelRatio", EmitDefaultValue = true)]
        public int? BioFuelRatio { get; set; }
        /// <summary>
        /// Electric energy usage ratio from the total amount of energy consumed by the vehicle.  Supported for **engineType** _HYBRID_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>Electric energy usage ratio from the total amount of energy consumed by the vehicle.  Supported for **engineType** _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>50</example>
        [DataMember(Name = "hybridRatio", EmitDefaultValue = true)]
        public int? HybridRatio { get; set; }
        /// <summary>
        /// Ratio of CNG or LPG usage from the total amount of fuel consumption.  Supported for **engineType** _COMBUSTION_ with **fuelType**  _CNG_GASOLINE_ or _LPG_GASOLINE_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>Ratio of CNG or LPG usage from the total amount of fuel consumption.  Supported for **engineType** _COMBUSTION_ with **fuelType**  _CNG_GASOLINE_ or _LPG_GASOLINE_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>50</example>
        [DataMember(Name = "dualFuelRatio", EmitDefaultValue = true)]
        public int? DualFuelRatio { get; set; }
        /// <summary>
        /// The cylinder capacity of the vehicle [cm&amp;#x00B3;]. This value is present for compatibility reasons and does not influence any of the results.  Supported for **engineType** _COMBUSTION_ or _HYBRID_. 
        /// </summary>
        /// <value>The cylinder capacity of the vehicle [cm&amp;#x00B3;]. This value is present for compatibility reasons and does not influence any of the results.  Supported for **engineType** _COMBUSTION_ or _HYBRID_. </value>
        /// <example>12000</example>
        [DataMember(Name = "cylinderCapacity", EmitDefaultValue = true)]
        public int? CylinderCapacity { get; set; }
        /// <summary>
        /// The CO&amp;#8322; emission class valid in the European Union. See also the  [Directive 1999/62/EC](https://eur-lex.europa.eu/eli/dir/1999/62) of the European Parliament and of the  Council on the charging of heavy goods vehicles for the use of certain infrastructures, article 7ga.  Relevant for &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The CO&amp;#8322; emission class valid in the European Union. See also the  [Directive 1999/62/EC](https://eur-lex.europa.eu/eli/dir/1999/62) of the European Parliament and of the  Council on the charging of heavy goods vehicles for the use of certain infrastructures, article 7ga.  Relevant for &#x60;toll&#x60;. </value>
        /// <example>1</example>
        [DataMember(Name = "co2EmissionClass", EmitDefaultValue = true)]
        public int? Co2EmissionClass { get; set; }
        /// <summary>
        /// Comma-separated list of the low-emission zone types of the vehicle. For now, types are available only for Germany, so using more than one value is not meaningful.  Available values are provided by type &#x60;LowEmissionZoneTypes&#x60;: \&quot;DE_GREEN\&quot; \&quot;DE_YELLOW\&quot; \&quot;DE_RED\&quot; \&quot;DE_NONE\&quot;   Relevant for &#x60;routing&#x60;. 
        /// </summary>
        /// <value>Comma-separated list of the low-emission zone types of the vehicle. For now, types are available only for Germany, so using more than one value is not meaningful.  Available values are provided by type &#x60;LowEmissionZoneTypes&#x60;: \&quot;DE_GREEN\&quot; \&quot;DE_YELLOW\&quot; \&quot;DE_RED\&quot; \&quot;DE_NONE\&quot;   Relevant for &#x60;routing&#x60;. </value>
        [DataMember(Name = "lowEmissionZoneTypes", EmitDefaultValue = true)]
        public string LowEmissionZoneTypes { get; set; }
        /// <summary>
        /// The empty weight of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The empty weight of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. </value>
        /// <example>15000</example>
        [DataMember(Name = "emptyWeight", EmitDefaultValue = true)]
        public int? EmptyWeight { get; set; }
        /// <summary>
        /// The weight of the vehicle&#39;s load [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The weight of the vehicle&#39;s load [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. </value>
        /// <example>25000</example>
        [DataMember(Name = "loadWeight", EmitDefaultValue = true)]
        public int? LoadWeight { get; set; }
        /// <summary>
        /// The total permitted weight of the vehicle and load [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;, &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The total permitted weight of the vehicle and load [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;, &#x60;emissions&#x60;. </value>
        /// <example>40000</example>
        [DataMember(Name = "totalPermittedWeight", EmitDefaultValue = true)]
        public int? TotalPermittedWeight { get; set; }
        /// <summary>
        /// The maximum distributed weight that may be supported by an axle of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The maximum distributed weight that may be supported by an axle of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>11500</example>
        [DataMember(Name = "axleWeight", EmitDefaultValue = true)]
        public int? AxleWeight { get; set; }
        /// <summary>
        /// The total number of axles of the vehicle including the trailers.  Relevant for &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The total number of axles of the vehicle including the trailers.  Relevant for &#x60;toll&#x60;. </value>
        /// <example>5</example>
        [DataMember(Name = "numberOfAxles", EmitDefaultValue = true)]
        public int? NumberOfAxles { get; set; }
        /// <summary>
        /// The total number of tires of the vehicle including the trailers.  Relevant for &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The total number of tires of the vehicle including the trailers.  Relevant for &#x60;toll&#x60;. </value>
        /// <example>10</example>
        [DataMember(Name = "numberOfTires", EmitDefaultValue = true)]
        public int? NumberOfTires { get; set; }
        /// <summary>
        /// The height of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The height of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>400</example>
        [DataMember(Name = "height", EmitDefaultValue = true)]
        public int? Height { get; set; }
        /// <summary>
        /// The height above the front axle [cm].  Relevant for &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The height above the front axle [cm].  Relevant for &#x60;toll&#x60;. </value>
        /// <example>400</example>
        [DataMember(Name = "heightAboveFrontAxle", EmitDefaultValue = true)]
        public int? HeightAboveFrontAxle { get; set; }
        /// <summary>
        /// The length of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The length of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>1650</example>
        [DataMember(Name = "length", EmitDefaultValue = true)]
        public int? Length { get; set; }
        /// <summary>
        /// The width of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The width of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>254</example>
        [DataMember(Name = "width", EmitDefaultValue = true)]
        public int? Width { get; set; }
        /// <summary>
        /// Comma-separated list of hazardous materials the vehicle has loaded. If _NONE_ is specified along with other hazardous materials it is ignored. Depending on the load the route will avoid roads prohibited for and/or prefer roads prescribed for specific hazardous materials.  Available values are provided by type &#x60;HazardousMaterials&#x60;: \&quot;HAZARDOUS_TO_WATER\&quot; \&quot;EXPLOSIVE\&quot; \&quot;FLAMMABLE\&quot; \&quot;RADIOACTIVE\&quot; \&quot;INHALATION_HAZARD\&quot; \&quot;MEDICAL_WASTE\&quot; \&quot;OTHER\&quot; \&quot;NONE\&quot;  Relevant for &#x60;routing&#x60;. 
        /// </summary>
        /// <value>Comma-separated list of hazardous materials the vehicle has loaded. If _NONE_ is specified along with other hazardous materials it is ignored. Depending on the load the route will avoid roads prohibited for and/or prefer roads prescribed for specific hazardous materials.  Available values are provided by type &#x60;HazardousMaterials&#x60;: \&quot;HAZARDOUS_TO_WATER\&quot; \&quot;EXPLOSIVE\&quot; \&quot;FLAMMABLE\&quot; \&quot;RADIOACTIVE\&quot; \&quot;INHALATION_HAZARD\&quot; \&quot;MEDICAL_WASTE\&quot; \&quot;OTHER\&quot; \&quot;NONE\&quot;  Relevant for &#x60;routing&#x60;. </value>
        [DataMember(Name = "hazardousMaterials", EmitDefaultValue = true)]
        public string HazardousMaterials { get; set; }
        /// <summary>
        /// Comma-separated list of truck routes the vehicle has to follow. This parameter will be ignored for non-truck profiles such as EUR_CAR, EUR_VAN, USA_1_PICKUP or AUS_LCV_LIGHT_COMMERCIAL.  * &#x60;DE_LKWUEBERLSTVAUSNV&#x60;  Preferred routes for long trucks in Germany, also known as Lang-LKW.  * &#x60;NL_LZV&#x60;  Preferred routes for long trucks in the Netherlands, also known as LZV (Langere en Zwaardere Vrachtautocombinatie).  * &#x60;NZ_HPMV&#x60;  The network for High Productivity Motor Vehicles (HPMV) carrying the maximum loads available under a permit (New Zeland Transport Agency).  * &#x60;SE_BK_1&#x60;  Public roads and bridges that support up to 64 t total permitted weight (Swedish Transport Administration).  * &#x60;SE_BK_2&#x60;  Public roads and bridges that support up to 51.4 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_3&#x60;  Public roads and bridges that support up to 37.5 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_4&#x60;  Public roads and bridges that support up to 74 t total permitted weight (draft summer 2018, Swedish Transport Administration).  * &#x60;US_STAA&#x60;  Routes that belong to the highway network as defined by the Surface Transportation Assistance Act in the US.  * &#x60;US_TD&#x60;  Part of a state-designated highway network for trucks in the US.  * &#x60;AU_B_DOUBLE&#x60;  B-Double routes as defined in Australia.  * &#x60;AU_B_DOUBLE_HML&#x60;  Routes for B-Double vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_B_TRIPLE&#x60;  B-Triple routes as defined in Australia.  * &#x60;AU_B_TRIPLE_HML&#x60;  Routes for B-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE&#x60;  Routes for AB-Triple vehicle combinations operating (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE_HML&#x60;  Routes for AB-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;NONE&#x60;  Overrides the profile settings to specify not to follow any truck routes.   If _NONE_ is specified along with other truck routes it is ignored.  Available values are provided by type &#x60;TruckRoutes&#x60;.  Relevant for &#x60;routing&#x60;. Cannot be used with **options[routingMode]&#x3D;MONETARY**. 
        /// </summary>
        /// <value>Comma-separated list of truck routes the vehicle has to follow. This parameter will be ignored for non-truck profiles such as EUR_CAR, EUR_VAN, USA_1_PICKUP or AUS_LCV_LIGHT_COMMERCIAL.  * &#x60;DE_LKWUEBERLSTVAUSNV&#x60;  Preferred routes for long trucks in Germany, also known as Lang-LKW.  * &#x60;NL_LZV&#x60;  Preferred routes for long trucks in the Netherlands, also known as LZV (Langere en Zwaardere Vrachtautocombinatie).  * &#x60;NZ_HPMV&#x60;  The network for High Productivity Motor Vehicles (HPMV) carrying the maximum loads available under a permit (New Zeland Transport Agency).  * &#x60;SE_BK_1&#x60;  Public roads and bridges that support up to 64 t total permitted weight (Swedish Transport Administration).  * &#x60;SE_BK_2&#x60;  Public roads and bridges that support up to 51.4 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_3&#x60;  Public roads and bridges that support up to 37.5 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_4&#x60;  Public roads and bridges that support up to 74 t total permitted weight (draft summer 2018, Swedish Transport Administration).  * &#x60;US_STAA&#x60;  Routes that belong to the highway network as defined by the Surface Transportation Assistance Act in the US.  * &#x60;US_TD&#x60;  Part of a state-designated highway network for trucks in the US.  * &#x60;AU_B_DOUBLE&#x60;  B-Double routes as defined in Australia.  * &#x60;AU_B_DOUBLE_HML&#x60;  Routes for B-Double vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_B_TRIPLE&#x60;  B-Triple routes as defined in Australia.  * &#x60;AU_B_TRIPLE_HML&#x60;  Routes for B-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE&#x60;  Routes for AB-Triple vehicle combinations operating (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE_HML&#x60;  Routes for AB-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;NONE&#x60;  Overrides the profile settings to specify not to follow any truck routes.   If _NONE_ is specified along with other truck routes it is ignored.  Available values are provided by type &#x60;TruckRoutes&#x60;.  Relevant for &#x60;routing&#x60;. Cannot be used with **options[routingMode]&#x3D;MONETARY**. </value>
        [DataMember(Name = "truckRoutes", EmitDefaultValue = true)]
        public string TruckRoutes { get; set; }
        /// <summary>
        /// Specifies if the vehicle usage is commercial.  Relevant for &#x60;toll&#x60;. 
        /// </summary>
        /// <value>Specifies if the vehicle usage is commercial.  Relevant for &#x60;toll&#x60;. </value>
        /// <example>false</example>
        [DataMember(Name = "commercial", EmitDefaultValue = true)]
        public bool? Commercial { get; set; }
        /// <summary>
        /// A comma separated list of ETC Subscriptions. See [here](./concepts/electronic-toll-collection) for more information on available subscriptions.  Available values are provided by type &#x60;EtcSubscriptionTypes&#x60;: \&quot;AT_GOBOX\&quot; \&quot;BE_TELETOL\&quot; \&quot;BE_VIAPASS\&quot; \&quot;CH_LSVA\&quot; \&quot;DE_QUICKBOX\&quot; \&quot;DE_TOLLCOLLECT\&quot; \&quot;DE_WARNOWTUNNEL_RFID\&quot; \&quot;DK_BROPAS_BUSINESS\&quot; \&quot;IT_TELEPASS\&quot; \&quot;NL_TELECARD\&quot; \&quot;NL_TTAG\&quot; \&quot;NO_AUTOPASS\&quot; \&quot;PT_VIA_VERDE\&quot; \&quot;US_APASS\&quot; \&quot;US_BREEZEBY\&quot; \&quot;US_DOWNBEACH_EXPRESSPASS\&quot; \&quot;US_EPASS\&quot; \&quot;US_EXPRESSACCOUNT\&quot; \&quot;US_EXPRESSCARD\&quot; \&quot;US_EXPRESSPASS\&quot; \&quot;US_EXPRESSTOLL\&quot; \&quot;US_EZPASS\&quot; \&quot;US_EZTAG\&quot; \&quot;US_FASTRAK\&quot; \&quot;US_GEAUXPASS\&quot; \&quot;US_GOODTOGO\&quot; \&quot;US_GOPASS\&quot; \&quot;US_IPASS\&quot; \&quot;US_KTAG\&quot; \&quot;US_LEEWAY\&quot; \&quot;US_MACKINACBRIDGE_MACPASS\&quot; \&quot;US_MARYLAND_EZPASS\&quot; \&quot;US_MASSACHUSETTS_EZPASS\&quot; \&quot;US_NC_QUICKPASS\&quot; \&quot;US_NEWHAMPSHIRE_EZPASS\&quot; \&quot;US_NEWJERSEY_EZPASS\&quot; \&quot;US_NEWYORK_EZPASS\&quot; \&quot;US_NEXPRESS\&quot; \&quot;US_OHIO_EZPASS\&quot; \&quot;US_PALPASS\&quot; \&quot;US_PIKEPASS\&quot; \&quot;US_RIVERLINK\&quot; \&quot;US_RIVERLINK_NOTRANSPONDER\&quot; \&quot;US_SEAWAYTRANSITCARD\&quot; \&quot;US_SUNPASS\&quot; \&quot;US_TOLLTAG\&quot; \&quot;US_TXTAG\&quot; \&quot;US_VIRGINIA_EZPASS\&quot; \&quot;US_WESTVIRGINIA_EZPASS\&quot; \&quot;US_PEACHPASS\&quot; \&quot;US_NEXUS\&quot; \&quot;US_DELAWARE_EZPASS\&quot; \&quot;US_GROSSEILETOLLBRIDGE_PASSTAG\&quot; \&quot;US_EZPASS_PAYBYPLATE\&quot;  Relevant for &#x60;toll&#x60;. 
        /// </summary>
        /// <value>A comma separated list of ETC Subscriptions. See [here](./concepts/electronic-toll-collection) for more information on available subscriptions.  Available values are provided by type &#x60;EtcSubscriptionTypes&#x60;: \&quot;AT_GOBOX\&quot; \&quot;BE_TELETOL\&quot; \&quot;BE_VIAPASS\&quot; \&quot;CH_LSVA\&quot; \&quot;DE_QUICKBOX\&quot; \&quot;DE_TOLLCOLLECT\&quot; \&quot;DE_WARNOWTUNNEL_RFID\&quot; \&quot;DK_BROPAS_BUSINESS\&quot; \&quot;IT_TELEPASS\&quot; \&quot;NL_TELECARD\&quot; \&quot;NL_TTAG\&quot; \&quot;NO_AUTOPASS\&quot; \&quot;PT_VIA_VERDE\&quot; \&quot;US_APASS\&quot; \&quot;US_BREEZEBY\&quot; \&quot;US_DOWNBEACH_EXPRESSPASS\&quot; \&quot;US_EPASS\&quot; \&quot;US_EXPRESSACCOUNT\&quot; \&quot;US_EXPRESSCARD\&quot; \&quot;US_EXPRESSPASS\&quot; \&quot;US_EXPRESSTOLL\&quot; \&quot;US_EZPASS\&quot; \&quot;US_EZTAG\&quot; \&quot;US_FASTRAK\&quot; \&quot;US_GEAUXPASS\&quot; \&quot;US_GOODTOGO\&quot; \&quot;US_GOPASS\&quot; \&quot;US_IPASS\&quot; \&quot;US_KTAG\&quot; \&quot;US_LEEWAY\&quot; \&quot;US_MACKINACBRIDGE_MACPASS\&quot; \&quot;US_MARYLAND_EZPASS\&quot; \&quot;US_MASSACHUSETTS_EZPASS\&quot; \&quot;US_NC_QUICKPASS\&quot; \&quot;US_NEWHAMPSHIRE_EZPASS\&quot; \&quot;US_NEWJERSEY_EZPASS\&quot; \&quot;US_NEWYORK_EZPASS\&quot; \&quot;US_NEXPRESS\&quot; \&quot;US_OHIO_EZPASS\&quot; \&quot;US_PALPASS\&quot; \&quot;US_PIKEPASS\&quot; \&quot;US_RIVERLINK\&quot; \&quot;US_RIVERLINK_NOTRANSPONDER\&quot; \&quot;US_SEAWAYTRANSITCARD\&quot; \&quot;US_SUNPASS\&quot; \&quot;US_TOLLTAG\&quot; \&quot;US_TXTAG\&quot; \&quot;US_VIRGINIA_EZPASS\&quot; \&quot;US_WESTVIRGINIA_EZPASS\&quot; \&quot;US_PEACHPASS\&quot; \&quot;US_NEXUS\&quot; \&quot;US_DELAWARE_EZPASS\&quot; \&quot;US_GROSSEILETOLLBRIDGE_PASSTAG\&quot; \&quot;US_EZPASS_PAYBYPLATE\&quot;  Relevant for &#x60;toll&#x60;. </value>
        [DataMember(Name = "etcSubscriptions", EmitDefaultValue = true)]
        public string EtcSubscriptions { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Vehicle {\n");
            sb.Append("  EngineType: ").Append(EngineType).Append("\n");
            sb.Append("  FuelType: ").Append(FuelType).Append("\n");
            sb.Append("  ElectricityType: ").Append(ElectricityType).Append("\n");
            sb.Append("  AverageFuelConsumption: ").Append(AverageFuelConsumption).Append("\n");
            sb.Append("  AverageElectricityConsumption: ").Append(AverageElectricityConsumption).Append("\n");
            sb.Append("  BioFuelRatio: ").Append(BioFuelRatio).Append("\n");
            sb.Append("  HybridRatio: ").Append(HybridRatio).Append("\n");
            sb.Append("  DualFuelRatio: ").Append(DualFuelRatio).Append("\n");
            sb.Append("  CylinderCapacity: ").Append(CylinderCapacity).Append("\n");
            sb.Append("  EmissionStandard: ").Append(EmissionStandard).Append("\n");
            sb.Append("  Co2EmissionClass: ").Append(Co2EmissionClass).Append("\n");
            sb.Append("  LowEmissionZoneTypes: ").Append(LowEmissionZoneTypes).Append("\n");
            sb.Append("  ParticleReductionClass: ").Append(ParticleReductionClass).Append("\n");
            sb.Append("  EmptyWeight: ").Append(EmptyWeight).Append("\n");
            sb.Append("  LoadWeight: ").Append(LoadWeight).Append("\n");
            sb.Append("  TotalPermittedWeight: ").Append(TotalPermittedWeight).Append("\n");
            sb.Append("  AxleWeight: ").Append(AxleWeight).Append("\n");
            sb.Append("  NumberOfAxles: ").Append(NumberOfAxles).Append("\n");
            sb.Append("  NumberOfTires: ").Append(NumberOfTires).Append("\n");
            sb.Append("  Height: ").Append(Height).Append("\n");
            sb.Append("  HeightAboveFrontAxle: ").Append(HeightAboveFrontAxle).Append("\n");
            sb.Append("  Length: ").Append(Length).Append("\n");
            sb.Append("  Width: ").Append(Width).Append("\n");
            sb.Append("  HazardousMaterials: ").Append(HazardousMaterials).Append("\n");
            sb.Append("  TunnelRestrictionCode: ").Append(TunnelRestrictionCode).Append("\n");
            sb.Append("  TruckRoutes: ").Append(TruckRoutes).Append("\n");
            sb.Append("  Commercial: ").Append(Commercial).Append("\n");
            sb.Append("  EtcSubscriptions: ").Append(EtcSubscriptions).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Vehicle);
        }
        /// <summary>
        /// Returns true if Vehicle instances are equal
        /// </summary>
        /// <param name="input">Instance of Vehicle to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Vehicle input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.EngineType == input.EngineType ||
                    this.EngineType.Equals(input.EngineType)
                ) && 
                (
                    this.FuelType == input.FuelType ||
                    this.FuelType.Equals(input.FuelType)
                ) && 
                (
                    this.ElectricityType == input.ElectricityType ||
                    this.ElectricityType.Equals(input.ElectricityType)
                ) && 
                (
                    this.AverageFuelConsumption == input.AverageFuelConsumption ||
                    (this.AverageFuelConsumption != null &&
                    this.AverageFuelConsumption.Equals(input.AverageFuelConsumption))
                ) && 
                (
                    this.AverageElectricityConsumption == input.AverageElectricityConsumption ||
                    (this.AverageElectricityConsumption != null &&
                    this.AverageElectricityConsumption.Equals(input.AverageElectricityConsumption))
                ) && 
                (
                    this.BioFuelRatio == input.BioFuelRatio ||
                    (this.BioFuelRatio != null &&
                    this.BioFuelRatio.Equals(input.BioFuelRatio))
                ) && 
                (
                    this.HybridRatio == input.HybridRatio ||
                    (this.HybridRatio != null &&
                    this.HybridRatio.Equals(input.HybridRatio))
                ) && 
                (
                    this.DualFuelRatio == input.DualFuelRatio ||
                    (this.DualFuelRatio != null &&
                    this.DualFuelRatio.Equals(input.DualFuelRatio))
                ) && 
                (
                    this.CylinderCapacity == input.CylinderCapacity ||
                    (this.CylinderCapacity != null &&
                    this.CylinderCapacity.Equals(input.CylinderCapacity))
                ) && 
                (
                    this.EmissionStandard == input.EmissionStandard ||
                    this.EmissionStandard.Equals(input.EmissionStandard)
                ) && 
                (
                    this.Co2EmissionClass == input.Co2EmissionClass ||
                    (this.Co2EmissionClass != null &&
                    this.Co2EmissionClass.Equals(input.Co2EmissionClass))
                ) && 
                (
                    this.LowEmissionZoneTypes == input.LowEmissionZoneTypes ||
                    (this.LowEmissionZoneTypes != null &&
                    this.LowEmissionZoneTypes.Equals(input.LowEmissionZoneTypes))
                ) && 
                (
                    this.ParticleReductionClass == input.ParticleReductionClass ||
                    this.ParticleReductionClass.Equals(input.ParticleReductionClass)
                ) && 
                (
                    this.EmptyWeight == input.EmptyWeight ||
                    (this.EmptyWeight != null &&
                    this.EmptyWeight.Equals(input.EmptyWeight))
                ) && 
                (
                    this.LoadWeight == input.LoadWeight ||
                    (this.LoadWeight != null &&
                    this.LoadWeight.Equals(input.LoadWeight))
                ) && 
                (
                    this.TotalPermittedWeight == input.TotalPermittedWeight ||
                    (this.TotalPermittedWeight != null &&
                    this.TotalPermittedWeight.Equals(input.TotalPermittedWeight))
                ) && 
                (
                    this.AxleWeight == input.AxleWeight ||
                    (this.AxleWeight != null &&
                    this.AxleWeight.Equals(input.AxleWeight))
                ) && 
                (
                    this.NumberOfAxles == input.NumberOfAxles ||
                    (this.NumberOfAxles != null &&
                    this.NumberOfAxles.Equals(input.NumberOfAxles))
                ) && 
                (
                    this.NumberOfTires == input.NumberOfTires ||
                    (this.NumberOfTires != null &&
                    this.NumberOfTires.Equals(input.NumberOfTires))
                ) && 
                (
                    this.Height == input.Height ||
                    (this.Height != null &&
                    this.Height.Equals(input.Height))
                ) && 
                (
                    this.HeightAboveFrontAxle == input.HeightAboveFrontAxle ||
                    (this.HeightAboveFrontAxle != null &&
                    this.HeightAboveFrontAxle.Equals(input.HeightAboveFrontAxle))
                ) && 
                (
                    this.Length == input.Length ||
                    (this.Length != null &&
                    this.Length.Equals(input.Length))
                ) && 
                (
                    this.Width == input.Width ||
                    (this.Width != null &&
                    this.Width.Equals(input.Width))
                ) && 
                (
                    this.HazardousMaterials == input.HazardousMaterials ||
                    (this.HazardousMaterials != null &&
                    this.HazardousMaterials.Equals(input.HazardousMaterials))
                ) && 
                (
                    this.TunnelRestrictionCode == input.TunnelRestrictionCode ||
                    this.TunnelRestrictionCode.Equals(input.TunnelRestrictionCode)
                ) && 
                (
                    this.TruckRoutes == input.TruckRoutes ||
                    (this.TruckRoutes != null &&
                    this.TruckRoutes.Equals(input.TruckRoutes))
                ) && 
                (
                    this.Commercial == input.Commercial ||
                    (this.Commercial != null &&
                    this.Commercial.Equals(input.Commercial))
                ) && 
                (
                    this.EtcSubscriptions == input.EtcSubscriptions ||
                    (this.EtcSubscriptions != null &&
                    this.EtcSubscriptions.Equals(input.EtcSubscriptions))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.EngineType.GetHashCode();
                hashCode = (hashCode * 59) + this.FuelType.GetHashCode();
                hashCode = (hashCode * 59) + this.ElectricityType.GetHashCode();
                if (this.AverageFuelConsumption != null)
                {
                    hashCode = (hashCode * 59) + this.AverageFuelConsumption.GetHashCode();
                }
                if (this.AverageElectricityConsumption != null)
                {
                    hashCode = (hashCode * 59) + this.AverageElectricityConsumption.GetHashCode();
                }
                if (this.BioFuelRatio != null)
                {
                    hashCode = (hashCode * 59) + this.BioFuelRatio.GetHashCode();
                }
                if (this.HybridRatio != null)
                {
                    hashCode = (hashCode * 59) + this.HybridRatio.GetHashCode();
                }
                if (this.DualFuelRatio != null)
                {
                    hashCode = (hashCode * 59) + this.DualFuelRatio.GetHashCode();
                }
                if (this.CylinderCapacity != null)
                {
                    hashCode = (hashCode * 59) + this.CylinderCapacity.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.EmissionStandard.GetHashCode();
                if (this.Co2EmissionClass != null)
                {
                    hashCode = (hashCode * 59) + this.Co2EmissionClass.GetHashCode();
                }
                if (this.LowEmissionZoneTypes != null)
                {
                    hashCode = (hashCode * 59) + this.LowEmissionZoneTypes.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.ParticleReductionClass.GetHashCode();
                if (this.EmptyWeight != null)
                {
                    hashCode = (hashCode * 59) + this.EmptyWeight.GetHashCode();
                }
                if (this.LoadWeight != null)
                {
                    hashCode = (hashCode * 59) + this.LoadWeight.GetHashCode();
                }
                if (this.TotalPermittedWeight != null)
                {
                    hashCode = (hashCode * 59) + this.TotalPermittedWeight.GetHashCode();
                }
                if (this.AxleWeight != null)
                {
                    hashCode = (hashCode * 59) + this.AxleWeight.GetHashCode();
                }
                if (this.NumberOfAxles != null)
                {
                    hashCode = (hashCode * 59) + this.NumberOfAxles.GetHashCode();
                }
                if (this.NumberOfTires != null)
                {
                    hashCode = (hashCode * 59) + this.NumberOfTires.GetHashCode();
                }
                if (this.Height != null)
                {
                    hashCode = (hashCode * 59) + this.Height.GetHashCode();
                }
                if (this.HeightAboveFrontAxle != null)
                {
                    hashCode = (hashCode * 59) + this.HeightAboveFrontAxle.GetHashCode();
                }
                if (this.Length != null)
                {
                    hashCode = (hashCode * 59) + this.Length.GetHashCode();
                }
                if (this.Width != null)
                {
                    hashCode = (hashCode * 59) + this.Width.GetHashCode();
                }
                if (this.HazardousMaterials != null)
                {
                    hashCode = (hashCode * 59) + this.HazardousMaterials.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TunnelRestrictionCode.GetHashCode();
                if (this.TruckRoutes != null)
                {
                    hashCode = (hashCode * 59) + this.TruckRoutes.GetHashCode();
                }
                if (this.Commercial != null)
                {
                    hashCode = (hashCode * 59) + this.Commercial.GetHashCode();
                }
                if (this.EtcSubscriptions != null)
                {
                    hashCode = (hashCode * 59) + this.EtcSubscriptions.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // AverageFuelConsumption (double?) minimum
            if (this.AverageFuelConsumption < (double?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AverageFuelConsumption, must be a value greater than or equal to 0.", new [] { "AverageFuelConsumption" });
            }
            // AverageElectricityConsumption (double?) minimum
            if (this.AverageElectricityConsumption < (double?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AverageElectricityConsumption, must be a value greater than or equal to 0.", new [] { "AverageElectricityConsumption" });
            }
            // BioFuelRatio (int?) maximum
            if (this.BioFuelRatio > (int?)100)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for BioFuelRatio, must be a value less than or equal to 100.", new [] { "BioFuelRatio" });
            }
            // BioFuelRatio (int?) minimum
            if (this.BioFuelRatio < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for BioFuelRatio, must be a value greater than or equal to 0.", new [] { "BioFuelRatio" });
            }
            // HybridRatio (int?) maximum
            if (this.HybridRatio > (int?)99)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for HybridRatio, must be a value less than or equal to 99.", new [] { "HybridRatio" });
            }
            // HybridRatio (int?) minimum
            if (this.HybridRatio < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for HybridRatio, must be a value greater than or equal to 1.", new [] { "HybridRatio" });
            }
            // DualFuelRatio (int?) maximum
            if (this.DualFuelRatio > (int?)99)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DualFuelRatio, must be a value less than or equal to 99.", new [] { "DualFuelRatio" });
            }
            // DualFuelRatio (int?) minimum
            if (this.DualFuelRatio < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DualFuelRatio, must be a value greater than or equal to 1.", new [] { "DualFuelRatio" });
            }
            // CylinderCapacity (int?) minimum
            if (this.CylinderCapacity < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CylinderCapacity, must be a value greater than or equal to 1.", new [] { "CylinderCapacity" });
            }
            // Co2EmissionClass (int?) maximum
            if (this.Co2EmissionClass > (int?)5)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2EmissionClass, must be a value less than or equal to 5.", new [] { "Co2EmissionClass" });
            }
            // Co2EmissionClass (int?) minimum
            if (this.Co2EmissionClass < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Co2EmissionClass, must be a value greater than or equal to 1.", new [] { "Co2EmissionClass" });
            }
            // EmptyWeight (int?) minimum
            if (this.EmptyWeight < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EmptyWeight, must be a value greater than or equal to 1.", new [] { "EmptyWeight" });
            }
            // LoadWeight (int?) minimum
            if (this.LoadWeight < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for LoadWeight, must be a value greater than or equal to 0.", new [] { "LoadWeight" });
            }
            // TotalPermittedWeight (int?) minimum
            if (this.TotalPermittedWeight < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TotalPermittedWeight, must be a value greater than or equal to 1.", new [] { "TotalPermittedWeight" });
            }
            // AxleWeight (int?) minimum
            if (this.AxleWeight < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AxleWeight, must be a value greater than or equal to 1.", new [] { "AxleWeight" });
            }
            // NumberOfAxles (int?) minimum
            if (this.NumberOfAxles < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NumberOfAxles, must be a value greater than or equal to 1.", new [] { "NumberOfAxles" });
            }
            // NumberOfTires (int?) minimum
            if (this.NumberOfTires < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NumberOfTires, must be a value greater than or equal to 1.", new [] { "NumberOfTires" });
            }
            // Height (int?) minimum
            if (this.Height < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Height, must be a value greater than or equal to 1.", new [] { "Height" });
            }
            // HeightAboveFrontAxle (int?) minimum
            if (this.HeightAboveFrontAxle < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for HeightAboveFrontAxle, must be a value greater than or equal to 1.", new [] { "HeightAboveFrontAxle" });
            }
            // Length (int?) minimum
            if (this.Length < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Length, must be a value greater than or equal to 1.", new [] { "Length" });
            }
            // Width (int?) minimum
            if (this.Width < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Width, must be a value greater than or equal to 1.", new [] { "Width" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The vehicle parameters that change at a waypoint. A vehicle parameter specified at a waypoint overrides the setting from the **profile** and **vehicle**. It is valid until the end of the route unless it is changed again at a subsequent waypoint. 
    /// </summary>
    [DataContract(Name = "VehicleParametersAtWaypoint")]
    public partial class VehicleParametersAtWaypoint : IEquatable<VehicleParametersAtWaypoint>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets TunnelRestrictionCode
        /// </summary>
        [DataMember(Name = "tunnelRestrictionCode", EmitDefaultValue = true)]
        public TunnelRestrictionCode? TunnelRestrictionCode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="VehicleParametersAtWaypoint" /> class.
        /// </summary>
        /// <param name="averageFuelConsumption">The average fuel consumption of the vehicle. Depending on the **fuelType** [l/100km] for liquid fuel types or [kg/100km] for gaseous fuel types.  Supported for **engineType** _COMBUSTION_  or _HYBRID_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="averageElectricityConsumption">The average electricity consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh/100km].  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. .</param>
        /// <param name="loadWeight">The weight of the vehicle&#39;s load [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. .</param>
        /// <param name="axleWeight">The maximum distributed weight that may be supported by an axle of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="height">The height of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="length">The length of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="width">The width of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. .</param>
        /// <param name="hazardousMaterials">The list of hazardous materials the vehicle has loaded. Use a list with only the _NONE_ value to specify that no hazardous material is loaded from that waypoint on. An empty list means that the hazardous materials don&#39;t change at the waypoint. If _NONE_ is specified along with other hazardous materials it is ignored.  Relevant for &#x60;routing&#x60;. .</param>
        /// <param name="tunnelRestrictionCode">tunnelRestrictionCode.</param>
        /// <param name="truckRoutes">The list of truck routes the vehicle has to follow. This parameter will be ignored for non-truck profiles such as EUR_CAR, EUR_VAN, USA_1_PICKUP or AUS_LCV_LIGHT_COMMERCIAL.  * &#x60;DE_LKWUEBERLSTVAUSNV&#x60;  Preferred routes for long trucks in Germany, also known as Lang-LKW.  * &#x60;NL_LZV&#x60;  Preferred routes for long trucks in the Netherlands, also known as LZV (Langere en Zwaardere Vrachtautocombinatie).  * &#x60;NZ_HPMV&#x60;  The network for High Productivity Motor Vehicles (HPMV) carrying the maximum loads available under a permit (New Zeland Transport Agency).  * &#x60;SE_BK_1&#x60;  Public roads and bridges that support up to 64 t total permitted weight (Swedish Transport Administration).  * &#x60;SE_BK_2&#x60;  Public roads and bridges that support up to 51.4 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_3&#x60;  Public roads and bridges that support up to 37.5 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_4&#x60;  Public roads and bridges that support up to 74 t total permitted weight (draft summer 2018, Swedish Transport Administration).  * &#x60;US_STAA&#x60;  Routes that belong to the highway network as defined by the Surface Transportation Assistance Act in the US.  * &#x60;US_TD&#x60;  Part of a state-designated highway network for trucks in the US.  * &#x60;AU_B_DOUBLE&#x60;  B-Double routes as defined in Australia.  * &#x60;AU_B_DOUBLE_HML&#x60;  Routes for B-Double vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_B_TRIPLE&#x60;  B-Triple routes as defined in Australia.  * &#x60;AU_B_TRIPLE_HML&#x60;  Routes for B-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE&#x60;  Routes for AB-Triple vehicle combinations operating (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE_HML&#x60;  Routes for AB-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;NONE&#x60;  Use a list with only the _NONE_ value for the truck routes  at a waypoint to specify that no truck route must be used from that waypoint on. An empty list of truck routes  at a waypoint means that the truck routes don&#39;t change at the waypoint. If _NONE_ is specified along with other  truck routes it is ignored.  Relevant for &#x60;routing&#x60;. Cannot be used with **options[routingMode]&#x3D;MONETARY**. .</param>
        public VehicleParametersAtWaypoint(double averageFuelConsumption = default(double), double averageElectricityConsumption = default(double), int loadWeight = default(int), int axleWeight = default(int), int height = default(int), int length = default(int), int width = default(int), List<HazardousMaterials> hazardousMaterials = default(List<HazardousMaterials>), TunnelRestrictionCode? tunnelRestrictionCode = default(TunnelRestrictionCode?), List<TruckRoutes> truckRoutes = default(List<TruckRoutes>))
        {
            this.AverageFuelConsumption = averageFuelConsumption;
            this.AverageElectricityConsumption = averageElectricityConsumption;
            this.LoadWeight = loadWeight;
            this.AxleWeight = axleWeight;
            this.Height = height;
            this.Length = length;
            this.Width = width;
            this.HazardousMaterials = hazardousMaterials;
            this.TunnelRestrictionCode = tunnelRestrictionCode;
            this.TruckRoutes = truckRoutes;
        }
        /// <summary>
        /// The average fuel consumption of the vehicle. Depending on the **fuelType** [l/100km] for liquid fuel types or [kg/100km] for gaseous fuel types.  Supported for **engineType** _COMBUSTION_  or _HYBRID_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The average fuel consumption of the vehicle. Depending on the **fuelType** [l/100km] for liquid fuel types or [kg/100km] for gaseous fuel types.  Supported for **engineType** _COMBUSTION_  or _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>35</example>
        [DataMember(Name = "averageFuelConsumption", EmitDefaultValue = false)]
        public double AverageFuelConsumption { get; set; }
        /// <summary>
        /// The average electricity consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh/100km].  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The average electricity consumption of the vehicle if the **engineType** is _ELECTRIC_ or _HYBRID_ [kWh/100km].  Supported for **engineType** _ELECTRIC_ or _HYBRID_. Relevant for &#x60;emissions&#x60;. </value>
        /// <example>115</example>
        [DataMember(Name = "averageElectricityConsumption", EmitDefaultValue = false)]
        public double AverageElectricityConsumption { get; set; }
        /// <summary>
        /// The weight of the vehicle&#39;s load [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. 
        /// </summary>
        /// <value>The weight of the vehicle&#39;s load [kg].  Relevant for &#x60;routing&#x60;, &#x60;emissions&#x60;. </value>
        /// <example>25000</example>
        [DataMember(Name = "loadWeight", EmitDefaultValue = false)]
        public int LoadWeight { get; set; }
        /// <summary>
        /// The maximum distributed weight that may be supported by an axle of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The maximum distributed weight that may be supported by an axle of the vehicle [kg].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>11500</example>
        [DataMember(Name = "axleWeight", EmitDefaultValue = false)]
        public int AxleWeight { get; set; }
        /// <summary>
        /// The height of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The height of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>400</example>
        [DataMember(Name = "height", EmitDefaultValue = false)]
        public int Height { get; set; }
        /// <summary>
        /// The length of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The length of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>1650</example>
        [DataMember(Name = "length", EmitDefaultValue = false)]
        public int Length { get; set; }
        /// <summary>
        /// The width of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. 
        /// </summary>
        /// <value>The width of the vehicle [cm].  Relevant for &#x60;routing&#x60;, &#x60;toll&#x60;. </value>
        /// <example>254</example>
        [DataMember(Name = "width", EmitDefaultValue = false)]
        public int Width { get; set; }
        /// <summary>
        /// The list of hazardous materials the vehicle has loaded. Use a list with only the _NONE_ value to specify that no hazardous material is loaded from that waypoint on. An empty list means that the hazardous materials don&#39;t change at the waypoint. If _NONE_ is specified along with other hazardous materials it is ignored.  Relevant for &#x60;routing&#x60;. 
        /// </summary>
        /// <value>The list of hazardous materials the vehicle has loaded. Use a list with only the _NONE_ value to specify that no hazardous material is loaded from that waypoint on. An empty list means that the hazardous materials don&#39;t change at the waypoint. If _NONE_ is specified along with other hazardous materials it is ignored.  Relevant for &#x60;routing&#x60;. </value>
        [DataMember(Name = "hazardousMaterials", EmitDefaultValue = false)]
        public List<HazardousMaterials> HazardousMaterials { get; set; }
        /// <summary>
        /// The list of truck routes the vehicle has to follow. This parameter will be ignored for non-truck profiles such as EUR_CAR, EUR_VAN, USA_1_PICKUP or AUS_LCV_LIGHT_COMMERCIAL.  * &#x60;DE_LKWUEBERLSTVAUSNV&#x60;  Preferred routes for long trucks in Germany, also known as Lang-LKW.  * &#x60;NL_LZV&#x60;  Preferred routes for long trucks in the Netherlands, also known as LZV (Langere en Zwaardere Vrachtautocombinatie).  * &#x60;NZ_HPMV&#x60;  The network for High Productivity Motor Vehicles (HPMV) carrying the maximum loads available under a permit (New Zeland Transport Agency).  * &#x60;SE_BK_1&#x60;  Public roads and bridges that support up to 64 t total permitted weight (Swedish Transport Administration).  * &#x60;SE_BK_2&#x60;  Public roads and bridges that support up to 51.4 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_3&#x60;  Public roads and bridges that support up to 37.5 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_4&#x60;  Public roads and bridges that support up to 74 t total permitted weight (draft summer 2018, Swedish Transport Administration).  * &#x60;US_STAA&#x60;  Routes that belong to the highway network as defined by the Surface Transportation Assistance Act in the US.  * &#x60;US_TD&#x60;  Part of a state-designated highway network for trucks in the US.  * &#x60;AU_B_DOUBLE&#x60;  B-Double routes as defined in Australia.  * &#x60;AU_B_DOUBLE_HML&#x60;  Routes for B-Double vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_B_TRIPLE&#x60;  B-Triple routes as defined in Australia.  * &#x60;AU_B_TRIPLE_HML&#x60;  Routes for B-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE&#x60;  Routes for AB-Triple vehicle combinations operating (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE_HML&#x60;  Routes for AB-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;NONE&#x60;  Use a list with only the _NONE_ value for the truck routes  at a waypoint to specify that no truck route must be used from that waypoint on. An empty list of truck routes  at a waypoint means that the truck routes don&#39;t change at the waypoint. If _NONE_ is specified along with other  truck routes it is ignored.  Relevant for &#x60;routing&#x60;. Cannot be used with **options[routingMode]&#x3D;MONETARY**. 
        /// </summary>
        /// <value>The list of truck routes the vehicle has to follow. This parameter will be ignored for non-truck profiles such as EUR_CAR, EUR_VAN, USA_1_PICKUP or AUS_LCV_LIGHT_COMMERCIAL.  * &#x60;DE_LKWUEBERLSTVAUSNV&#x60;  Preferred routes for long trucks in Germany, also known as Lang-LKW.  * &#x60;NL_LZV&#x60;  Preferred routes for long trucks in the Netherlands, also known as LZV (Langere en Zwaardere Vrachtautocombinatie).  * &#x60;NZ_HPMV&#x60;  The network for High Productivity Motor Vehicles (HPMV) carrying the maximum loads available under a permit (New Zeland Transport Agency).  * &#x60;SE_BK_1&#x60;  Public roads and bridges that support up to 64 t total permitted weight (Swedish Transport Administration).  * &#x60;SE_BK_2&#x60;  Public roads and bridges that support up to 51.4 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_3&#x60;  Public roads and bridges that support up to 37.5 t total permitted weight.  Actual limit depends on wheelbase and axle weight (Swedish Transport Administration).  * &#x60;SE_BK_4&#x60;  Public roads and bridges that support up to 74 t total permitted weight (draft summer 2018, Swedish Transport Administration).  * &#x60;US_STAA&#x60;  Routes that belong to the highway network as defined by the Surface Transportation Assistance Act in the US.  * &#x60;US_TD&#x60;  Part of a state-designated highway network for trucks in the US.  * &#x60;AU_B_DOUBLE&#x60;  B-Double routes as defined in Australia.  * &#x60;AU_B_DOUBLE_HML&#x60;  Routes for B-Double vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_B_TRIPLE&#x60;  B-Triple routes as defined in Australia.  * &#x60;AU_B_TRIPLE_HML&#x60;  Routes for B-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE&#x60;  Routes for AB-Triple vehicle combinations operating (Australian Transport Administration).  * &#x60;AU_AB_TRIPLE_HML&#x60;  Routes for AB-Triple vehicle combinations operating at Higher Mass Limits (HML) (Australian Transport Administration).  * &#x60;NONE&#x60;  Use a list with only the _NONE_ value for the truck routes  at a waypoint to specify that no truck route must be used from that waypoint on. An empty list of truck routes  at a waypoint means that the truck routes don&#39;t change at the waypoint. If _NONE_ is specified along with other  truck routes it is ignored.  Relevant for &#x60;routing&#x60;. Cannot be used with **options[routingMode]&#x3D;MONETARY**. </value>
        [DataMember(Name = "truckRoutes", EmitDefaultValue = false)]
        public List<TruckRoutes> TruckRoutes { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class VehicleParametersAtWaypoint {\n");
            sb.Append("  AverageFuelConsumption: ").Append(AverageFuelConsumption).Append("\n");
            sb.Append("  AverageElectricityConsumption: ").Append(AverageElectricityConsumption).Append("\n");
            sb.Append("  LoadWeight: ").Append(LoadWeight).Append("\n");
            sb.Append("  AxleWeight: ").Append(AxleWeight).Append("\n");
            sb.Append("  Height: ").Append(Height).Append("\n");
            sb.Append("  Length: ").Append(Length).Append("\n");
            sb.Append("  Width: ").Append(Width).Append("\n");
            sb.Append("  HazardousMaterials: ").Append(HazardousMaterials).Append("\n");
            sb.Append("  TunnelRestrictionCode: ").Append(TunnelRestrictionCode).Append("\n");
            sb.Append("  TruckRoutes: ").Append(TruckRoutes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as VehicleParametersAtWaypoint);
        }
        /// <summary>
        /// Returns true if VehicleParametersAtWaypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of VehicleParametersAtWaypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(VehicleParametersAtWaypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.AverageFuelConsumption == input.AverageFuelConsumption ||
                    this.AverageFuelConsumption.Equals(input.AverageFuelConsumption)
                ) && 
                (
                    this.AverageElectricityConsumption == input.AverageElectricityConsumption ||
                    this.AverageElectricityConsumption.Equals(input.AverageElectricityConsumption)
                ) && 
                (
                    this.LoadWeight == input.LoadWeight ||
                    this.LoadWeight.Equals(input.LoadWeight)
                ) && 
                (
                    this.AxleWeight == input.AxleWeight ||
                    this.AxleWeight.Equals(input.AxleWeight)
                ) && 
                (
                    this.Height == input.Height ||
                    this.Height.Equals(input.Height)
                ) && 
                (
                    this.Length == input.Length ||
                    this.Length.Equals(input.Length)
                ) && 
                (
                    this.Width == input.Width ||
                    this.Width.Equals(input.Width)
                ) && 
                (
                    this.HazardousMaterials == input.HazardousMaterials ||
                    this.HazardousMaterials != null &&
                    input.HazardousMaterials != null &&
                    this.HazardousMaterials.SequenceEqual(input.HazardousMaterials)
                ) && 
                (
                    this.TunnelRestrictionCode == input.TunnelRestrictionCode ||
                    this.TunnelRestrictionCode.Equals(input.TunnelRestrictionCode)
                ) && 
                (
                    this.TruckRoutes == input.TruckRoutes ||
                    this.TruckRoutes != null &&
                    input.TruckRoutes != null &&
                    this.TruckRoutes.SequenceEqual(input.TruckRoutes)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.AverageFuelConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.AverageElectricityConsumption.GetHashCode();
                hashCode = (hashCode * 59) + this.LoadWeight.GetHashCode();
                hashCode = (hashCode * 59) + this.AxleWeight.GetHashCode();
                hashCode = (hashCode * 59) + this.Height.GetHashCode();
                hashCode = (hashCode * 59) + this.Length.GetHashCode();
                hashCode = (hashCode * 59) + this.Width.GetHashCode();
                if (this.HazardousMaterials != null)
                {
                    hashCode = (hashCode * 59) + this.HazardousMaterials.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TunnelRestrictionCode.GetHashCode();
                if (this.TruckRoutes != null)
                {
                    hashCode = (hashCode * 59) + this.TruckRoutes.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // AverageFuelConsumption (double) minimum
            if (this.AverageFuelConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AverageFuelConsumption, must be a value greater than or equal to 0.", new [] { "AverageFuelConsumption" });
            }
            // AverageElectricityConsumption (double) minimum
            if (this.AverageElectricityConsumption < (double)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AverageElectricityConsumption, must be a value greater than or equal to 0.", new [] { "AverageElectricityConsumption" });
            }
            // LoadWeight (int) minimum
            if (this.LoadWeight < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for LoadWeight, must be a value greater than or equal to 0.", new [] { "LoadWeight" });
            }
            // AxleWeight (int) minimum
            if (this.AxleWeight < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AxleWeight, must be a value greater than or equal to 1.", new [] { "AxleWeight" });
            }
            // Height (int) minimum
            if (this.Height < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Height, must be a value greater than or equal to 1.", new [] { "Height" });
            }
            // Length (int) minimum
            if (this.Length < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Length, must be a value greater than or equal to 1.", new [] { "Length" });
            }
            // Width (int) minimum
            if (this.Width < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Width, must be a value greater than or equal to 1.", new [] { "Width" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when the route passes a road which is prohibited for the given vehicle but passed nevertheless as there is no other valid route or when schedule restrictions are violated. Requires _VIOLATION_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "ViolationEvent")]
    public partial class ViolationEvent : IEquatable<ViolationEvent>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name = "type", IsRequired = true, EmitDefaultValue = true)]
        public ViolationType Type { get; set; }
        /// <summary>
        /// Gets or Sets AccessType
        /// </summary>
        [DataMember(Name = "accessType", EmitDefaultValue = false)]
        public AccessType? AccessType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ViolationEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ViolationEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ViolationEvent" /> class.
        /// </summary>
        /// <param name="type">type (required).</param>
        /// <param name="scheduleViolationTypes">Contains the list of violated schedule restrictions at this event. Only present if **type&#x3D;SCHEDULE**. .</param>
        /// <param name="accessType">accessType.</param>
        /// <param name="relatedEventIndex">For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise..</param>
        /// <param name="polyline">The polyline of the violation in the format specified by **options[polylineFormat]**. Only present for **accessType** _ENTER_. Requires _VIOLATION_EVENTS_POLYLINE_ to be requested..</param>
        public ViolationEvent(ViolationType type = default(ViolationType), List<ScheduleViolationType> scheduleViolationTypes = default(List<ScheduleViolationType>), AccessType? accessType = default(AccessType?), int relatedEventIndex = default(int), string polyline = default(string))
        {
            this.Type = type;
            this.ScheduleViolationTypes = scheduleViolationTypes;
            this.AccessType = accessType;
            this.RelatedEventIndex = relatedEventIndex;
            this.Polyline = polyline;
        }
        /// <summary>
        /// Contains the list of violated schedule restrictions at this event. Only present if **type&#x3D;SCHEDULE**. 
        /// </summary>
        /// <value>Contains the list of violated schedule restrictions at this event. Only present if **type&#x3D;SCHEDULE**. </value>
        [DataMember(Name = "scheduleViolationTypes", EmitDefaultValue = false)]
        public List<ScheduleViolationType> ScheduleViolationTypes { get; set; }
        /// <summary>
        /// For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.
        /// </summary>
        /// <value>For **accessType** _ENTER_ this index points to the corresponding event with **accessType** _EXIT_ and vice-versa. Not present otherwise.</value>
        [DataMember(Name = "relatedEventIndex", EmitDefaultValue = false)]
        public int RelatedEventIndex { get; set; }
        /// <summary>
        /// The polyline of the violation in the format specified by **options[polylineFormat]**. Only present for **accessType** _ENTER_. Requires _VIOLATION_EVENTS_POLYLINE_ to be requested.
        /// </summary>
        /// <value>The polyline of the violation in the format specified by **options[polylineFormat]**. Only present for **accessType** _ENTER_. Requires _VIOLATION_EVENTS_POLYLINE_ to be requested.</value>
        [DataMember(Name = "polyline", EmitDefaultValue = false)]
        public string Polyline { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ViolationEvent {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  ScheduleViolationTypes: ").Append(ScheduleViolationTypes).Append("\n");
            sb.Append("  AccessType: ").Append(AccessType).Append("\n");
            sb.Append("  RelatedEventIndex: ").Append(RelatedEventIndex).Append("\n");
            sb.Append("  Polyline: ").Append(Polyline).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ViolationEvent);
        }
        /// <summary>
        /// Returns true if ViolationEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of ViolationEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ViolationEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Type == input.Type ||
                    this.Type.Equals(input.Type)
                ) && 
                (
                    this.ScheduleViolationTypes == input.ScheduleViolationTypes ||
                    this.ScheduleViolationTypes != null &&
                    input.ScheduleViolationTypes != null &&
                    this.ScheduleViolationTypes.SequenceEqual(input.ScheduleViolationTypes)
                ) && 
                (
                    this.AccessType == input.AccessType ||
                    this.AccessType.Equals(input.AccessType)
                ) && 
                (
                    this.RelatedEventIndex == input.RelatedEventIndex ||
                    this.RelatedEventIndex.Equals(input.RelatedEventIndex)
                ) && 
                (
                    this.Polyline == input.Polyline ||
                    (this.Polyline != null &&
                    this.Polyline.Equals(input.Polyline))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Type.GetHashCode();
                if (this.ScheduleViolationTypes != null)
                {
                    hashCode = (hashCode * 59) + this.ScheduleViolationTypes.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AccessType.GetHashCode();
                hashCode = (hashCode * 59) + this.RelatedEventIndex.GetHashCode();
                if (this.Polyline != null)
                {
                    hashCode = (hashCode * 59) + this.Polyline.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // RelatedEventIndex (int) minimum
            if (this.RelatedEventIndex < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RelatedEventIndex, must be a value greater than or equal to 0.", new [] { "RelatedEventIndex" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// The reason why the road or the schedule is violated.  * &#x60;PROHIBITED&#x60; - The violated road is prohibited in general for the current vehicle.    * &#x60;DELIVERY_ONLY&#x60; - The violated road is prohibited except for delivery reasons but delivery is disallowed for the cars and vans.    * &#x60;URBAN&#x60; - The violated road is prohibited because it is flagged as urban.    * &#x60;RESIDENTS_ONLY&#x60; - The violated road is prohibited because it is flagged as residents only for the current vehicle.    * &#x60;RESTRICTED_ACCESS&#x60; - A point with restricted access, e.g. a gate or a bollard was passed.    * &#x60;VEHICLE_PROPERTY&#x60; - The violated road is prohibited for the current vehicle due to a vehicle property such as the weight or height.    * &#x60;COMBINED_TRANSPORT&#x60; - The violated road is a boat(ferry) or rail (train or rail shuttle) connection prohibited for the current vehicle.  * &#x60;SCHEDULE&#x60; - The schedule is violated. The reasons can be found in **scheduleViolationTypes**.  * &#x60;BLOCKED_ROAD_BY_INTERSECTION&#x60; - The violated road has been blocked through **options[blockIntersectingRoads]**.
    /// </summary>
    /// <value>The reason why the road or the schedule is violated.  * &#x60;PROHIBITED&#x60; - The violated road is prohibited in general for the current vehicle.    * &#x60;DELIVERY_ONLY&#x60; - The violated road is prohibited except for delivery reasons but delivery is disallowed for the cars and vans.    * &#x60;URBAN&#x60; - The violated road is prohibited because it is flagged as urban.    * &#x60;RESIDENTS_ONLY&#x60; - The violated road is prohibited because it is flagged as residents only for the current vehicle.    * &#x60;RESTRICTED_ACCESS&#x60; - A point with restricted access, e.g. a gate or a bollard was passed.    * &#x60;VEHICLE_PROPERTY&#x60; - The violated road is prohibited for the current vehicle due to a vehicle property such as the weight or height.    * &#x60;COMBINED_TRANSPORT&#x60; - The violated road is a boat(ferry) or rail (train or rail shuttle) connection prohibited for the current vehicle.  * &#x60;SCHEDULE&#x60; - The schedule is violated. The reasons can be found in **scheduleViolationTypes**.  * &#x60;BLOCKED_ROAD_BY_INTERSECTION&#x60; - The violated road has been blocked through **options[blockIntersectingRoads]**.</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum ViolationType
    {
        /// <summary>
        /// Enum PROHIBITED for value: PROHIBITED
        /// </summary>
        [EnumMember(Value = "PROHIBITED")]
        PROHIBITED = 1,
        /// <summary>
        /// Enum DELIVERY_ONLY for value: DELIVERY_ONLY
        /// </summary>
        [EnumMember(Value = "DELIVERY_ONLY")]
        DELIVERY_ONLY = 2,
        /// <summary>
        /// Enum URBAN for value: URBAN
        /// </summary>
        [EnumMember(Value = "URBAN")]
        URBAN = 3,
        /// <summary>
        /// Enum RESIDENTS_ONLY for value: RESIDENTS_ONLY
        /// </summary>
        [EnumMember(Value = "RESIDENTS_ONLY")]
        RESIDENTS_ONLY = 4,
        /// <summary>
        /// Enum RESTRICTED_ACCESS for value: RESTRICTED_ACCESS
        /// </summary>
        [EnumMember(Value = "RESTRICTED_ACCESS")]
        RESTRICTED_ACCESS = 5,
        /// <summary>
        /// Enum VEHICLE_PROPERTY for value: VEHICLE_PROPERTY
        /// </summary>
        [EnumMember(Value = "VEHICLE_PROPERTY")]
        VEHICLE_PROPERTY = 6,
        /// <summary>
        /// Enum COMBINED_TRANSPORT for value: COMBINED_TRANSPORT
        /// </summary>
        [EnumMember(Value = "COMBINED_TRANSPORT")]
        COMBINED_TRANSPORT = 7,
        /// <summary>
        /// Enum SCHEDULE for value: SCHEDULE
        /// </summary>
        [EnumMember(Value = "SCHEDULE")]
        SCHEDULE = 8,
        /// <summary>
        /// Enum BLOCKED_ROAD_BY_INTERSECTION for value: BLOCKED_ROAD_BY_INTERSECTION
        /// </summary>
        [EnumMember(Value = "BLOCKED_ROAD_BY_INTERSECTION")]
        BLOCKED_ROAD_BY_INTERSECTION = 9
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Warning
    /// </summary>
    [DataContract(Name = "Warning")]
    public partial class Warning : IEquatable<Warning>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Warning" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Warning() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Warning" /> class.
        /// </summary>
        /// <param name="description">A human readable message that describes the warning. (required).</param>
        /// <param name="warningCode">A constant string that can be used to identify this warning class programmatically. A warningCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional warningCodes as well as the **details** of existing warningCodes may be added at any time. Furthermore, the **description** may change at any time.    * &#x60;GENERAL_PARAMETER_IGNORED&#x60; - A parameter was ignored.   * &#x60;parameter&#x60; - The ignored parameter.   * &#x60;value&#x60; - The value of the ignored parameter.   * &#x60;relatedParameter&#x60; - The parameter which caused the parameter in question to be ignored.   * &#x60;relatedValue&#x60; - The value which caused the parameter in question to be ignored. Not present if the conflict is independent of the value. * &#x60;ROUTING_PARAMETER_INCONSISTENCY&#x60; - A parameter was inconsistent with other vehicle parameters. Some results like emissions or toll may not be correct.   * &#x60;parameter&#x60; - The inconsistent parameter.   * &#x60;value&#x60; - The value of the inconsistent parameter.   * &#x60;relatedParameter&#x60; - The parameter which caused the parameter in question to be inconsistent.   * &#x60;relatedValue&#x60; - The value which caused the parameter in question to be inconsistent. * &#x60;ROUTING_MISSING_VEHICLE_PARAMETER&#x60; - The requested vehicle contains a parameter which requires another parameter to be specified. Some results like emissions or toll may not be correct.   * &#x60;missingParameter&#x60; - The missing parameter.   * &#x60;relatedParameter&#x60; - The parameter which requires the missing parameter to be specified.   * &#x60;relatedValue&#x60; - The value which requires the missing parameter to be specified. * &#x60;ROUTING_DRIVERS_WORKING_HOURS_WITH_BOAT_OR_RAIL&#x60; - The route contains a boat (ferry) or rail (train or rail shuttle) connection which can lead to incorrect results when **workingHoursPreset** is specified. Breaks may not be scheduled in an optimal way. * &#x60;ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE&#x60; - The requested language is not available for maneuvers, a different language is used instead.   * &#x60;requestedLanguage&#x60; - The language requested by the user.   * &#x60;usedLanguage&#x60; - The language of maneuvers in the response. * &#x60;ROUTING_UNSUPPORTED_EMISSION_PARAMETER&#x60; - The requested emission standard does not support the specified vehicle.   * &#x60;relatedParameter&#x60; - The parameter causing the emission calculation failure.   * &#x60;relatedValue&#x60; - The value of the related parameter. * &#x60;ROUTING_REGION_NOT_SUPPORTED_BY_EMISSION_STANDARD&#x60; - The requested emission standard does not support the region the profile was designed for.   * &#x60;region&#x60; - The requested region not supported by the requested emission standard.   * &#x60;supportedRegions&#x60; - The regions which are supported by the requested emission standard.   * &#x60;emissionStandard&#x60; - The requested emission standard. * &#x60;ROUTING_COUNTRY_IGNORED&#x60; - The country code given in **options[allowedCountries]** or **options[prohibitedCountries]** was ignored as it is not covered by the map.   * &#x60;ignoredCountryCode&#x60; - The ignored country code. * &#x60;ROUTING_SUBDIVISION_FALLBACK&#x60; - The country code given in **options[allowedCountries]** contains a country subdivision code that is not supported by the map, and that instead the enclosing country code was used. In such cases, routes are constrained to the country, rather than only the subdivision.   * &#x60;requestedSubdivisionCode&#x60; - The country subdivision code that was requested, but cannot be used.   * &#x60;fallbackCountryCode&#x60; - The enclosing country that is used as a fallback instead. * &#x60;ROUTING_LIVE_TRAFFIC_DATA_UNAVAILABLE&#x60; - Live traffic data are temporarily unavailable. * &#x60;ROUTING_ETC_SUBSCRIPTION_REQUIRED&#x60; - The route passes through toll areas but the configured vehicle does not contain the required electronic toll collection subscriptions.   * &#x60;requiredEtcSubscriptions&#x60; - The required electronic toll collection subscriptions. * &#x60;ROUTING_WAYPOINT_MATCH_DISTANCE&#x60; - The distance from the waypoint to the nearest accessible road is greater than 1000 meters. Closed areas, countries or roads can be the reason for this.   * &#x60;distance&#x60;- The air-line distance between waypoint and match point on the road.   * &#x60;parameter&#x60; - The waypoint parameter. * &#x60;ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED&#x60; - The combined-transport waypoint was ignored as no connection could be found.   * &#x60;parameter&#x60; - The waypoint parameter.   * &#x60;availableConnections&#x60; - The list of connections available for the start coordinates (array of strings). This will only be returned if connections for the start coordinates are found, but none match the destination coordinates. * &#x60;ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS&#x60; - The combined-transport waypoint was ambiguous.   * &#x60;parameter&#x60; - The waypoint parameter.   * &#x60;usedConnection&#x60; - The connection used for this route.   * &#x60;availableConnections&#x60; - The list of connections available for the combined-transport waypoint (array of strings). * &#x60;ROUTING_WAYPOINTS_DONT_MATCH_PROFILE_REGION&#x60; - The waypoints or the routeId do not match the region of the profile specified in the request.   * &#x60;waypointsRegion&#x60; - The region of the waypoints or routeId.   * &#x60;profileRegion&#x60; - The region of the profile. * &#x60;ROUTING_INACTIVE_ROADATTRIBUTE_SCENARIOS&#x60; - The scenarios given in options[customRoadAttributeScenarios] contain at least one which is not active.   * &#x60;scenarios&#x60; - The inactive scenarioIds (comma-separated list). * &#x60;ROUTING_ROADATTRIBUTES_MAYBE_IGNORED&#x60; - At least one of the scenarios given in options[customRoadAttributeScenarios] could not be fully considered in the route calculation after a map update, i.e. some road attributes may have been ignored.  (required).</param>
        /// <param name="details">Additional properties specific to this class of warnings..</param>
        public Warning(string description = default(string), string warningCode = default(string), Dictionary<string, Object> details = default(Dictionary<string, Object>))
        {
            // to ensure "description" is required (not null)
            if (description == null)
            {
                throw new ArgumentNullException("description is a required property for Warning and cannot be null");
            }
            this.Description = description;
            // to ensure "warningCode" is required (not null)
            if (warningCode == null)
            {
                throw new ArgumentNullException("warningCode is a required property for Warning and cannot be null");
            }
            this.WarningCode = warningCode;
            this.Details = details;
        }
        /// <summary>
        /// A human readable message that describes the warning.
        /// </summary>
        /// <value>A human readable message that describes the warning.</value>
        [DataMember(Name = "description", IsRequired = true, EmitDefaultValue = true)]
        public string Description { get; set; }
        /// <summary>
        /// A constant string that can be used to identify this warning class programmatically. A warningCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional warningCodes as well as the **details** of existing warningCodes may be added at any time. Furthermore, the **description** may change at any time.    * &#x60;GENERAL_PARAMETER_IGNORED&#x60; - A parameter was ignored.   * &#x60;parameter&#x60; - The ignored parameter.   * &#x60;value&#x60; - The value of the ignored parameter.   * &#x60;relatedParameter&#x60; - The parameter which caused the parameter in question to be ignored.   * &#x60;relatedValue&#x60; - The value which caused the parameter in question to be ignored. Not present if the conflict is independent of the value. * &#x60;ROUTING_PARAMETER_INCONSISTENCY&#x60; - A parameter was inconsistent with other vehicle parameters. Some results like emissions or toll may not be correct.   * &#x60;parameter&#x60; - The inconsistent parameter.   * &#x60;value&#x60; - The value of the inconsistent parameter.   * &#x60;relatedParameter&#x60; - The parameter which caused the parameter in question to be inconsistent.   * &#x60;relatedValue&#x60; - The value which caused the parameter in question to be inconsistent. * &#x60;ROUTING_MISSING_VEHICLE_PARAMETER&#x60; - The requested vehicle contains a parameter which requires another parameter to be specified. Some results like emissions or toll may not be correct.   * &#x60;missingParameter&#x60; - The missing parameter.   * &#x60;relatedParameter&#x60; - The parameter which requires the missing parameter to be specified.   * &#x60;relatedValue&#x60; - The value which requires the missing parameter to be specified. * &#x60;ROUTING_DRIVERS_WORKING_HOURS_WITH_BOAT_OR_RAIL&#x60; - The route contains a boat (ferry) or rail (train or rail shuttle) connection which can lead to incorrect results when **workingHoursPreset** is specified. Breaks may not be scheduled in an optimal way. * &#x60;ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE&#x60; - The requested language is not available for maneuvers, a different language is used instead.   * &#x60;requestedLanguage&#x60; - The language requested by the user.   * &#x60;usedLanguage&#x60; - The language of maneuvers in the response. * &#x60;ROUTING_UNSUPPORTED_EMISSION_PARAMETER&#x60; - The requested emission standard does not support the specified vehicle.   * &#x60;relatedParameter&#x60; - The parameter causing the emission calculation failure.   * &#x60;relatedValue&#x60; - The value of the related parameter. * &#x60;ROUTING_REGION_NOT_SUPPORTED_BY_EMISSION_STANDARD&#x60; - The requested emission standard does not support the region the profile was designed for.   * &#x60;region&#x60; - The requested region not supported by the requested emission standard.   * &#x60;supportedRegions&#x60; - The regions which are supported by the requested emission standard.   * &#x60;emissionStandard&#x60; - The requested emission standard. * &#x60;ROUTING_COUNTRY_IGNORED&#x60; - The country code given in **options[allowedCountries]** or **options[prohibitedCountries]** was ignored as it is not covered by the map.   * &#x60;ignoredCountryCode&#x60; - The ignored country code. * &#x60;ROUTING_SUBDIVISION_FALLBACK&#x60; - The country code given in **options[allowedCountries]** contains a country subdivision code that is not supported by the map, and that instead the enclosing country code was used. In such cases, routes are constrained to the country, rather than only the subdivision.   * &#x60;requestedSubdivisionCode&#x60; - The country subdivision code that was requested, but cannot be used.   * &#x60;fallbackCountryCode&#x60; - The enclosing country that is used as a fallback instead. * &#x60;ROUTING_LIVE_TRAFFIC_DATA_UNAVAILABLE&#x60; - Live traffic data are temporarily unavailable. * &#x60;ROUTING_ETC_SUBSCRIPTION_REQUIRED&#x60; - The route passes through toll areas but the configured vehicle does not contain the required electronic toll collection subscriptions.   * &#x60;requiredEtcSubscriptions&#x60; - The required electronic toll collection subscriptions. * &#x60;ROUTING_WAYPOINT_MATCH_DISTANCE&#x60; - The distance from the waypoint to the nearest accessible road is greater than 1000 meters. Closed areas, countries or roads can be the reason for this.   * &#x60;distance&#x60;- The air-line distance between waypoint and match point on the road.   * &#x60;parameter&#x60; - The waypoint parameter. * &#x60;ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED&#x60; - The combined-transport waypoint was ignored as no connection could be found.   * &#x60;parameter&#x60; - The waypoint parameter.   * &#x60;availableConnections&#x60; - The list of connections available for the start coordinates (array of strings). This will only be returned if connections for the start coordinates are found, but none match the destination coordinates. * &#x60;ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS&#x60; - The combined-transport waypoint was ambiguous.   * &#x60;parameter&#x60; - The waypoint parameter.   * &#x60;usedConnection&#x60; - The connection used for this route.   * &#x60;availableConnections&#x60; - The list of connections available for the combined-transport waypoint (array of strings). * &#x60;ROUTING_WAYPOINTS_DONT_MATCH_PROFILE_REGION&#x60; - The waypoints or the routeId do not match the region of the profile specified in the request.   * &#x60;waypointsRegion&#x60; - The region of the waypoints or routeId.   * &#x60;profileRegion&#x60; - The region of the profile. * &#x60;ROUTING_INACTIVE_ROADATTRIBUTE_SCENARIOS&#x60; - The scenarios given in options[customRoadAttributeScenarios] contain at least one which is not active.   * &#x60;scenarios&#x60; - The inactive scenarioIds (comma-separated list). * &#x60;ROUTING_ROADATTRIBUTES_MAYBE_IGNORED&#x60; - At least one of the scenarios given in options[customRoadAttributeScenarios] could not be fully considered in the route calculation after a map update, i.e. some road attributes may have been ignored. 
        /// </summary>
        /// <value>A constant string that can be used to identify this warning class programmatically. A warningCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional warningCodes as well as the **details** of existing warningCodes may be added at any time. Furthermore, the **description** may change at any time.    * &#x60;GENERAL_PARAMETER_IGNORED&#x60; - A parameter was ignored.   * &#x60;parameter&#x60; - The ignored parameter.   * &#x60;value&#x60; - The value of the ignored parameter.   * &#x60;relatedParameter&#x60; - The parameter which caused the parameter in question to be ignored.   * &#x60;relatedValue&#x60; - The value which caused the parameter in question to be ignored. Not present if the conflict is independent of the value. * &#x60;ROUTING_PARAMETER_INCONSISTENCY&#x60; - A parameter was inconsistent with other vehicle parameters. Some results like emissions or toll may not be correct.   * &#x60;parameter&#x60; - The inconsistent parameter.   * &#x60;value&#x60; - The value of the inconsistent parameter.   * &#x60;relatedParameter&#x60; - The parameter which caused the parameter in question to be inconsistent.   * &#x60;relatedValue&#x60; - The value which caused the parameter in question to be inconsistent. * &#x60;ROUTING_MISSING_VEHICLE_PARAMETER&#x60; - The requested vehicle contains a parameter which requires another parameter to be specified. Some results like emissions or toll may not be correct.   * &#x60;missingParameter&#x60; - The missing parameter.   * &#x60;relatedParameter&#x60; - The parameter which requires the missing parameter to be specified.   * &#x60;relatedValue&#x60; - The value which requires the missing parameter to be specified. * &#x60;ROUTING_DRIVERS_WORKING_HOURS_WITH_BOAT_OR_RAIL&#x60; - The route contains a boat (ferry) or rail (train or rail shuttle) connection which can lead to incorrect results when **workingHoursPreset** is specified. Breaks may not be scheduled in an optimal way. * &#x60;ROUTING_MANEUVERS_IN_DIFFERENT_LANGUAGE&#x60; - The requested language is not available for maneuvers, a different language is used instead.   * &#x60;requestedLanguage&#x60; - The language requested by the user.   * &#x60;usedLanguage&#x60; - The language of maneuvers in the response. * &#x60;ROUTING_UNSUPPORTED_EMISSION_PARAMETER&#x60; - The requested emission standard does not support the specified vehicle.   * &#x60;relatedParameter&#x60; - The parameter causing the emission calculation failure.   * &#x60;relatedValue&#x60; - The value of the related parameter. * &#x60;ROUTING_REGION_NOT_SUPPORTED_BY_EMISSION_STANDARD&#x60; - The requested emission standard does not support the region the profile was designed for.   * &#x60;region&#x60; - The requested region not supported by the requested emission standard.   * &#x60;supportedRegions&#x60; - The regions which are supported by the requested emission standard.   * &#x60;emissionStandard&#x60; - The requested emission standard. * &#x60;ROUTING_COUNTRY_IGNORED&#x60; - The country code given in **options[allowedCountries]** or **options[prohibitedCountries]** was ignored as it is not covered by the map.   * &#x60;ignoredCountryCode&#x60; - The ignored country code. * &#x60;ROUTING_SUBDIVISION_FALLBACK&#x60; - The country code given in **options[allowedCountries]** contains a country subdivision code that is not supported by the map, and that instead the enclosing country code was used. In such cases, routes are constrained to the country, rather than only the subdivision.   * &#x60;requestedSubdivisionCode&#x60; - The country subdivision code that was requested, but cannot be used.   * &#x60;fallbackCountryCode&#x60; - The enclosing country that is used as a fallback instead. * &#x60;ROUTING_LIVE_TRAFFIC_DATA_UNAVAILABLE&#x60; - Live traffic data are temporarily unavailable. * &#x60;ROUTING_ETC_SUBSCRIPTION_REQUIRED&#x60; - The route passes through toll areas but the configured vehicle does not contain the required electronic toll collection subscriptions.   * &#x60;requiredEtcSubscriptions&#x60; - The required electronic toll collection subscriptions. * &#x60;ROUTING_WAYPOINT_MATCH_DISTANCE&#x60; - The distance from the waypoint to the nearest accessible road is greater than 1000 meters. Closed areas, countries or roads can be the reason for this.   * &#x60;distance&#x60;- The air-line distance between waypoint and match point on the road.   * &#x60;parameter&#x60; - The waypoint parameter. * &#x60;ROUTING_COMBINED_TRANSPORT_WAYPOINT_IGNORED&#x60; - The combined-transport waypoint was ignored as no connection could be found.   * &#x60;parameter&#x60; - The waypoint parameter.   * &#x60;availableConnections&#x60; - The list of connections available for the start coordinates (array of strings). This will only be returned if connections for the start coordinates are found, but none match the destination coordinates. * &#x60;ROUTING_COMBINED_TRANSPORT_WAYPOINT_AMBIGUOUS&#x60; - The combined-transport waypoint was ambiguous.   * &#x60;parameter&#x60; - The waypoint parameter.   * &#x60;usedConnection&#x60; - The connection used for this route.   * &#x60;availableConnections&#x60; - The list of connections available for the combined-transport waypoint (array of strings). * &#x60;ROUTING_WAYPOINTS_DONT_MATCH_PROFILE_REGION&#x60; - The waypoints or the routeId do not match the region of the profile specified in the request.   * &#x60;waypointsRegion&#x60; - The region of the waypoints or routeId.   * &#x60;profileRegion&#x60; - The region of the profile. * &#x60;ROUTING_INACTIVE_ROADATTRIBUTE_SCENARIOS&#x60; - The scenarios given in options[customRoadAttributeScenarios] contain at least one which is not active.   * &#x60;scenarios&#x60; - The inactive scenarioIds (comma-separated list). * &#x60;ROUTING_ROADATTRIBUTES_MAYBE_IGNORED&#x60; - At least one of the scenarios given in options[customRoadAttributeScenarios] could not be fully considered in the route calculation after a map update, i.e. some road attributes may have been ignored. </value>
        [DataMember(Name = "warningCode", IsRequired = true, EmitDefaultValue = true)]
        public string WarningCode { get; set; }
        /// <summary>
        /// Additional properties specific to this class of warnings.
        /// </summary>
        /// <value>Additional properties specific to this class of warnings.</value>
        [DataMember(Name = "details", EmitDefaultValue = false)]
        public Dictionary<string, Object> Details { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Warning {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  WarningCode: ").Append(WarningCode).Append("\n");
            sb.Append("  Details: ").Append(Details).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Warning);
        }
        /// <summary>
        /// Returns true if Warning instances are equal
        /// </summary>
        /// <param name="input">Instance of Warning to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Warning input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.WarningCode == input.WarningCode ||
                    (this.WarningCode != null &&
                    this.WarningCode.Equals(input.WarningCode))
                ) && 
                (
                    this.Details == input.Details ||
                    this.Details != null &&
                    input.Details != null &&
                    this.Details.SequenceEqual(input.Details)
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.WarningCode != null)
                {
                    hashCode = (hashCode * 59) + this.WarningCode.GetHashCode();
                }
                if (this.Details != null)
                {
                    hashCode = (hashCode * 59) + this.Details.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Waypoint
    /// </summary>
    [DataContract(Name = "Waypoint")]
    public partial class Waypoint : IEquatable<Waypoint>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Waypoint" /> class.
        /// </summary>
        /// <param name="name">An identifier to reference this waypoint in the response..</param>
        /// <param name="onRoad">onRoad.</param>
        /// <param name="offRoad">offRoad.</param>
        /// <param name="manipulate">manipulate.</param>
        /// <param name="combinedTransport">combinedTransport.</param>
        public Waypoint(string name = default(string), OnRoadWaypoint onRoad = default(OnRoadWaypoint), OffRoadWaypoint offRoad = default(OffRoadWaypoint), ManipulateRouteWaypoint manipulate = default(ManipulateRouteWaypoint), CombinedTransport combinedTransport = default(CombinedTransport))
        {
            this.Name = name;
            this.OnRoad = onRoad;
            this.OffRoad = offRoad;
            this.Manipulate = manipulate;
            this.CombinedTransport = combinedTransport;
        }
        /// <summary>
        /// An identifier to reference this waypoint in the response.
        /// </summary>
        /// <value>An identifier to reference this waypoint in the response.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }
        /// <summary>
        /// Gets or Sets OnRoad
        /// </summary>
        [DataMember(Name = "onRoad", EmitDefaultValue = false)]
        public OnRoadWaypoint OnRoad { get; set; }
        /// <summary>
        /// Gets or Sets OffRoad
        /// </summary>
        [DataMember(Name = "offRoad", EmitDefaultValue = false)]
        public OffRoadWaypoint OffRoad { get; set; }
        /// <summary>
        /// Gets or Sets Manipulate
        /// </summary>
        [DataMember(Name = "manipulate", EmitDefaultValue = false)]
        public ManipulateRouteWaypoint Manipulate { get; set; }
        /// <summary>
        /// Gets or Sets CombinedTransport
        /// </summary>
        [DataMember(Name = "combinedTransport", EmitDefaultValue = false)]
        public CombinedTransport CombinedTransport { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Waypoint {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  OnRoad: ").Append(OnRoad).Append("\n");
            sb.Append("  OffRoad: ").Append(OffRoad).Append("\n");
            sb.Append("  Manipulate: ").Append(Manipulate).Append("\n");
            sb.Append("  CombinedTransport: ").Append(CombinedTransport).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Waypoint);
        }
        /// <summary>
        /// Returns true if Waypoint instances are equal
        /// </summary>
        /// <param name="input">Instance of Waypoint to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Waypoint input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.OnRoad == input.OnRoad ||
                    (this.OnRoad != null &&
                    this.OnRoad.Equals(input.OnRoad))
                ) && 
                (
                    this.OffRoad == input.OffRoad ||
                    (this.OffRoad != null &&
                    this.OffRoad.Equals(input.OffRoad))
                ) && 
                (
                    this.Manipulate == input.Manipulate ||
                    (this.Manipulate != null &&
                    this.Manipulate.Equals(input.Manipulate))
                ) && 
                (
                    this.CombinedTransport == input.CombinedTransport ||
                    (this.CombinedTransport != null &&
                    this.CombinedTransport.Equals(input.CombinedTransport))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.OnRoad != null)
                {
                    hashCode = (hashCode * 59) + this.OnRoad.GetHashCode();
                }
                if (this.OffRoad != null)
                {
                    hashCode = (hashCode * 59) + this.OffRoad.GetHashCode();
                }
                if (this.Manipulate != null)
                {
                    hashCode = (hashCode * 59) + this.Manipulate.GetHashCode();
                }
                if (this.CombinedTransport != null)
                {
                    hashCode = (hashCode * 59) + this.CombinedTransport.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Issued when a waypoint is reached by the route, but not for route-manipulation waypoints. Requires _WAYPOINT_EVENTS_ to be requested.
    /// </summary>
    [DataContract(Name = "WaypointEvent")]
    public partial class WaypointEvent : IEquatable<WaypointEvent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WaypointEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected WaypointEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="WaypointEvent" /> class.
        /// </summary>
        /// <param name="index">The index of the waypoint in the request. (required).</param>
        /// <param name="name">The name of the waypoint as given in the request. This field is only present if it is not empty..</param>
        public WaypointEvent(int index = default(int), string name = default(string))
        {
            this.Index = index;
            this.Name = name;
        }
        /// <summary>
        /// The index of the waypoint in the request.
        /// </summary>
        /// <value>The index of the waypoint in the request.</value>
        [DataMember(Name = "index", IsRequired = true, EmitDefaultValue = true)]
        public int Index { get; set; }
        /// <summary>
        /// The name of the waypoint as given in the request. This field is only present if it is not empty.
        /// </summary>
        /// <value>The name of the waypoint as given in the request. This field is only present if it is not empty.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class WaypointEvent {\n");
            sb.Append("  Index: ").Append(Index).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as WaypointEvent);
        }
        /// <summary>
        /// Returns true if WaypointEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of WaypointEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(WaypointEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Index == input.Index ||
                    this.Index.Equals(input.Index)
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Index.GetHashCode();
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Index (int) minimum
            if (this.Index < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Index, must be a value greater than or equal to 0.", new [] { "Index" });
            }
            yield break;
        }
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Enables the calculation of break and rest times according to the selected rules. Breaks and rests will be added to the **travelTime**, details can be requested through the _SCHEDULE_EVENTS_. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY&#x60; - Based on Regulation (EC) 561/2006 of the European Parliament and of the Council.   Break time 45 min, maximum driving time between breaks 4.5 hours, maximum driving time 9 hours, maximum travel time 13 hours.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY&#x60; - In contrast to &#x60;EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY&#x60;,   the exception rules \&quot;Maximum driving time may be extended to 10h twice a week.\&quot; and \&quot;A daily rest may be reduced to 9h three times between weekly rests.\&quot;   are observed in so far as the driving time limit is extended and the daily rest time is reduced.   * &#x60;EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY&#x60; - Based on Directive 2002/15/EC of the European Parliament and of the Council \&quot;on the organisation of the working time of persons performing mobile road transport activities\&quot;.   Break time 30 min, maximum working time between breaks 6 hours, maximum travel time 9.5 hours.   * &#x60;EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY&#x60; - Makes sure that the standard rules of the EU directives 2003/88/EC and 2002/15/EC that are applicable for a route within a long single day are observed.   If working hours total more than 9h, a break must be 45min long. Here, a working time of at most 10h is guaranteed.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS &#x60; - Based on Regulation (EC) 561/2006 of the European Parliament and of the Council.   Break time 45 min, maximum driving time between breaks 4.5 hours,   daily rest time 11 hours, maximum driving time between daily rests 9 hours, maximum travel time between daily rests 13 hours,   maximum driving time 56 hours, maximum travel time 144 hours.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS&#x60; - When two drivers form a team, they can take turns.   In contrast to &#x60;EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS&#x60;, no breaks are scheduled and the daily rest time limits are raised.   * &#x60;US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY&#x60; - Based on Hours of Service (HOS) of Drivers as issued by the Federal Motor Carrier Safety Administration (FMCSA).   Break time 30 min, maximum driving time between breaks 8 hours, maximum driving time 11 hours, maximum travel time 14 hours.   * &#x60;US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY&#x60; - Makes sure that the standard rules of the HOS regulations in 49 CFR 395 that are applicable for a route within a single day are observed.   It is assumed that the short-haul exception does apply so breaks are not scheduled.   * &#x60;US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS&#x60; - Based on Hours of Service (HOS) of Drivers as issued by the Federal Motor Carrier Safety Administration (FMCSA).   Break time 30 min, maximum driving time between breaks 8 hours,   daily rest time 10 hours, maximum driving time between daily rests 11 hours, maximum travel time between daily rests 14 hours.  If this parameter is given both as query parameter and in the body then it must match. Otherwise an error is returned.   For details see this [concept](./concepts/drivers-working-hours).
    /// </summary>
    /// <value>Enables the calculation of break and rest times according to the selected rules. Breaks and rests will be added to the **travelTime**, details can be requested through the _SCHEDULE_EVENTS_. This parameter will be ignored for non-motorized profiles such as _BICYCLE_ or _PEDESTRIAN_.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY&#x60; - Based on Regulation (EC) 561/2006 of the European Parliament and of the Council.   Break time 45 min, maximum driving time between breaks 4.5 hours, maximum driving time 9 hours, maximum travel time 13 hours.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY&#x60; - In contrast to &#x60;EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY&#x60;,   the exception rules \&quot;Maximum driving time may be extended to 10h twice a week.\&quot; and \&quot;A daily rest may be reduced to 9h three times between weekly rests.\&quot;   are observed in so far as the driving time limit is extended and the daily rest time is reduced.   * &#x60;EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY&#x60; - Based on Directive 2002/15/EC of the European Parliament and of the Council \&quot;on the organisation of the working time of persons performing mobile road transport activities\&quot;.   Break time 30 min, maximum working time between breaks 6 hours, maximum travel time 9.5 hours.   * &#x60;EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY&#x60; - Makes sure that the standard rules of the EU directives 2003/88/EC and 2002/15/EC that are applicable for a route within a long single day are observed.   If working hours total more than 9h, a break must be 45min long. Here, a working time of at most 10h is guaranteed.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS &#x60; - Based on Regulation (EC) 561/2006 of the European Parliament and of the Council.   Break time 45 min, maximum driving time between breaks 4.5 hours,   daily rest time 11 hours, maximum driving time between daily rests 9 hours, maximum travel time between daily rests 13 hours,   maximum driving time 56 hours, maximum travel time 144 hours.   * &#x60;EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS&#x60; - When two drivers form a team, they can take turns.   In contrast to &#x60;EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS&#x60;, no breaks are scheduled and the daily rest time limits are raised.   * &#x60;US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY&#x60; - Based on Hours of Service (HOS) of Drivers as issued by the Federal Motor Carrier Safety Administration (FMCSA).   Break time 30 min, maximum driving time between breaks 8 hours, maximum driving time 11 hours, maximum travel time 14 hours.   * &#x60;US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY&#x60; - Makes sure that the standard rules of the HOS regulations in 49 CFR 395 that are applicable for a route within a single day are observed.   It is assumed that the short-haul exception does apply so breaks are not scheduled.   * &#x60;US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS&#x60; - Based on Hours of Service (HOS) of Drivers as issued by the Federal Motor Carrier Safety Administration (FMCSA).   Break time 30 min, maximum driving time between breaks 8 hours,   daily rest time 10 hours, maximum driving time between daily rests 11 hours, maximum travel time between daily rests 14 hours.  If this parameter is given both as query parameter and in the body then it must match. Otherwise an error is returned.   For details see this [concept](./concepts/drivers-working-hours).</value>
    [JsonConverter(typeof(StringEnumConverter))]
    public enum WorkingHoursPreset
    {
        /// <summary>
        /// Enum EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY for value: EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY
        /// </summary>
        [EnumMember(Value = "EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY")]
        EU_DRIVING_TIME_REGULATION_FOR_SINGLE_DAY = 1,
        /// <summary>
        /// Enum EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY for value: EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY
        /// </summary>
        [EnumMember(Value = "EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY")]
        EU_DRIVING_TIME_REGULATION_FOR_LONG_SINGLE_DAY = 2,
        /// <summary>
        /// Enum EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY for value: EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY
        /// </summary>
        [EnumMember(Value = "EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY")]
        EU_WORKING_TIME_DIRECTIVE_FOR_SINGLE_DAY = 3,
        /// <summary>
        /// Enum EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY for value: EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY
        /// </summary>
        [EnumMember(Value = "EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY")]
        EU_WORKING_TIME_DIRECTIVES_FOR_LONG_SINGLE_DAY = 4,
        /// <summary>
        /// Enum EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS for value: EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS
        /// </summary>
        [EnumMember(Value = "EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS")]
        EU_DRIVING_TIME_REGULATION_FOR_MULTIPLE_DAYS = 5,
        /// <summary>
        /// Enum EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS for value: EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS
        /// </summary>
        [EnumMember(Value = "EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS")]
        EU_DRIVING_TIME_REGULATION_FOR_TEAM_AND_MULTIPLE_DAYS = 6,
        /// <summary>
        /// Enum US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY for value: US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY
        /// </summary>
        [EnumMember(Value = "US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY")]
        US_HOURS_OF_SERVICE_REGULATIONS_FOR_SINGLE_DAY = 7,
        /// <summary>
        /// Enum US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY for value: US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY
        /// </summary>
        [EnumMember(Value = "US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY")]
        US_HOURS_OF_SERVICE_REGULATIONS_FOR_SHORT_HAUL_AND_SINGLE_DAY = 8,
        /// <summary>
        /// Enum US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS for value: US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS
        /// </summary>
        [EnumMember(Value = "US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS")]
        US_HOURS_OF_SERVICE_REGULATIONS_FOR_MULTIPLE_DAYS = 9
    }
}

/*
 * Routing
 *
 * With the Routing service you can calculate routes from A to B taking into account vehicle-specific restrictions, traffic situations, toll, emissions, driver's working hours, service times and opening intervals.
 *
 * The version of the OpenAPI document: 1.22
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
namespace RoutingClient.Model
{
    /// <summary>
    /// Defines the accumulated driving, working and travel times since the last break or daily rest. For details see this [concept](./concepts/drivers-working-hours).
    /// </summary>
    [DataContract(Name = "WorkLogbook")]
    public partial class WorkLogbook : IEquatable<WorkLogbook>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WorkLogbook" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected WorkLogbook() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="WorkLogbook" /> class.
        /// </summary>
        /// <param name="lastTimeTheDriverWorked">The last time the driver worked formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).   The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The date must provide an offset to UTC.   See [here](./concepts/date-and-time) for more information on the relevance of date and time. (required).</param>
        /// <param name="accumulatedDrivingTimeSinceLastBreak">Accumulated driving time since end of last break [s], this includes all time behind the wheel.   Values higher than the maximum driving time between breaks of the **workingHoursPreset** are capped and effectively equal to the value given by the preset.  (default to 0).</param>
        /// <param name="accumulatedWorkingTimeSinceLastBreak">Accumulated working time since end of last break [s], this includes driving time, service time at depot and customers, and idle time if lower than working time threshold.     Values higher than the maximum working time between breaks of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. May not be smaller than **accumulatedDrivingTimeSinceLastBreak** if the value is specified. If no other value is specified, the default value is 0. .</param>
        /// <param name="accumulatedDrivingTimeSinceLastDailyRest">Accumulated driving time since end of last daily rest [s], this includes all time behind the wheel.   Values higher than the maximum driving time between daily rests of the **workingHoursPreset** are capped and effectively equal to the value given by preset. May not be smaller than **accumulatedDrivingTimeSinceLastBreak** if the value is specified. If no other value is specified, the default value is 0. .</param>
        /// <param name="accumulatedTravelTimeSinceLastDailyRest">Accumulated travel time since end of last daily rest [s], this includes all time since the last daily rest.   Values higher than maximum travel time between daily rests of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. May not be smaller than **accumulatedWorkingTimeSinceLastBreak** or **accumulatedDrivingTimeSinceLastDailyRest** if the values are specified. If no other value is specified, the default value is 0. .</param>
        public WorkLogbook(DateTime? lastTimeTheDriverWorked = default(DateTime?), int accumulatedDrivingTimeSinceLastBreak = 0, int? accumulatedWorkingTimeSinceLastBreak = default(int?), int? accumulatedDrivingTimeSinceLastDailyRest = default(int?), int? accumulatedTravelTimeSinceLastDailyRest = default(int?))
        {
            // to ensure "lastTimeTheDriverWorked" is required (not null)
            if (lastTimeTheDriverWorked == null)
            {
                throw new ArgumentNullException("lastTimeTheDriverWorked is a required property for WorkLogbook and cannot be null");
            }
            this.LastTimeTheDriverWorked = lastTimeTheDriverWorked;
            this.AccumulatedDrivingTimeSinceLastBreak = accumulatedDrivingTimeSinceLastBreak;
            this.AccumulatedWorkingTimeSinceLastBreak = accumulatedWorkingTimeSinceLastBreak;
            this.AccumulatedDrivingTimeSinceLastDailyRest = accumulatedDrivingTimeSinceLastDailyRest;
            this.AccumulatedTravelTimeSinceLastDailyRest = accumulatedTravelTimeSinceLastDailyRest;
        }
        /// <summary>
        /// The last time the driver worked formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).   The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The date must provide an offset to UTC.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.
        /// </summary>
        /// <value>The last time the driver worked formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).   The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  The date must provide an offset to UTC.   See [here](./concepts/date-and-time) for more information on the relevance of date and time.</value>
        /// <example>2020-12-04T06:00Z</example>
        [DataMember(Name = "lastTimeTheDriverWorked", IsRequired = true, EmitDefaultValue = true)]
        public DateTime? LastTimeTheDriverWorked { get; set; }
        /// <summary>
        /// Accumulated driving time since end of last break [s], this includes all time behind the wheel.   Values higher than the maximum driving time between breaks of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. 
        /// </summary>
        /// <value>Accumulated driving time since end of last break [s], this includes all time behind the wheel.   Values higher than the maximum driving time between breaks of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. </value>
        [DataMember(Name = "accumulatedDrivingTimeSinceLastBreak", EmitDefaultValue = false)]
        public int AccumulatedDrivingTimeSinceLastBreak { get; set; }
        /// <summary>
        /// Accumulated working time since end of last break [s], this includes driving time, service time at depot and customers, and idle time if lower than working time threshold.     Values higher than the maximum working time between breaks of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. May not be smaller than **accumulatedDrivingTimeSinceLastBreak** if the value is specified. If no other value is specified, the default value is 0. 
        /// </summary>
        /// <value>Accumulated working time since end of last break [s], this includes driving time, service time at depot and customers, and idle time if lower than working time threshold.     Values higher than the maximum working time between breaks of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. May not be smaller than **accumulatedDrivingTimeSinceLastBreak** if the value is specified. If no other value is specified, the default value is 0. </value>
        [DataMember(Name = "accumulatedWorkingTimeSinceLastBreak", EmitDefaultValue = true)]
        public int? AccumulatedWorkingTimeSinceLastBreak { get; set; }
        /// <summary>
        /// Accumulated driving time since end of last daily rest [s], this includes all time behind the wheel.   Values higher than the maximum driving time between daily rests of the **workingHoursPreset** are capped and effectively equal to the value given by preset. May not be smaller than **accumulatedDrivingTimeSinceLastBreak** if the value is specified. If no other value is specified, the default value is 0. 
        /// </summary>
        /// <value>Accumulated driving time since end of last daily rest [s], this includes all time behind the wheel.   Values higher than the maximum driving time between daily rests of the **workingHoursPreset** are capped and effectively equal to the value given by preset. May not be smaller than **accumulatedDrivingTimeSinceLastBreak** if the value is specified. If no other value is specified, the default value is 0. </value>
        [DataMember(Name = "accumulatedDrivingTimeSinceLastDailyRest", EmitDefaultValue = true)]
        public int? AccumulatedDrivingTimeSinceLastDailyRest { get; set; }
        /// <summary>
        /// Accumulated travel time since end of last daily rest [s], this includes all time since the last daily rest.   Values higher than maximum travel time between daily rests of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. May not be smaller than **accumulatedWorkingTimeSinceLastBreak** or **accumulatedDrivingTimeSinceLastDailyRest** if the values are specified. If no other value is specified, the default value is 0. 
        /// </summary>
        /// <value>Accumulated travel time since end of last daily rest [s], this includes all time since the last daily rest.   Values higher than maximum travel time between daily rests of the **workingHoursPreset** are capped and effectively equal to the value given by the preset. May not be smaller than **accumulatedWorkingTimeSinceLastBreak** or **accumulatedDrivingTimeSinceLastDailyRest** if the values are specified. If no other value is specified, the default value is 0. </value>
        [DataMember(Name = "accumulatedTravelTimeSinceLastDailyRest", EmitDefaultValue = true)]
        public int? AccumulatedTravelTimeSinceLastDailyRest { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class WorkLogbook {\n");
            sb.Append("  LastTimeTheDriverWorked: ").Append(LastTimeTheDriverWorked).Append("\n");
            sb.Append("  AccumulatedDrivingTimeSinceLastBreak: ").Append(AccumulatedDrivingTimeSinceLastBreak).Append("\n");
            sb.Append("  AccumulatedWorkingTimeSinceLastBreak: ").Append(AccumulatedWorkingTimeSinceLastBreak).Append("\n");
            sb.Append("  AccumulatedDrivingTimeSinceLastDailyRest: ").Append(AccumulatedDrivingTimeSinceLastDailyRest).Append("\n");
            sb.Append("  AccumulatedTravelTimeSinceLastDailyRest: ").Append(AccumulatedTravelTimeSinceLastDailyRest).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as WorkLogbook);
        }
        /// <summary>
        /// Returns true if WorkLogbook instances are equal
        /// </summary>
        /// <param name="input">Instance of WorkLogbook to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(WorkLogbook input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.LastTimeTheDriverWorked == input.LastTimeTheDriverWorked ||
                    (this.LastTimeTheDriverWorked != null &&
                    this.LastTimeTheDriverWorked.Equals(input.LastTimeTheDriverWorked))
                ) && 
                (
                    this.AccumulatedDrivingTimeSinceLastBreak == input.AccumulatedDrivingTimeSinceLastBreak ||
                    this.AccumulatedDrivingTimeSinceLastBreak.Equals(input.AccumulatedDrivingTimeSinceLastBreak)
                ) && 
                (
                    this.AccumulatedWorkingTimeSinceLastBreak == input.AccumulatedWorkingTimeSinceLastBreak ||
                    (this.AccumulatedWorkingTimeSinceLastBreak != null &&
                    this.AccumulatedWorkingTimeSinceLastBreak.Equals(input.AccumulatedWorkingTimeSinceLastBreak))
                ) && 
                (
                    this.AccumulatedDrivingTimeSinceLastDailyRest == input.AccumulatedDrivingTimeSinceLastDailyRest ||
                    (this.AccumulatedDrivingTimeSinceLastDailyRest != null &&
                    this.AccumulatedDrivingTimeSinceLastDailyRest.Equals(input.AccumulatedDrivingTimeSinceLastDailyRest))
                ) && 
                (
                    this.AccumulatedTravelTimeSinceLastDailyRest == input.AccumulatedTravelTimeSinceLastDailyRest ||
                    (this.AccumulatedTravelTimeSinceLastDailyRest != null &&
                    this.AccumulatedTravelTimeSinceLastDailyRest.Equals(input.AccumulatedTravelTimeSinceLastDailyRest))
                );
        }
        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.LastTimeTheDriverWorked != null)
                {
                    hashCode = (hashCode * 59) + this.LastTimeTheDriverWorked.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AccumulatedDrivingTimeSinceLastBreak.GetHashCode();
                if (this.AccumulatedWorkingTimeSinceLastBreak != null)
                {
                    hashCode = (hashCode * 59) + this.AccumulatedWorkingTimeSinceLastBreak.GetHashCode();
                }
                if (this.AccumulatedDrivingTimeSinceLastDailyRest != null)
                {
                    hashCode = (hashCode * 59) + this.AccumulatedDrivingTimeSinceLastDailyRest.GetHashCode();
                }
                if (this.AccumulatedTravelTimeSinceLastDailyRest != null)
                {
                    hashCode = (hashCode * 59) + this.AccumulatedTravelTimeSinceLastDailyRest.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // AccumulatedDrivingTimeSinceLastBreak (int) minimum
            if (this.AccumulatedDrivingTimeSinceLastBreak < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AccumulatedDrivingTimeSinceLastBreak, must be a value greater than or equal to 0.", new [] { "AccumulatedDrivingTimeSinceLastBreak" });
            }
            // AccumulatedWorkingTimeSinceLastBreak (int?) minimum
            if (this.AccumulatedWorkingTimeSinceLastBreak < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AccumulatedWorkingTimeSinceLastBreak, must be a value greater than or equal to 0.", new [] { "AccumulatedWorkingTimeSinceLastBreak" });
            }
            // AccumulatedDrivingTimeSinceLastDailyRest (int?) minimum
            if (this.AccumulatedDrivingTimeSinceLastDailyRest < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AccumulatedDrivingTimeSinceLastDailyRest, must be a value greater than or equal to 0.", new [] { "AccumulatedDrivingTimeSinceLastDailyRest" });
            }
            // AccumulatedTravelTimeSinceLastDailyRest (int?) minimum
            if (this.AccumulatedTravelTimeSinceLastDailyRest < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AccumulatedTravelTimeSinceLastDailyRest, must be a value greater than or equal to 0.", new [] { "AccumulatedTravelTimeSinceLastDailyRest" });
            }
            yield break;
        }
    }
}

